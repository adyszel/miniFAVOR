var tipuesearch = {"pages":[{"text":"miniFAVOR miniFAVOR Documentation Organization Top Navigation Bar Getting Help miniFAVOR Documentation Welcome to the miniFAVOR documentation.\nThis online documentation is automatically generated from inline comments and static analysis using the FORD tool. Organization The FORD tool is used to document Modern Fortran source code. Top Navigation Bar You can navigate through the source code by using the black navigation bar at the top of this landing page. In addition, the search box on the right side of the top navbar, the following link is available: Source Files : This landing page enumerates the source files associated with the project,\n  includes a graph depicting their interdependencies and links to their dedicated pages. Getting Help If you encounter a problem, have a suggestion, or want to ask a question,\nwe encourage you to post an issue in this projects Github repository by opening a new issue .","tags":"home","loc":"index.html","title":" miniFAVOR "},{"text":"PROGRAM: miniFAVOR PURPOSE:  Entry point for the console application. Contents Programs minifavor Source Code miniFAVOR.f90 Source Code !  miniFAVOR.f90 ! !  FUNCTIONS: !  miniFAVOR - Entry point of console application. ! !**************************************************************************** ! !  PROGRAM: miniFAVOR ! !  PURPOSE:  Entry point for the console application. ! !**************************************************************************** program miniFAVOR use I_O , only : read_In , write_Out use calc_RTndt , only : RTndt , CF , sample_chem use calc_K , only : Ki_t use calc_cpi , only : cpi_t use randomness_m , only : random_samples_t implicit none ! Variables character ( len = 64 ) :: fn_IN integer , parameter :: n_IN = 15 integer , parameter :: n_ECHO = n_IN + 1 integer , parameter :: n_OUT = n_IN + 2 integer , parameter :: n_DAT = n_IN + 3 integer :: i , j , num_seeds type ( random_samples_t ), allocatable :: samples (:) ! Inputs real :: a , b integer :: nsim , ntime logical :: details real , dimension (:), allocatable :: stress , temp real :: Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 ! Outputs real , allocatable :: K_hist (:) real , allocatable :: Chemistry_factor (:) real , allocatable :: R_Tndt (:) real , allocatable :: CPI (:) real , allocatable :: CPI_avg (:) real , dimension (:,:), allocatable :: Chemistry_content real , dimension (:,:), allocatable :: cpi_hist integer , parameter :: nmaterials = 2 ! Body of miniFAVOR !Get input file name call random_seed ( size = num_seeds ) call random_seed ( put = [( i , i = 1 , num_seeds )]) print * , 'Input file name:' read ( * , '(a)' ) fn_IN !Read input file call read_IN ( fn_IN , n_IN , n_ECHO , & a , b , nsim , ntime , details , Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 , stress , temp ) !Allocate output arrays allocate ( Chemistry_content ( nsim , nmaterials )) allocate ( Chemistry_factor ( nsim )) allocate ( cpi_hist ( nsim , ntime )) allocate ( R_Tndt ( nsim ), CPI ( nsim ), CPI_avg ( nsim ), samples ( nsim )) !Calculate applied stress intensity factor (SIF) K_hist = Ki_t ( a , b , stress ) ! This cannot be parallelized or reordered without the results changing do i = 1 , nsim call samples ( i )% define () end do !Start looping over number of simulations Vessel_loop : do i = 1 , nsim !Sample chemistry: Chemistry_content(i,1) is Cu content, Chemistry_content(i,2) is Ni content call sample_chem ( Cu_ave , Ni_ave , Cu_sig , Ni_sig , Chemistry_content ( i , 1 ), Chemistry_content ( i , 2 ), samples ( i )) !Calculate chemistry factor: Chemistry_factor(i) is chemistry factor Chemistry_factor ( i ) = CF ( Chemistry_content ( i , 1 ), Chemistry_content ( i , 2 )) !Calculate RTndt for this vessel trial: CPI_results(i,1) is RTndt R_Tndt ( i ) = RTndt ( a , Chemistry_factor ( i ), fsurf , RTndt0 , samples ( i )% phi ()) !Start time loop Time_loop : do j = 1 , ntime !Calculate instantaneous cpi(t) cpi_hist ( i , j ) = cpi_t ( K_hist ( j ), R_Tndt ( i ), temp ( j )) end do Time_loop !Calculate CPI for vessel 'i' CPI ( i ) = maxval ( cpi_hist ( i ,:)) !Calculate moving average CPI for trials executed so far CPI_avg ( i ) = sum ( CPI ( 1 : i )) / i end do Vessel_loop call write_OUT ( fn_IN , n_OUT , n_DAT , & a , b , nsim , ntime , details , Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 , & R_Tndt , CPI , CPI_avg , K_hist , Chemistry_content , Chemistry_factor ) end program miniFAVOR","tags":"","loc":"sourcefile/minifavor.f90.html","title":"miniFAVOR.f90 – miniFAVOR"},{"text":"Contents Modules i_o Source Code I_O.f90 Source Code module I_O implicit none contains subroutine read_IN ( fn_IN , n_IN , n_ECHO , & a , b , nsim , ntime , details , Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 , stress , temp ) !Variables integer , intent ( in ) :: n_IN , n_ECHO character ( len = 64 ), intent ( in ) :: fn_IN real , intent ( out ) :: a , b , Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 integer , intent ( out ) :: nsim , ntime logical , intent ( out ) :: details real , allocatable , intent ( out ) :: stress (:), temp (:) character ( len = 64 ) :: fn_ECHO integer :: i !Open input file and create echo file open ( unit = n_IN , file = fn_IN , status = 'old' , form = 'formatted' ) fn_ECHO = fn_IN ( 1 : index ( fn_IN , '.in' ) - 1 ) // '.echo' open ( unit = n_ECHO , file = fn_ECHO , status = 'unknown' , form = 'formatted' ) !Read and echo crack depth and vessel thickness read ( n_IN , * ) a , b write ( n_ECHO , '(a25,f10.3,a)' ) 'Crack Depth: ' , a , ' in' write ( n_ECHO , '(a25,f10.3,a)' ) 'Vessel Thickness: ' , b , ' in' !Read and echo number of simulations to be performed andnumber of time steps read ( n_IN , * ) nsim , ntime write ( n_ECHO , '(a25,i10)' ) 'Number of Simulations: ' , nsim write ( n_ECHO , '(a25,i10)' ) 'Number of Time Steps: ' , ntime !Read in and echo type of output to be written read ( n_IN , * ) details write ( n_ECHO , '(a25,l10)' ) 'Detailed output: ' , details !Read and echo embrittlement inputs read ( n_IN , * ) Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 write ( n_ECHO , '(a25,f10.3,a)' ) 'Copper Content: ' , Cu_ave , ' %' write ( n_ECHO , '(a25,f10.3,a)' ) 'Nickel Content: ' , Ni_ave , ' %' write ( n_ECHO , '(a25,f10.3,a)' ) 'Copper Content STDEV: ' , Cu_sig , ' %' write ( n_ECHO , '(a25,f10.3,a)' ) 'Nickel Content STDEV: ' , Ni_sig , ' %' write ( n_ECHO , '(a25,f10.3,a)' ) 'ID Surface Fluence: ' , fsurf , ' n/cm&#94;2' write ( n_ECHO , '(a25,f10.3,a)' ) 'Unirradiated RTndt: ' , RTndt0 , ' degF' !Allocate stress and temperature arrays allocate ( stress ( ntime )) allocate ( temp ( ntime )) !Read and echo stress and temerature inputs write ( n_ECHO , '(a)' ) 'Stress (ksi),      Temperature (degF)' read_transient : do i = 1 , ntime read ( n_IN , * ) stress ( i ), temp ( i ) write ( n_ECHO , '(f10.3,9x,f10.3)' ) stress ( i ), temp ( i ) end do read_transient end subroutine read_IN subroutine write_OUT ( fn_IN , n_OUT , n_DAT , & a , b , nsim , ntime , details , Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 , & R_Tndt , CPI , CPI_avg , K_hist , Chemistry_content , Chemistry_factor ) !Variables character ( len = 64 ), intent ( in ) :: fn_IN integer , intent ( in ) :: n_OUT , n_DAT real , intent ( in ) :: a , b , Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 integer , intent ( in ) :: nsim , ntime logical , intent ( in ) :: details real , intent ( in ) :: K_hist (:), Chemistry_content (:,:), Chemistry_factor (:) real , intent ( in ) :: R_Tndt (:) real , intent ( in ) :: CPI (:) real , intent ( in ) :: CPI_avg (:) character ( len = 64 ) :: fn_OUT , fn_DAT integer :: i !Open output file fn_OUT = fn_IN ( 1 : index ( fn_IN , '.in' ) - 1 ) // '.out' open ( unit = n_OUT , file = fn_OUT , status = 'unknown' , form = 'formatted' ) !Write out important outputs summary write ( n_OUT , '(a)' ) 'MiniFAVOR Output Summary' write ( n_OUT , '(a)' ) '/Key inputs/' write ( n_OUT , '(a25,f10.3,a)' ) 'Crack Depth: ' , a , ' in' write ( n_OUT , '(a25,f10.3,a)' ) 'Vessel Thickness: ' , b , ' in' write ( n_OUT , '(a25,i10)' ) 'Number of Simulations: ' , nsim write ( n_OUT , '(a25,f10.3,a)' ) 'Copper Content: ' , Cu_ave , ' %' write ( n_OUT , '(a25,f10.3,a)' ) 'Nickel Content: ' , Ni_ave , ' %' write ( n_OUT , '(a25,f10.3,a)' ) 'Copper Content STDEV: ' , Cu_sig , ' %' write ( n_OUT , '(a25,f10.3,a)' ) 'Nickel Content STDEV: ' , Ni_sig , ' %' write ( n_OUT , '(a25,f10.3,a)' ) 'ID Surface Fluence: ' , fsurf , ' n/cm&#94;2' write ( n_OUT , '(a25,f10.3,a)' ) 'Unirradiated RTndt: ' , RTndt0 , ' degF' write ( n_OUT , '(a)' ) '/Results/' write ( n_OUT , '(a25,f10.3)' ) 'Final CPI: ' , CPI_avg ( nsim ) write ( n_OUT , '(a25,f10.3,a)' ) 'Minimum crack tip RTndt: ' , & minval ( R_Tndt ), ' degF' write ( n_OUT , '(a25,f10.3,a)' ) 'Maximum crack tip  RTndt: ' , & maxval ( R_Tndt ), ' degF' write ( n_OUT , '(a25,f10.3,a)' ) 'Average crack tip RTndt: ' , & sum ( R_Tndt ) / nsim , ' degF' !Write out detailed output to data file if ( details ) then fn_DAT = fn_IN ( 1 : index ( fn_IN , '.in' ) - 1 ) // '.dat' open ( unit = n_DAT , file = fn_DAT , status = 'unknown' , form = 'formatted' ) write ( n_DAT , '(a)' ) 'MiniFAVOR Detailed Output' write ( n_DAT , '(a)' ) '/Applied SIF (ksi*in&#94;0.5)/' write_SIF : do i = 1 , ntime write ( n_DAT , '(f10.3)' ) K_hist ( i ) end do write_SIF write ( n_DAT , '(a)' ) '/Chemistry Results' write ( n_DAT , '(a)' ) 'Cu content (%),  Ni Content (%), Chemistry Factor CF' write_chem : do i = 1 , nsim write ( n_DAT , '(3f10.3)' ) Chemistry_content ( i , 1 ), Chemistry_content ( i , 2 ), Chemistry_factor ( i ) end do write_chem write ( n_DAT , '(a)' ) '/Vessel CPI data' write ( n_DAT , '(a)' ) 'Vessel RTndt (degF),  Vessel CPI, Cumulative Average CPI' write_CPI : do i = 1 , nsim write ( n_DAT , '(3f10.3)' ) R_Tndt ( i ), CPI ( i ), CPI_avg ( i ) end do write_CPI end if end subroutine write_OUT end module I_O","tags":"","loc":"sourcefile/i_o.f90.html","title":"I_O.f90 – miniFAVOR"},{"text":"Contents Submodules randomness_s Source Code random_samples_s.f90 Source Code submodule ( randomness_m ) randomness_s use assertions_interface , only : assert implicit none contains module procedure define ! These must be called in this order or the results will change call random_number ( self % Cu_sig_local_ ) call random_number ( self % Cu_local_ ) call random_number ( self % Ni_local_ ) call random_number ( self % phi_ ) call self % mark_as_defined end procedure module procedure write_formatted integer , parameter :: success = 0 select case ( iotype ) case ( 'LISTDIRECTED' ) write ( unit , * ) \"random_samples_t(Cu_sig_local=\" , self % Cu_sig_local_ , \", Cu_local=\" , self % Cu_local_ , & \", Ni_local=\" , self % Ni_local_ , \", phi=\" , self % phi_ , \")\" iostat = success case default block use iso_fortran_env , only : IOSTAT_INQUIRE_INTERNAL_UNIT integer , parameter :: iotype_not_supported = 99 call assert ( iotype_not_supported /= IOSTAT_INQUIRE_INTERNAL_UNIT , \"standard-conforming iostat_value\" ) iostat = iotype_not_supported iomsg = \"iotype not supported\" end block end select end procedure module procedure Cu_sig_local self_Cu_sig_local = self % Cu_sig_local_ end procedure module procedure Cu_local self_Cu_local = self % Cu_local_ end procedure module procedure Ni_local self_Ni_local = self % Ni_local_ end procedure module procedure phi self_phi = self % phi_ end procedure end submodule","tags":"","loc":"sourcefile/random_samples_s.f90.html","title":"random_samples_s.f90 – miniFAVOR"},{"text":"Contents Modules randomness_m Source Code random_samples_m.f90 Source Code module randomness_m use object_interface , only : object implicit none private public :: random_samples_t type , extends ( object ) :: random_samples_t private real :: Cu_sig_local_ real :: Cu_local_ real :: Ni_local_ real :: phi_ contains procedure :: define procedure :: write_formatted procedure :: Cu_sig_local procedure :: Cu_local procedure :: Ni_local procedure :: phi end type interface module subroutine define ( self ) implicit none class ( random_samples_t ), intent ( out ) :: self end subroutine module subroutine write_formatted ( self , unit , iotype , v_list , iostat , iomsg ) implicit none class ( random_samples_t ), intent ( in ) :: self integer , intent ( in ) :: unit character ( * ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg end subroutine pure module function Cu_sig_local ( self ) result ( self_Cu_sig_local ) implicit none class ( random_samples_t ), intent ( in ) :: self real self_Cu_sig_local end function pure module function Cu_local ( self ) result ( self_Cu_local ) implicit none class ( random_samples_t ), intent ( in ) :: self real self_Cu_local end function pure module function Ni_local ( self ) result ( self_Ni_local ) implicit none class ( random_samples_t ), intent ( in ) :: self real self_Ni_local end function pure module function phi ( self ) result ( self_phi ) implicit none class ( random_samples_t ), intent ( in ) :: self real self_phi end function end interface end module","tags":"","loc":"sourcefile/random_samples_m.f90.html","title":"random_samples_m.f90 – miniFAVOR"},{"text":"Contents Modules constants_h Source Code Commons.f90 Source Code module constants_h implicit none real , parameter :: Pi = 4.D0 * DATAN ( 1.D0 ) real , dimension ( 0 : 40 , 7 ), parameter :: CF_weld = reshape (( / & 20 , 20 , 21 , 22 , 24 , 26 , 29 , 32 , 36 , 40 , & 44 , 49 , 52 , 58 , 61 , 66 , 70 , 75 , 79 , 83 , & 88 , 92 , 97 , 101 , 105 , 110 , 113 , 119 , 122 , 128 , & 131 , 136 , 140 , 144 , 149 , 153 , 158 , 162 , 166 , 171 , & 175 , & 20 , 20 , 26 , 35 , 43 , 49 , 52 , 55 , 58 , 61 , & 65 , 68 , 72 , 76 , 79 , 84 , 88 , 92 , 95 , 100 , & 104 , 108 , 112 , 117 , 121 , 126 , 130 , 134 , 138 , 142 , & 146 , 151 , 155 , 160 , 164 , 168 , 172 , 177 , 182 , 185 , & 189 , & 20 , 20 , 27 , 41 , 54 , 67 , 77 , 85 , 90 , 94 , & 97 , 101 , 103 , 106 , 109 , 112 , 115 , 119 , 122 , 126 , & 129 , 133 , 137 , 140 , 144 , 148 , 151 , 155 , 160 , 164 , & 167 , 172 , 175 , 180 , 184 , 187 , 191 , 196 , 200 , 203 , & 207 , & 20 , 20 , 27 , 41 , 54 , 68 , 82 , 95 , 106 , 115 , & 122 , 130 , 135 , 139 , 142 , 146 , 149 , 151 , 154 , 157 , & 160 , 164 , 167 , 169 , 173 , 176 , 180 , 184 , 187 , 191 , & 194 , 198 , 202 , 205 , 209 , 212 , 216 , 220 , 223 , 227 , & 231 , & 20 , 20 , 27 , 41 , 54 , 68 , 82 , 95 , 108 , 122 , & 133 , 144 , 153 , 162 , 168 , 175 , 178 , 184 , 187 , 191 , & 194 , 197 , 200 , 203 , 206 , 209 , 212 , 216 , 218 , 222 , & 225 , 228 , 231 , 234 , 238 , 241 , 245 , 248 , 250 , 254 , & 257 , & 20 , 20 , 27 , 41 , 54 , 68 , 82 , 95 , 108 , 122 , & 135 , 148 , 161 , 172 , 182 , 191 , 199 , 207 , 214 , 220 , & 223 , 229 , 232 , 236 , 239 , 243 , 246 , 249 , 251 , 254 , & 257 , 260 , 263 , 266 , 269 , 272 , 275 , 278 , 281 , 285 , & 288 , & 20 , 20 , 27 , 41 , 54 , 68 , 82 , 95 , 108 , 122 , & 135 , 148 , 161 , 176 , 188 , 200 , 211 , 221 , 230 , 238 , & 245 , 252 , 257 , 263 , 268 , 272 , 276 , 280 , 284 , 287 , & 290 , 293 , 296 , 299 , 302 , 305 , 308 , 311 , 314 , 317 , & 320 / ), [ 41 , 7 ]) end module constants_h","tags":"","loc":"sourcefile/commons.f90.html","title":"Commons.f90 – miniFAVOR"},{"text":"Contents Modules calc_cpi Source Code Calc_cpi.f90 Source Code module calc_cpi implicit none contains !Function to calculate cpi(t) function cpi_t ( K , RTndt , T ) !Variables real :: cpi_t real , intent ( in ) :: K , RTndt , T real :: aKic , bKic , cKic !Calculate aKic, bKic, cKic aKic = 1 9.35 + 8.335 * exp ( 0.02254 * ( T - RTndt )) bKic = 1 5.61 + 5 0.132 * exp ( 0.008 * ( T - RTndt )) cKic = 4.0 !Calculate cpi_t if ( K < aKic ) then cpi_t = 0.0 else cpi_t = 1 - exp ( - (( K - aKic ) / bKic ) ** cKic ) end if end function cpi_t end module calc_cpi","tags":"","loc":"sourcefile/calc_cpi.f90.html","title":"Calc_cpi.f90 – miniFAVOR"},{"text":"Contents Modules calc_rtndt Source Code Calc_RTndt.f90 Source Code module calc_RTndt use assertions_interface , only : assert implicit none contains !RTndt_x calculation function RTndt ( a , CF , fsurf , RTndt0 , phi ) !Variables real :: RTndt , D_RTepi , D_RTndt , f real , intent ( in ) :: a , CF , fsurf , RTndt0 , phi !Calculate D_RTepi D_RTepi = - 2 9.5 + 7 8.0 * ( - log ( 1 - phi )) ** ( 1 / 1.73 ) !Calculate D_RTndt f = fsurf * exp ( - 0.24 * a ) D_RTndt = CF * f ** ( 0.28 - 0.10 * log10 ( f )) !Calculate the RTndt RTndt = RTndt0 + D_RTepi + D_RTndt end function RTndt !This function calculates the weld chemistry factor given the copper and nickel contents function CF ( Cu , Ni ) use constants_h , only : CF_weld !Variables real :: CF real , intent ( in ) :: Cu , Ni integer :: Cu_int , Ni_int real :: CF_1 , CF_2 !Calculate indexes for copper interpolation: !  multiply the Cu-% by 100 and take the integer truncation to find interpolation bounds !  truncate interpolation between 0% and 0.40% Cu_int = int ( Cu * 100 ) if ( Cu_int < 0 ) then Cu_int = 0 else if ( Cu_int > 40 ) then Cu_int = 40 end if !Calculate indexes for nickel interpolation: !  multiply the Ni-% by 100 and take the integer truncation to find interpolation bounds !  truncate interpolation between 0% and 1.20% Ni_int = int ( Ni * 100 ) if ( Ni_int < 0 ) then Ni_int = 0 else if ( Ni_int > 120 ) then Ni_int = 120 end if !Nickel contents in CF_weld are at intervals of 0.20% nickel Ni_int = int ( Ni_int / 20 ) + 1 !Bi-linear interpolation if ( Cu <= 0.0 . or . Cu >= 0.40 ) then !only interpolate on nickel select case ( Ni_int ) case ( 7 ) CF = CF_weld ( Cu_int , Ni_int ) case default CF = CF_weld ( Cu_int , Ni_int ) + & ( Ni - 0.2 * ( Ni_int - 1 )) / 0.2 * ( CF_weld ( Cu_int , Ni_int + 1 ) - CF_weld ( Cu_int , Ni_int )) end select else !First, interpolate on copper select case ( Ni_int ) case ( 7 ) CF = CF_weld ( Cu_int , Ni_int ) + & ( Cu - 0.01 * ( Cu_int )) / 0.01 * ( CF_weld ( Cu_int + 1 , Ni_int ) - CF_weld ( Cu_int + 1 , Ni_int )) case default CF_1 = CF_weld ( Cu_int , Ni_int ) + & ( Cu - 0.01 * ( Cu_int )) / 0.01 * ( CF_weld ( Cu_int + 1 , Ni_int ) - CF_weld ( Cu_int + 1 , Ni_int )) CF_2 = CF_weld ( Cu_int , Ni_int + 1 ) + & ( Cu - 0.01 * ( Cu_int )) / 0.01 * ( CF_weld ( Cu_int + 1 , Ni_int + 1 ) - CF_weld ( Cu_int + 1 , Ni_int + 1 )) !Second, interpolate on nickel CF = CF_1 + ( Ni - 0.2 * ( Ni_int - 1 )) / 0.2 * ( CF_2 - CF_1 ) end select end if end function CF !This subroutine samples the copper and nickel contents based on the nominal value !and the standard deviation subroutine sample_chem ( Cu_ave , Ni_ave , Cu_sig , Ni_sig , Cu_local , Ni_local , samples ) use randomness_m , only : random_samples_t !Variables type ( random_samples_t ), intent ( in ) :: samples real , intent ( in ) :: Cu_ave , Ni_ave , Cu_sig , Ni_sig real , intent ( out ) :: Cu_local , Ni_local real :: Cu_bar , Cu_sig_star , Cu_sig_local ! Requires call assert ( samples % user_defined (), \"random_samples_t%sample_chem: samples%user_defined()\" ) !Sample local copper content based on weld copper sampling procedure Cu_bar = Cu_ave * Cu_sig Cu_sig_star = min ( 0.0718 * Cu_ave , 0.0185 ) Cu_sig_local = Cu_bar + Cu_sig_star * sqrt ( 2.0 ) * erfc ( 2 * samples % Cu_sig_local () - 1 ) Cu_local = Cu_ave + Cu_sig_local * sqrt ( 2.0 ) * erfc ( 2 * samples % Cu_local () - 1 ) !Sample local nickel content based on weld nickel heat 34B009 & W5214 procedure Ni_local = Ni_ave + Ni_sig * sqrt ( 2.0 ) * erfc ( 2 * samples % Ni_local () - 1 ) end subroutine sample_chem end module calc_RTndt","tags":"","loc":"sourcefile/calc_rtndt.f90.html","title":"Calc_RTndt.f90 – miniFAVOR"},{"text":"Contents Modules calc_k Source Code Calc_K.f90 Source Code module calc_K implicit none contains !Function to calculate K(t) elemental function Ki_t ( a , b , stress ) use constants_h , only : Pi !Variables real :: Ki_t real , intent ( in ) :: a , b , stress !Calculate Ki_t Ki_t = stress * sqrt ( Pi * a ) * & ( 1.122 - 0.231 * ( a / b ) + 1 0.55 * ( a / b ) ** 2 - 2 1.71 * ( a / b ) ** 3 + 3 0.382 * ( a / b ) ** 4 ) end function Ki_t end module calc_K","tags":"","loc":"sourcefile/calc_k.f90.html","title":"Calc_K.f90 – miniFAVOR"},{"text":"Contents Modules many1_with_separator_test Source Code many1_with_separator_test.f90 Source Code module many1_with_separator_test implicit none private public :: test_many1_with_separator contains function test_many1_with_separator () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 5 ) individual_tests ( 1 ) = it ( \"can parse one item\" , check_one ) individual_tests ( 2 ) = it ( & \"can parse one item followed by a separator\" , & check_one_with_separator ) individual_tests ( 3 ) = it ( & \"parses until the parser doesn't match\" , check_many ) individual_tests ( 4 ) = it ( & \"leaves a trailing separator\" , check_many_with_separator ) individual_tests ( 5 ) = it ( & \"fails if the first result doesn't match\" , check_none ) tests = describe ( \"many1_with_separator\" , individual_tests ) end function pure function check_one () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_items_t , parser_output_t , many1_with_separator , new_state use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many1_with_separator ( parse_a , parse_comma , new_state ( var_str ( \"AB\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = & assert_equals ( 1 , size ( parsed % items )) & . and . assert_equals ( \"B\" , results % remaining ) class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_one_with_separator () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_items_t , parser_output_t , many1_with_separator , new_state use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many1_with_separator ( parse_a , parse_comma , new_state ( var_str ( \"A,B\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = & assert_equals ( 1 , size ( parsed % items )) & . and . assert_equals ( \",B\" , results % remaining ) class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_many () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_items_t , parser_output_t , many1_with_separator , new_state use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many1_with_separator ( parse_a , parse_comma , new_state ( var_str ( \"A,A,AB\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = & assert_equals ( 3 , size ( parsed % items )) & . and . assert_equals ( \"B\" , results % remaining ) class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_many_with_separator () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_items_t , parser_output_t , many1_with_separator , new_state use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many1_with_separator ( parse_a , parse_comma , new_state ( var_str ( \"A,A,A,B\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = & assert_equals ( 3 , size ( parsed % items )) & . and . assert_equals ( \",B\" , results % remaining ) class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_none () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , many1_with_separator , new_state use vegetables , only : result_t , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many1_with_separator ( parse_a , parse_comma , new_state ( var_str ( \"BAA\" ))) result_ = assert_not ( results % ok , results % message % to_string ()) end function pure function parse_a ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"A\" , state_ ) end function pure function parse_comma ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \",\" , state_ ) end function end module","tags":"","loc":"sourcefile/many1_with_separator_test.f90.html","title":"many1_with_separator_test.f90 – miniFAVOR"},{"text":"Contents Modules parse_string_test Source Code parse_string_test.f90 Source Code module parse_string_test implicit none private public :: test_parse_string contains function test_parse_string () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( & \"Parsing the first part of a string consumes that string\" , & check_pass ) individual_tests ( 2 ) = it ( & \"Parsing something else produces an error\" , & check_fail ) tests = describe ( \"parse_string\" , individual_tests ) end function pure function check_pass () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_string_t , parser_output_t , new_state , parse_string use vegetables , only : & result_t , assert_equals , assert_not , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_string ( \"Hello\" , new_state ( var_str ( \"Hello World\" ))) result_ = & assert_that ( parse_result % ok , \"Got result\" , \"Didn't get result\" ) & . and . assert_not ( parse_result % empty , \"Wasn't empty\" , \"Was empty\" ) if ( result_ % passed ()) then select type ( the_string => parse_result % parsed ) type is ( parsed_string_t ) result_ = & assert_equals ( \"Hello\" , the_string % value_ ) & . and . assert_equals ( \" World\" , parse_result % remaining ) class default result_ = fail ( \"Didn't get a string back\" ) end select end if end function pure function check_fail () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , parse_string use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_string ( \"Hello\" , new_state ( var_str ( \"World\" ))) result_ = & assert_not ( parse_result % ok ) & . and . assert_equals ( \"W\" , parse_result % message % found ) & . and . assert_equals ( \"Hello\" , parse_result % message % expected ( 1 )) end function end module","tags":"","loc":"sourcefile/parse_string_test.f90.html","title":"parse_string_test.f90 – miniFAVOR"},{"text":"Contents Modules parse_whitespace_test Source Code parse_whitespace_test.f90 Source Code module parse_whitespace_test implicit none private public :: test_parse_whitespace contains function test_parse_whitespace () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"Parsing the first character in a string consumes that character\" , & check_parse_first_character ) individual_tests ( 2 ) = it ( & \"Parsing a different character produces an error\" , & check_parse_different_character ) individual_tests ( 3 ) = it ( & \"Parsing an empty string produces an error\" , & check_parse_empty_string ) tests = describe ( \"parse_whitespace\" , individual_tests ) end function pure function check_parse_first_character () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_character_t , parser_output_t , new_state , parse_whitespace use vegetables , only : & result_t , assert_equals , assert_not , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_whitespace ( new_state ( var_str ( \" First\" ))) result_ = & assert_that ( parse_result % ok , \"Got result\" , \"Didn't get result\" ) & . and . assert_not ( parse_result % empty , \"Wasn't empty\" , \"Was empty\" ) if ( result_ % passed ()) then select type ( the_char => parse_result % parsed ) type is ( parsed_character_t ) result_ = & assert_equals ( \" \" , the_char % value_ ) & . and . assert_equals ( \"First\" , parse_result % remaining ) class default result_ = fail ( \"Didn't get a character back\" ) end select end if end function pure function check_parse_different_character () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , parse_whitespace use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_whitespace ( new_state ( var_str ( \"First\" ))) result_ = & assert_not ( parse_result % ok ) & . and . assert_equals ( \"F\" , parse_result % message % found ) & . and . assert_equals ( \"whitespace\" , parse_result % message % expected ( 1 )) end function pure function check_parse_empty_string () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , parse_whitespace use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_whitespace ( new_state ( var_str ( \"\" ))) result_ = & assert_not ( parse_result % ok ) & . and . assert_equals ( \"end of input\" , parse_result % message % found ) & . and . assert_equals ( \"whitespace\" , parse_result % message % expected ( 1 )) end function end module","tags":"","loc":"sourcefile/parse_whitespace_test.f90.html","title":"parse_whitespace_test.f90 – miniFAVOR"},{"text":"Contents Modules sequence_test Source Code sequence_test.f90 Source Code module sequence_test implicit none private public :: test_sequence contains function test_sequence () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"When both parses pass, the results are combined\" , & check_both_pass ) individual_tests ( 2 ) = it ( & \"When the first parse fails, that error comes back\" , & check_first_fail ) individual_tests ( 3 ) = it ( & \"When the second parse fails, that error comes back\" , & check_second_fail ) tests = describe ( \"sequence\" , individual_tests ) end function pure function check_both_pass () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parsed_string_t , parser_output_t , new_state , sequence use vegetables , only : result_t , assert_equals , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = sequence ( parse_a , then_parse_b , new_state ( var_str ( \"AB\" ))) result_ = assert_that ( parse_result % ok ) if ( result_ % passed ()) then select type ( string => parse_result % parsed ) type is ( parsed_string_t ) result_ = assert_equals ( \"AB\" , string % value_ ) class default result_ = fail ( \"Didn't get string back\" ) end select end if end function pure function check_first_fail () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , sequence use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = sequence ( parse_a , then_parse_b , new_state ( var_str ( \"BB\" ))) result_ = assert_not ( parse_result % ok ) if ( result_ % passed ()) then result_ = & assert_equals ( \"B\" , parse_result % message % found ) & . and . assert_equals ( \"A\" , parse_result % message % expected ( 1 )) end if end function pure function check_second_fail () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , sequence use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = sequence ( parse_a , then_parse_b , new_state ( var_str ( \"AA\" ))) result_ = assert_not ( parse_result % ok ) if ( result_ % passed ()) then result_ = & assert_equals ( \"A\" , parse_result % message % found ) & . and . assert_equals ( \"B\" , parse_result % message % expected ( 1 )) end if end function pure function parse_a ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"A\" , state_ ) end function pure function then_parse_b ( previous , state_ ) result ( result_ ) use iso_varying_string , only : assignment ( = ) use parff , only : & parsed_character_t , & parsed_string_t , & parsed_value_t , & parser_output_t , & state_t , & parse_char class ( parsed_value_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( parsed_string_t ) :: parsed result_ = parse_char ( \"B\" , state_ ) if ( result_ % ok ) then select type ( previous ) type is ( parsed_character_t ) select type ( next => result_ % parsed ) type is ( parsed_character_t ) parsed % value_ = previous % value_ // next % value_ end select end select deallocate ( result_ % parsed ) allocate ( result_ % parsed , source = parsed ) end if end function end module","tags":"","loc":"sourcefile/sequence_test.f90.html","title":"sequence_test.f90 – miniFAVOR"},{"text":"Contents Modules many1_test Source Code many1_test.f90 Source Code module many1_test implicit none private public :: test_many1 contains function test_many1 () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( \"can parse one item\" , check_parse_one ) individual_tests ( 2 ) = it ( & \"parses until the parser doesn't match\" , check_many ) individual_tests ( 3 ) = it ( & \"fails if the first result doesn't match\" , check_none ) tests = describe ( \"many1\" , individual_tests ) end function pure function check_parse_one () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parsed_items_t , parser_output_t , many1 , new_state use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many1 ( parse_a , new_state ( var_str ( \"AB\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = & assert_equals ( 1 , size ( parsed % items )) & . and . assert_equals ( \"B\" , results % remaining ) class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_many () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parsed_items_t , parser_output_t , many1 , new_state use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many1 ( parse_a , new_state ( var_str ( \"AAB\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = & assert_equals ( 2 , size ( parsed % items )) & . and . assert_equals ( \"B\" , results % remaining ) class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_none () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , many1 , new_state use vegetables , only : result_t , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many1 ( parse_a , new_state ( var_str ( \"BAA\" ))) result_ = assert_not ( results % ok , results % message % to_string ()) end function pure function parse_a ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"A\" , state_ ) end function end module","tags":"","loc":"sourcefile/many1_test.f90.html","title":"many1_test.f90 – miniFAVOR"},{"text":"Contents Modules many_test Source Code many_test.f90 Source Code module many_test implicit none private public :: test_many contains function test_many () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( \"can parse one item\" , check_one ) individual_tests ( 2 ) = it ( & \"parses until the parser doesn't match\" , check_many ) individual_tests ( 3 ) = it ( & \"returns empty if the first result doesn't match\" , check_none ) tests = describe ( \"many\" , individual_tests ) end function pure function check_one () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parsed_items_t , parser_output_t , many , new_state use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many ( parse_a , new_state ( var_str ( \"AB\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = & assert_equals ( 1 , size ( parsed % items )) & . and . assert_equals ( \"B\" , results % remaining ) class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_many () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parsed_items_t , parser_output_t , many , new_state use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many ( parse_a , new_state ( var_str ( \"AAAB\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = & assert_equals ( 3 , size ( parsed % items )) & . and . assert_equals ( \"B\" , results % remaining ) class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_none () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , many , new_state use vegetables , only : result_t , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many ( parse_a , new_state ( var_str ( \"BAA\" ))) if ( results % ok ) then result_ = assert_that ( results % empty ) else result_ = fail ( results % message % to_string ()) end if end function pure function parse_a ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"A\" , state_ ) end function end module","tags":"","loc":"sourcefile/many_test.f90.html","title":"many_test.f90 – miniFAVOR"},{"text":"Contents Programs main Source Code main.f90 Source Code ! Generated by make_vegetable_driver. DO NOT EDIT program main implicit none call run () contains subroutine run () use drop_then_test , only : & drop_then_drop_then => test_drop_then use either_test , only : & either_either => test_either use many1_test , only : & many1_many1 => test_many1 use many1_with_separator_test , only : & many1_with_separator_many1_with_separator => test_many1_with_separator use many_test , only : & many_many => test_many use many_with_separator_test , only : & many_with_separator_many_with_separator => test_many_with_separator use optionally_test , only : & optionally_optionally => test_optionally use parse_character_test , only : & parse_character_parse_character => test_parse_character use parse_digit_test , only : & parse_digit_parse_digit => test_parse_digit use parse_integer_test , only : & parse_integer_parse_integer => test_parse_integer use parse_rational_test , only : & parse_rational_parse_rational => test_parse_rational use parse_string_test , only : & parse_string_parse_string => test_parse_string use parse_whitespace_test , only : & parse_whitespace_parse_whitespace => test_parse_whitespace use parse_with_test , only : & parse_with_parse_with => test_parse_with use repeat_test , only : & repeat_repeat => test_repeat use sequence_test , only : & sequence_sequence => test_sequence use then_drop_test , only : & then_drop_then_drop => test_then_drop use vegetables , only : test_item_t , test_that , run_tests type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 17 ) individual_tests ( 1 ) = drop_then_drop_then () individual_tests ( 2 ) = either_either () individual_tests ( 3 ) = many1_many1 () individual_tests ( 4 ) = many1_with_separator_many1_with_separator () individual_tests ( 5 ) = many_many () individual_tests ( 6 ) = many_with_separator_many_with_separator () individual_tests ( 7 ) = optionally_optionally () individual_tests ( 8 ) = parse_character_parse_character () individual_tests ( 9 ) = parse_digit_parse_digit () individual_tests ( 10 ) = parse_integer_parse_integer () individual_tests ( 11 ) = parse_rational_parse_rational () individual_tests ( 12 ) = parse_string_parse_string () individual_tests ( 13 ) = parse_whitespace_parse_whitespace () individual_tests ( 14 ) = parse_with_parse_with () individual_tests ( 15 ) = repeat_repeat () individual_tests ( 16 ) = sequence_sequence () individual_tests ( 17 ) = then_drop_then_drop () tests = test_that ( individual_tests ) call run_tests ( tests ) end subroutine end program","tags":"","loc":"sourcefile/main.f90.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Modules repeat_test Source Code repeat_test.f90 Source Code module repeat_test implicit none private public :: test_repeat contains function test_repeat () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( & \"uses the parser the given number of times\" , check_repeat ) individual_tests ( 2 ) = it ( & \"fails if it can't parse that many\" , check_not_enough ) tests = describe ( \"repeat\" , individual_tests ) end function pure function check_repeat () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parsed_items_t , parser_output_t , new_state , repeat_ use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = repeat_ ( parse_a , 2 , new_state ( var_str ( \"AA\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = assert_equals ( 2 , size ( parsed % items )) class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_not_enough () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , repeat_ use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: results results = repeat_ ( parse_a , 3 , new_state ( var_str ( \"AAB\" ))) result_ = assert_not ( results % ok ) if ( result_ % passed ()) then result_ = & assert_equals ( \"B\" , results % message % found ) & . and . assert_equals ( \"A\" , results % message % expected ( 1 )) end if end function pure function parse_a ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"A\" , state_ ) end function end module","tags":"","loc":"sourcefile/repeat_test.f90.html","title":"repeat_test.f90 – miniFAVOR"},{"text":"Contents Modules parse_rational_test Source Code parse_rational_test.f90 Source Code module parse_rational_test use iso_varying_string , only : varying_string use vegetables , only : Input_t implicit none private type , extends ( Input_t ) :: number_input_t type ( varying_string ) :: string double precision :: value_ end type type , extends ( Input_t ) :: invalid_input_t type ( varying_string ) :: string end type public :: test_parse_rational contains function test_parse_rational () result ( tests ) use iso_varying_string , only : var_str use vegetables , only : Example_t , test_item_t , describe , Example , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) type ( Example_t ) :: invalid_examples ( 6 ) type ( Example_t ) :: number_examples ( 10 ) number_examples ( 1 ) = Example ( number_input_t ( var_str ( \"1\" ), 1.0d0 )) number_examples ( 2 ) = Example ( number_input_t ( var_str ( \"-2\" ), - 2.0d0 )) number_examples ( 3 ) = Example ( number_input_t ( var_str ( \"+3\" ), 3.0d0 )) number_examples ( 4 ) = Example ( number_input_t ( var_str ( \"4.\" ), 4.0d0 )) number_examples ( 5 ) = Example ( number_input_t ( var_str ( \"5.0\" ), 5.0d0 )) number_examples ( 6 ) = Example ( number_input_t ( var_str ( \".6\" ), 0.6d0 )) number_examples ( 7 ) = Example ( number_input_t ( var_str ( \"7e8\" ), 7.0d8 )) number_examples ( 8 ) = Example ( number_input_t ( var_str ( \"9.E-1\" ), 9.0d-1 )) number_examples ( 9 ) = Example ( number_input_t ( var_str ( \".2d+3\" ), 0.2d3 )) number_examples ( 10 ) = Example ( number_input_t ( var_str ( \"4.0D5\" ), 4.0d5 )) invalid_examples ( 1 ) = Example ( invalid_input_t ( var_str ( \"a\" ))) invalid_examples ( 2 ) = Example ( invalid_input_t ( var_str ( \"-b\" ))) invalid_examples ( 3 ) = Example ( invalid_input_t ( var_str ( \"+c\" ))) invalid_examples ( 4 ) = Example ( invalid_input_t ( var_str ( \".\" ))) invalid_examples ( 5 ) = Example ( invalid_input_t ( var_str ( \".e\" ))) invalid_examples ( 6 ) = Example ( invalid_input_t ( var_str ( \"-d+\" ))) individual_tests ( 1 ) = it ( & \"Can parse various numbers\" , & number_examples , & check_parse_rational ) individual_tests ( 2 ) = it ( & \"Parsing invalid numbers produce errors\" , & invalid_examples , & check_parse_invalid ) individual_tests ( 3 ) = it ( & \"Parsing an empty string produces an error\" , check_parse_empty ) tests = describe ( \"parse_rational\" , individual_tests ) end function pure function check_parse_rational ( input ) result ( result_ ) use parff , only : & parsed_rational_t , parser_output_t , new_state , parse_rational use vegetables , only : Input_t , result_t , assert_equals , fail class ( Input_t ), intent ( in ) :: input type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result select type ( input ) type is ( number_input_t ) parse_result = parse_rational ( new_state ( input % string )) if ( parse_result % ok ) then select type ( parsed => parse_result % parsed ) type is ( parsed_rational_t ) result_ = assert_equals ( & input % value_ , parsed % value_ , input % string ) class default result_ = fail ( \"Didn't get an integer back\" ) end select else result_ = fail ( parse_result % message % to_string ()) end if class default result_ = fail ( \"Expected to get a number_input_t\" ) end select end function pure function check_parse_invalid ( input ) result ( result_ ) use parff , only : parser_output_t , new_state , parse_rational use vegetables , only : Input_t , result_t , assert_not , fail class ( Input_t ), intent ( in ) :: input type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result select type ( input ) type is ( invalid_input_t ) parse_result = parse_rational ( new_state ( input % string )) result_ = assert_not ( & parse_result % ok , parse_result % message % to_string ()) class default result_ = fail ( \"Expected to get an invalid_input_tt\" ) end select end function pure function check_parse_empty () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , parse_rational use vegetables , only : Input_t , result_t , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_rational ( new_state ( var_str ( \"\" ))) result_ = assert_not ( & parse_result % ok , parse_result % message % to_string ()) end function end module","tags":"","loc":"sourcefile/parse_rational_test.f90.html","title":"parse_rational_test.f90 – miniFAVOR"},{"text":"Contents Modules drop_then_test Source Code drop_then_test.f90 Source Code module drop_then_test implicit none private public :: test_drop_then contains function test_drop_then () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"When both parses pass, we get the results of the second one\" , & check_both_pass ) individual_tests ( 2 ) = it ( & \"When the first parse fails, that error comes back\" , & check_first_fail ) individual_tests ( 3 ) = it ( & \"When the second parse fails, that error comes back\" , & check_second_fail ) tests = describe ( \"drop_then\" , individual_tests ) end function pure function check_both_pass () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parsed_character_t , parser_output_t , drop_then , new_state use vegetables , only : result_t , assert_equals , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = drop_then ( parse_a , parse_b , new_state ( var_str ( \"AB\" ))) result_ = assert_that ( parse_result % ok ) if ( result_ % passed ()) then select type ( string => parse_result % parsed ) type is ( parsed_character_t ) result_ = assert_equals ( \"B\" , string % value_ ) class default result_ = fail ( \"Didn't get character back\" ) end select end if end function pure function check_first_fail () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , drop_then , new_state use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = drop_then ( parse_a , parse_b , new_state ( var_str ( \"BB\" ))) result_ = assert_not ( parse_result % ok ) if ( result_ % passed ()) then result_ = & assert_equals ( \"B\" , parse_result % message % found ) & . and . assert_equals ( \"A\" , parse_result % message % expected ( 1 )) end if end function pure function check_second_fail () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , drop_then , new_state use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = drop_then ( parse_a , parse_b , new_state ( var_str ( \"AA\" ))) result_ = assert_not ( parse_result % ok ) if ( result_ % passed ()) then result_ = & assert_equals ( \"A\" , parse_result % message % found ) & . and . assert_equals ( \"B\" , parse_result % message % expected ( 1 )) end if end function pure function parse_a ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"A\" , state_ ) end function pure function parse_b ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"B\" , state_ ) end function end module","tags":"","loc":"sourcefile/drop_then_test.f90.html","title":"drop_then_test.f90 – miniFAVOR"},{"text":"Contents Modules parse_with_test Source Code parse_with_test.f90 Source Code module parse_with_test implicit none private public :: test_parse_with contains function test_parse_with () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( & \"Gets the parsed result back if successful\" , & check_successful ) individual_tests ( 2 ) = it ( & \"Gets a message back if failed\" , & check_failure ) tests = describe ( \"parse_with\" , individual_tests ) end function pure function check_successful () result ( result_ ) use parff , only : parse_result_t , parsed_character_t , parse_with use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parse_result_t ) :: the_result the_result = parse_with ( the_parser , \"A\" ) if ( the_result % ok ) then select type ( parsed => the_result % parsed ) type is ( parsed_character_t ) result_ = assert_equals ( \"A\" , parsed % value_ ) class default result_ = fail ( \"Didn't get a character back\" ) end select else result_ = fail ( the_result % message ) end if end function pure function check_failure () result ( result_ ) use parff , only : parse_result_t , parse_with use vegetables , only : result_t , assert_not type ( result_t ) :: result_ type ( parse_result_t ) :: the_result the_result = parse_with ( the_parser , \"B\" ) result_ = assert_not ( the_result % ok , the_result % message ) end function pure function the_parser ( state ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state type ( parser_output_t ) :: result_ result_ = parse_char ( \"A\" , state ) end function end module","tags":"","loc":"sourcefile/parse_with_test.f90.html","title":"parse_with_test.f90 – miniFAVOR"},{"text":"Contents Modules then_drop_test Source Code then_drop_test.f90 Source Code module then_drop_test implicit none private public :: test_then_drop contains function test_then_drop () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"When both parses pass, we get the results of the first one\" , & check_both_pass ) individual_tests ( 2 ) = it ( & \"When the first parse fails, that error comes back\" , & check_first_fail ) individual_tests ( 3 ) = it ( & \"When the second parse fails, that error comes back\" , & check_second_fail ) tests = describe ( \"then_drop\" , individual_tests ) end function pure function check_both_pass () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_character_t , parser_output_t , new_state , then_drop use vegetables , only : result_t , assert_equals , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = then_drop ( parse_a , parse_b , new_state ( var_str ( \"AB\" ))) result_ = assert_that ( parse_result % ok ) if ( result_ % passed ()) then select type ( string => parse_result % parsed ) type is ( parsed_character_t ) result_ = assert_equals ( \"A\" , string % value_ ) class default result_ = fail ( \"Didn't get character back\" ) end select end if end function pure function check_first_fail () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , then_drop use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = then_drop ( parse_a , parse_b , new_state ( var_str ( \"BB\" ))) result_ = assert_not ( parse_result % ok ) if ( result_ % passed ()) then result_ = & assert_equals ( \"B\" , parse_result % message % found ) & . and . assert_equals ( \"A\" , parse_result % message % expected ( 1 )) end if end function pure function check_second_fail () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , then_drop use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = then_drop ( parse_a , parse_b , new_state ( var_str ( \"AA\" ))) result_ = assert_not ( parse_result % ok ) if ( result_ % passed ()) then result_ = & assert_equals ( \"A\" , parse_result % message % found ) & . and . assert_equals ( \"B\" , parse_result % message % expected ( 1 )) end if end function pure function parse_a ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"A\" , state_ ) end function pure function parse_b ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"B\" , state_ ) end function end module","tags":"","loc":"sourcefile/then_drop_test.f90.html","title":"then_drop_test.f90 – miniFAVOR"},{"text":"Contents Modules either_test Source Code either_test.f90 Source Code module either_test implicit none private public :: test_either contains function test_either () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"Returns the first result if it passed\" , check_first_pass ) individual_tests ( 2 ) = it ( & \"Returns the second result if it passed\" , check_second_pass ) individual_tests ( 3 ) = it ( & \"Returns the error if neither passed\" , check_both_fail ) tests = describe ( \"either\" , individual_tests ) end function pure function check_first_pass () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parsed_character_t , parser_output_t , either , new_state use vegetables , only : result_t , assert_equals , assert_not , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = either ( parse_f , parse_a , new_state ( var_str ( \"First\" ))) result_ = & assert_that ( parse_result % ok , \"Got result\" , \"Didn't get result\" ) & . and . assert_not ( parse_result % empty , \"Wasn't empty\" , \"Was empty\" ) if ( result_ % passed ()) then select type ( the_char => parse_result % parsed ) type is ( parsed_character_t ) result_ = & assert_equals ( \"F\" , the_char % value_ ) & . and . assert_equals ( \"irst\" , parse_result % remaining ) class default result_ = fail ( \"Didn't get a character back\" ) end select end if end function pure function check_second_pass () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parsed_character_t , parser_output_t , either , new_state use vegetables , only : result_t , assert_equals , assert_not , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = either ( parse_a , parse_f , new_state ( var_str ( \"First\" ))) result_ = & assert_that ( parse_result % ok , \"Got result\" , \"Didn't get result\" ) & . and . assert_not ( parse_result % empty , \"Wasn't empty\" , \"Was empty\" ) if ( result_ % passed ()) then select type ( the_char => parse_result % parsed ) type is ( parsed_character_t ) result_ = & assert_equals ( \"F\" , the_char % value_ ) & . and . assert_equals ( \"irst\" , parse_result % remaining ) class default result_ = fail ( \"Didn't get a character back\" ) end select end if end function pure function check_both_fail () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , either , new_state use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = either ( parse_a , parse_a , new_state ( var_str ( \"First\" ))) result_ = & assert_not ( parse_result % ok ) & . and . assert_equals ( \"F\" , parse_result % message % found ) & . and . assert_equals ( 2 , size ( parse_result % message % expected )) end function pure function parse_a ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"A\" , state_ ) end function pure function parse_f ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"F\" , state_ ) end function end module","tags":"","loc":"sourcefile/either_test.f90.html","title":"either_test.f90 – miniFAVOR"},{"text":"Contents Modules parse_character_test Source Code parse_character_test.f90 Source Code module parse_character_test implicit none private public :: test_parse_character contains function test_parse_character () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"Parsing the first character in a string consumes that character\" , & check_parse_first_character ) individual_tests ( 2 ) = it ( & \"Parsing a different character produces an error\" , & check_parse_different_character ) individual_tests ( 3 ) = it ( & \"Parsing an empty string produces an error\" , & check_parse_empty_string ) tests = describe ( \"parse_char\" , individual_tests ) end function pure function check_parse_first_character () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_character_t , parser_output_t , new_state , parse_char use vegetables , only : & result_t , assert_equals , assert_not , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_char ( \"F\" , new_state ( var_str ( \"First\" ))) result_ = & assert_that ( parse_result % ok , \"Got result\" , \"Didn't get result\" ) & . and . assert_not ( parse_result % empty , \"Wasn't empty\" , \"Was empty\" ) if ( result_ % passed ()) then select type ( the_char => parse_result % parsed ) type is ( parsed_character_t ) result_ = & assert_equals ( \"F\" , the_char % value_ ) & . and . assert_equals ( \"irst\" , parse_result % remaining ) class default result_ = fail ( \"Didn't get a character back\" ) end select end if end function pure function check_parse_different_character () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , parse_char use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_char ( \"A\" , new_state ( var_str ( \"First\" ))) result_ = & assert_not ( parse_result % ok ) & . and . assert_equals ( \"F\" , parse_result % message % found ) & . and . assert_equals ( \"A\" , parse_result % message % expected ( 1 )) end function pure function check_parse_empty_string () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , parse_char use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_char ( \"A\" , new_state ( var_str ( \"\" ))) result_ = & assert_not ( parse_result % ok ) & . and . assert_equals ( \"end of input\" , parse_result % message % found ) & . and . assert_equals ( \"A\" , parse_result % message % expected ( 1 )) end function end module","tags":"","loc":"sourcefile/parse_character_test.f90.html","title":"parse_character_test.f90 – miniFAVOR"},{"text":"Contents Modules optionally_test Source Code optionally_test.f90 Source Code module optionally_test implicit none private public :: test_optionally contains function test_optionally () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"parses the given parser if it succeeds\" , check_parse_succeed ) individual_tests ( 2 ) = it ( & \"parses nothing if the parser fails\" , check_parse_fails ) individual_tests ( 3 ) = it ( & \"parses nothing if the string is empty\" , check_parse_empty ) tests = describe ( \"optionally\" , individual_tests ) end function pure function check_parse_succeed () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_character_t , parser_output_t , new_state , optionally use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = optionally ( parse_a , new_state ( var_str ( \"AB\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_character_t ) result_ = & assert_equals ( \"A\" , parsed % value_ , \"parsed\" ) & . and . assert_equals ( \"B\" , results % remaining , \"remaining\" ) class default result_ = fail ( \"Didn't get the character back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_parse_fails () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , optionally use vegetables , only : result_t , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = optionally ( parse_a , new_state ( var_str ( \"BB\" ))) if ( results % ok ) then result_ = assert_that ( results % empty ) else result_ = fail ( results % message % to_string ()) end if end function pure function check_parse_empty () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , optionally use vegetables , only : result_t , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = optionally ( parse_a , new_state ( var_str ( \"\" ))) if ( results % ok ) then result_ = assert_that ( results % empty ) else result_ = fail ( results % message % to_string ()) end if end function pure function parse_a ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"A\" , state_ ) end function end module","tags":"","loc":"sourcefile/optionally_test.f90.html","title":"optionally_test.f90 – miniFAVOR"},{"text":"Contents Modules many_with_separator_test Source Code many_with_separator_test.f90 Source Code module many_with_separator_test implicit none private public :: test_many_with_separator contains function test_many_with_separator () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 5 ) individual_tests ( 1 ) = it ( \"can parse one item\" , check_one ) individual_tests ( 2 ) = it ( & \"can parse one item followed by a separator\" , & check_one_with_separator ) individual_tests ( 3 ) = it ( & \"parses until the parser doesn't match\" , check_many ) individual_tests ( 4 ) = it ( & \"leaves a trailing separator\" , check_many_with_separator ) individual_tests ( 5 ) = it ( & \"returns empty if the first result doesn't match\" , check_none ) tests = describe ( \"many_with_separator\" , individual_tests ) end function pure function check_one () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_items_t , parser_output_t , many_with_separator , new_state use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many_with_separator ( parse_a , parse_comma , new_state ( var_str ( \"AB\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = & assert_equals ( 1 , size ( parsed % items )) & . and . assert_equals ( \"B\" , results % remaining ) class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_one_with_separator () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_character_t , & parsed_items_t , & parser_output_t , & many_with_separator , & new_state use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many_with_separator ( parse_a , parse_comma , new_state ( var_str ( \"A,B\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = assert_equals ( 1 , size ( parsed % items )) if ( result_ % passed ()) then select type ( the_item => parsed % items ( 1 )% item ) type is ( parsed_character_t ) result_ = & assert_equals ( \"A\" , the_item % value_ ) & . and . assert_equals ( \",B\" , results % remaining ) end select end if class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_many () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_items_t , parser_output_t , many_with_separator , new_state use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many_with_separator ( parse_a , parse_comma , new_state ( var_str ( \"A,A,AB\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = & assert_equals ( 3 , size ( parsed % items ))& . and . assert_equals ( \"B\" , results % remaining ) class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_many_with_separator () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_items_t , parser_output_t , many_with_separator , new_state use vegetables , only : result_t , assert_equals , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many_with_separator ( parse_a , parse_comma , new_state ( var_str ( \"A,A,A,B\" ))) if ( results % ok ) then select type ( parsed => results % parsed ) type is ( parsed_items_t ) result_ = & assert_equals ( 3 , size ( parsed % items ))& . and . assert_equals ( \",B\" , results % remaining ) class default result_ = fail ( \"Didn't get list back\" ) end select else result_ = fail ( results % message % to_string ()) end if end function pure function check_none () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , many_with_separator , new_state use vegetables , only : result_t , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: results results = many_with_separator ( parse_a , parse_comma , new_state ( var_str ( \"B,A,A\" ))) if ( results % ok ) then result_ = assert_that ( results % empty ) else result_ = fail ( results % message % to_string ()) end if end function pure function parse_a ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"A\" , state_ ) end function pure function parse_comma ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \",\" , state_ ) end function end module","tags":"","loc":"sourcefile/many_with_separator_test.f90.html","title":"many_with_separator_test.f90 – miniFAVOR"},{"text":"Contents Modules parse_digit_test Source Code parse_digit_test.f90 Source Code module parse_digit_test implicit none private public :: test_parse_digit contains function test_parse_digit () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"Parsing the first character in a string consumes that character\" , & check_parse_first_character ) individual_tests ( 2 ) = it ( & \"Parsing a different character produces an error\" , & check_parse_different_character ) individual_tests ( 3 ) = it ( & \"Parsing an empty string produces an error\" , & check_parse_empty_string ) tests = describe ( \"parse_digit\" , individual_tests ) end function pure function check_parse_first_character () result ( result_ ) use iso_varying_string , only : var_str use parff , only : & parsed_character_t , parser_output_t , new_state , parse_digit use vegetables , only : & result_t , assert_equals , assert_not , assert_that , fail type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_digit ( new_state ( var_str ( \"1First\" ))) result_ = & assert_that ( parse_result % ok , \"Got result\" , \"Didn't get result\" ) & . and . assert_not ( parse_result % empty , \"Wasn't empty\" , \"Was empty\" ) if ( result_ % passed ()) then select type ( the_char => parse_result % parsed ) type is ( parsed_character_t ) result_ = & assert_equals ( \"1\" , the_char % value_ ) & . and . assert_equals ( \"First\" , parse_result % remaining ) class default result_ = fail ( \"Didn't get a character back\" ) end select end if end function pure function check_parse_different_character () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , parse_digit use vegetables , only : result_t , assert_equals , assert_not , fail type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_digit ( new_state ( var_str ( \"First\" ))) result_ = & assert_not ( parse_result % ok ) & . and . assert_equals ( \"F\" , parse_result % message % found ) & . and . assert_equals ( \"digit\" , parse_result % message % expected ( 1 )) end function pure function check_parse_empty_string () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , parse_digit use vegetables , only : result_t , assert_equals , assert_not , fail type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_digit ( new_state ( var_str ( \"\" ))) result_ = & assert_not ( parse_result % ok ) & . and . assert_equals ( \"end of input\" , parse_result % message % found ) & . and . assert_equals ( \"digit\" , parse_result % message % expected ( 1 )) end function end module","tags":"","loc":"sourcefile/parse_digit_test.f90.html","title":"parse_digit_test.f90 – miniFAVOR"},{"text":"Contents Modules parse_integer_test Source Code parse_integer_test.f90 Source Code module parse_integer_test use iso_varying_string , only : varying_string use vegetables , only : Input_t implicit none private type , extends ( Input_t ) :: number_input_t type ( varying_string ) :: string integer :: value_ end type type , extends ( Input_t ) :: invalid_input_t type ( varying_string ) :: string end type public :: test_parse_integer contains function test_parse_integer () result ( tests ) use iso_varying_string , only : var_str use vegetables , only : Example_t , test_item_t , describe , Example , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) type ( Example_t ) :: invalid_examples ( 3 ) type ( Example_t ) :: number_examples ( 7 ) number_examples ( 1 ) = Example ( number_input_t ( var_str ( \"0\" ), 0 )) number_examples ( 2 ) = Example ( number_input_t ( var_str ( \"-0\" ), 0 )) number_examples ( 3 ) = Example ( number_input_t ( var_str ( \"+0\" ), 0 )) number_examples ( 4 ) = Example ( number_input_t ( var_str ( \"1\" ), 1 )) number_examples ( 5 ) = Example ( number_input_t ( var_str ( \"-1\" ), - 1 )) number_examples ( 6 ) = Example ( number_input_t ( var_str ( \"+1\" ), 1 )) number_examples ( 7 ) = Example ( number_input_t ( var_str ( \"-321\" ), - 321 )) invalid_examples ( 1 ) = Example ( invalid_input_t ( var_str ( \"a\" ))) invalid_examples ( 2 ) = Example ( invalid_input_t ( var_str ( \"-b\" ))) invalid_examples ( 3 ) = Example ( invalid_input_t ( var_str ( \"+c\" ))) individual_tests ( 1 ) = it ( & \"Can parse various integers\" , & number_examples , & check_parse_integer ) individual_tests ( 2 ) = it ( & \"Parsing invalid integers produce errors\" , & invalid_examples , & check_parse_invalid ) individual_tests ( 3 ) = it ( & \"Parsing an empty string produces an error\" , check_parse_empty ) tests = describe ( \"parse_integer\" , individual_tests ) end function pure function check_parse_integer ( input ) result ( result_ ) use parff , only : & parsed_integer_t , parser_output_t , new_state , parse_integer use vegetables , only : Input_t , result_t , assert_equals , fail class ( Input_t ), intent ( in ) :: input type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result select type ( input ) type is ( number_input_t ) parse_result = parse_integer ( new_state ( input % string )) if ( parse_result % ok ) then select type ( parsed => parse_result % parsed ) type is ( parsed_integer_t ) result_ = assert_equals ( & input % value_ , parsed % value_ , input % string ) class default result_ = fail ( \"Didn't get an integer back\" ) end select else result_ = fail ( parse_result % message % to_string ()) end if class default result_ = fail ( \"Expected to get a number_input_t\" ) end select end function pure function check_parse_invalid ( input ) result ( result_ ) use parff , only : parser_output_t , new_state , parse_integer use vegetables , only : Input_t , result_t , assert_not , fail class ( Input_t ), intent ( in ) :: input type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result select type ( input ) type is ( invalid_input_t ) parse_result = parse_integer ( new_state ( input % string )) result_ = assert_not ( & parse_result % ok , parse_result % message % to_string ()) class default result_ = fail ( \"Expected to get an invalid_input_tt\" ) end select end function pure function check_parse_empty () result ( result_ ) use iso_varying_string , only : var_str use parff , only : parser_output_t , new_state , parse_integer use vegetables , only : result_t , assert_not type ( result_t ) :: result_ type ( parser_output_t ) :: parse_result parse_result = parse_integer ( new_state ( var_str ( \"\" ))) result_ = assert_not ( & parse_result % ok , parse_result % message % to_string ()) end function end module","tags":"","loc":"sourcefile/parse_integer_test.f90.html","title":"parse_integer_test.f90 – miniFAVOR"},{"text":"Contents Modules parff Source Code parff.f90 Source Code module parff use iso_varying_string , only : varying_string implicit none private public :: & intermediate_parsed_string_t , & intermediate_repeat_t , & message_t , & parse_result_t , & parsed_character_t , & parsed_integer_t , & parsed_item_t , & parsed_items_t , & parsed_nothing_t , & parsed_rational_t , & parsed_string_t , & parsed_value_t , & parser_output_t , & position_t , & state_t , & consumed_ok , & drop_then , & either , & empty_error , & empty_ok , & many , & many1 , & many1_with_separator , & many_with_separator , & message , & new_state , & optionally , & parse_char , & parse_digit , & parse_integer , & parse_nothing , & parse_rational , & parse_string , & parse_whitespace , & parse_with , & repeat_ , & return_ , & satisfy , & sequence , & then_drop , & with_label type , abstract :: parsed_value_t end type type :: parsed_item_t class ( parsed_value_t ), allocatable :: item end type type , extends ( parsed_value_t ) :: parsed_nothing_t end type type , extends ( parsed_value_t ) :: parsed_character_t character ( len = 1 ) :: value_ end type type , extends ( parsed_value_t ) :: parsed_string_t type ( varying_string ) :: value_ end type type , extends ( parsed_value_t ) :: parsed_integer_t integer :: value_ end type type , extends ( parsed_value_t ) :: parsed_rational_t double precision :: value_ end type type , extends ( parsed_value_t ) :: intermediate_parsed_string_t type ( varying_string ) :: parsed_so_far type ( varying_string ) :: left_to_parse end type type , extends ( parsed_value_t ) :: parsed_items_t type ( parsed_item_t ), allocatable :: items (:) end type type , extends ( parsed_value_t ) :: intermediate_repeat_t type ( parsed_items_t ) :: parsed_so_far integer :: remaining end type type :: position_t integer :: line integer :: column end type type :: state_t type ( varying_string ) :: input type ( position_t ) :: position end type type :: message_t type ( position_t ) :: position type ( varying_string ) :: found type ( varying_string ), allocatable :: expected (:) contains procedure :: to_string => message_to_string end type type :: parser_output_t logical :: empty logical :: ok type ( message_t ) :: message ! The following are only defined if ok class ( parsed_value_t ), allocatable :: parsed type ( varying_string ) :: remaining type ( position_t ) :: position end type type :: parse_result_t logical :: ok class ( parsed_value_t ), allocatable :: parsed type ( varying_string ) :: message end type abstract interface pure function match_i ( char_ ) result ( matches ) character ( len = 1 ), intent ( in ) :: char_ logical :: matches end function pure function parser_i ( state_ ) result ( result_ ) import parser_output_t , state_t type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ end function pure function then_parser_i ( previous , state_ ) result ( result_ ) import parser_output_t , parsed_value_t , state_t class ( parsed_value_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ end function end interface interface drop_then module procedure drop_then_parser module procedure drop_then_result end interface interface parse_string module procedure parse_string_c module procedure parse_string_s end interface interface parse_with module procedure parse_with_c module procedure parse_with_s end interface interface sequence module procedure sequence_parser module procedure sequence_result end interface interface then_drop module procedure then_drop_parser module procedure then_drop_result end interface interface with_label module procedure with_label_c module procedure with_label_s end interface type ( parsed_nothing_t ), parameter :: PARSED_NOTHING = parsed_nothing_t () contains pure function consumed_ok ( parsed , remaining , position , message_ ) use iso_varying_string , only : varying_string class ( parsed_value_t ), intent ( in ) :: parsed type ( varying_string ), intent ( in ) :: remaining type ( position_t ), intent ( in ) :: position type ( message_t ), intent ( in ) :: message_ type ( parser_output_t ) :: consumed_ok consumed_ok % empty = . false . consumed_ok % ok = . true . allocate ( consumed_ok % parsed , source = parsed ) consumed_ok % remaining = remaining consumed_ok % position = position consumed_ok % message = message_ end function pure recursive function drop_then_parser ( parser1 , parser2 , state_ ) result ( result_ ) procedure ( parser_i ) :: parser1 procedure ( parser_i ) :: parser2 type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = drop_then ( parser1 ( state_ ), parser2 ) end function pure recursive function drop_then_result ( previous , parser ) result ( result_ ) type ( parser_output_t ), intent ( in ) :: previous procedure ( parser_i ) :: parser type ( parser_output_t ) :: result_ if ( previous % ok ) then result_ = parser ( & state ( previous % remaining , previous % position )) if (. not . previous % empty ) then result_ % empty = . false . end if else result_ = previous end if end function pure recursive function either ( parse1 , parse2 , state_ ) result ( result_ ) procedure ( parser_i ) :: parse1 procedure ( parser_i ) :: parse2 type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( parser_output_t ) :: first_result type ( parser_output_t ) :: second_result first_result = parse1 ( state_ ) if ( first_result % empty ) then second_result = parse2 ( state_ ) if ( second_result % empty ) then if ( first_result % ok ) then result_ = merge_ok ( & first_result % parsed , & first_result % remaining , & first_result % position , & first_result % message , & second_result % message ) else if ( second_result % ok ) then result_ = merge_ok ( & second_result % parsed , & second_result % remaining , & second_result % position , & first_result % message , & second_result % message ) else result_ = merge_error ( & first_result % message , & second_result % message ) end if end if else result_ = second_result end if else result_ = first_result end if end function pure function empty_error ( message_ ) type ( message_t ), intent ( in ) :: message_ type ( parser_output_t ) :: empty_error empty_error % empty = . true . empty_error % ok = . false . empty_error % message = message_ end function pure function empty_ok ( parsed , remaining , position , message_ ) use iso_varying_string , only : varying_string class ( parsed_value_t ), intent ( in ) :: parsed type ( varying_string ), intent ( in ) :: remaining type ( position_t ), intent ( in ) :: position type ( message_t ), intent ( in ) :: message_ type ( parser_output_t ) :: empty_ok empty_ok % empty = . true . empty_ok % ok = . true . allocate ( empty_ok % parsed , source = parsed ) empty_ok % remaining = remaining empty_ok % position = position empty_ok % message = message_ end function pure function expect ( message_ , label ) result ( new_message ) use iso_varying_string , only : varying_string type ( message_t ), intent ( in ) :: message_ type ( varying_string ), intent ( in ) :: label type ( message_t ) :: new_message new_message = message ( message_ % position , message_ % found , [ label ]) end function pure function many ( the_parser , the_state ) result ( the_result ) procedure ( parser_i ) :: the_parser type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = many_with_separator ( the_parser , parse_nothing , the_state ) end function pure function many1 ( the_parser , the_state ) result ( the_result ) procedure ( parser_i ) :: the_parser type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = many1_with_separator ( the_parser , parse_nothing , the_state ) end function pure function many1_with_separator ( & the_parser , the_separator , the_state ) result ( the_result ) procedure ( parser_i ) :: the_parser procedure ( parser_i ) :: the_separator type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result type ( parsed_items_t ) :: all type ( parser_output_t ) :: next type ( parsed_items_t ) :: temp the_result = the_parser ( the_state ) if ( the_result % ok ) then allocate ( all % items ( 1 )) allocate ( all % items ( 1 )% item , source = the_result % parsed ) do next = drop_then ( the_separator , the_parser , state ( the_result % remaining , the_result % position )) if (. not . next % ok ) exit allocate ( temp % items ( size ( all % items ))) temp % items = all % items deallocate ( all % items ) allocate ( all % items ( size ( temp % items ) + 1 )) all % items ( 1 : size ( temp % items )) = temp % items allocate ( all % items ( size ( all % items ))% item , source = next % parsed ) deallocate ( temp % items ) the_result = next end do deallocate ( the_result % parsed ) allocate ( the_result % parsed , source = all ) end if end function pure function many_with_separator ( & the_parser , the_separator , the_state ) result ( the_result ) use iso_varying_string , only : varying_string , var_str procedure ( parser_i ) :: the_parser procedure ( parser_i ) :: the_separator type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result type ( parsed_items_t ) :: all the_result = many1_with_separator ( the_parser , the_separator , the_state ) if (. not . the_result % ok ) then allocate ( all % items ( 0 )) the_result = empty_ok ( & all , & the_state % input , & the_state % position , & message ( & the_state % position , & var_str ( \"\" ), & [ varying_string :: ])) end if end function pure function merge_ ( message1 , message2 ) result ( merged ) type ( message_t ), intent ( in ) :: message1 type ( message_t ), intent ( in ) :: message2 type ( message_t ) :: merged merged = message ( & message1 % position , & message1 % found , & [ message1 % expected , message2 % expected ]) end function pure function merge_error ( message1 , message2 ) result ( result_ ) type ( message_t ), intent ( in ) :: message1 type ( message_t ), intent ( in ) :: message2 type ( parser_output_t ) :: result_ result_ = empty_error ( merge_ ( message1 , message2 )) end function pure function merge_ok ( & parsed , remaining , position , message1 , message2 ) result ( result_ ) use iso_varying_string , only : varying_string class ( parsed_value_t ), intent ( in ) :: parsed type ( varying_string ), intent ( in ) :: remaining type ( position_t ), intent ( in ) :: position type ( message_t ), intent ( in ) :: message1 type ( message_t ), intent ( in ) :: message2 type ( parser_output_t ) :: result_ result_ = empty_ok ( & parsed , & remaining , & position , & merge_ ( message1 , message2 )) end function pure function message ( position , found , expected ) use iso_varying_string , only : varying_string type ( position_t ), intent ( in ) :: position type ( varying_string ), intent ( in ) :: found type ( varying_string ), intent ( in ) :: expected (:) type ( message_t ) :: message message % position = position message % found = found allocate ( message % expected , source = expected ) end function pure function message_to_string ( self ) result ( string ) use iso_varying_string , only : varying_string , operator ( // ) use strff , only : join , to_string , NEWLINE class ( message_t ), intent ( in ) :: self type ( varying_string ) :: string string = \"At line \" // to_string ( self % position % line ) // \" and column \" // to_string ( self % position % column ) // NEWLINE & // \"    found \" // self % found // \" but expected \" // join ( self % expected , \" or \" ) end function pure function new_position () type ( position_t ) :: new_position new_position % line = 1 new_position % column = 1 end function pure function new_state ( input ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: input type ( state_t ) :: new_state new_state = state ( input , new_position ()) end function pure function next_position ( char_ , position ) character ( len = 1 ), intent ( in ) :: char_ type ( position_t ), intent ( in ) :: position type ( position_t ) :: next_position character ( len = 1 ), parameter :: TAB = char ( 9 ) character ( len = 1 ), parameter :: NEWLINE_ = char ( 10 ) if ( char_ == NEWLINE_ ) then next_position % line = position % line + 1 next_position % column = position % column else if ( char_ == TAB ) then next_position % line = position % line next_position % column = position % column + 8 - mod ( position % column - 1 , 8 ) else next_position % line = position % line next_position % column = position % column + 1 end if end function pure function optionally ( parser , the_state ) result ( the_result ) procedure ( parser_i ) :: parser type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = either ( parser , parse_nothing , the_state ) end function pure function parse_char ( the_char , the_state ) result ( the_result ) character ( len = 1 ), intent ( in ) :: the_char type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = with_label ( the_char , the_parser , the_state ) contains pure function the_parser ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = satisfy ( the_matcher , state_ ) end function pure function the_matcher ( char_ ) result ( matches ) character ( len = 1 ), intent ( in ) :: char_ logical :: matches matches = char_ == the_char end function end function pure function parse_digit ( the_state ) result ( the_result ) type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = with_label ( \"digit\" , the_parser , the_state ) contains pure function the_parser ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = satisfy ( the_matcher , state_ ) end function pure function the_matcher ( char_ ) result ( matches ) use strff , only : operator (. includes .) character ( len = 1 ), intent ( in ) :: char_ logical :: matches matches = \"0123456789\" . includes . char_ end function end function pure function parse_integer ( the_state ) result ( the_result ) type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = with_label ( \"integer\" , the_parser , the_state ) contains pure function the_parser ( state_ ) result ( result_ ) use iso_varying_string , only : assignment ( = ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ integer :: the_number character ( len = 64 ) :: the_string type ( parsed_integer_t ) :: the_value result_ = sequence ( optionally ( parse_sign , state_ ), then_parse_digits ) if ( result_ % ok ) then select type ( parsed_string => result_ % parsed ) type is ( parsed_string_t ) the_string = parsed_string % value_ read ( the_string , * ) the_number the_value % value_ = the_number deallocate ( result_ % parsed ) allocate ( result_ % parsed , source = the_value ) end select end if end function pure function parse_sign ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = either ( parse_plus , parse_minus , state_ ) end function pure function parse_plus ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"+\" , state_ ) end function pure function parse_minus ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"-\" , state_ ) end function pure function then_parse_digits ( previous , state_ ) result ( result_ ) use iso_varying_string , only : operator ( // ) class ( parsed_value_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_digits ( state_ ) if ( result_ % ok ) then select type ( previous ) type is ( parsed_character_t ) select type ( next => result_ % parsed ) type is ( parsed_string_t ) next % value_ = previous % value_ // next % value_ end select end select end if end function pure function parse_digits ( state_ ) result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ) use strff , only : join type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( varying_string ), allocatable :: digits (:) integer :: i type ( parsed_string_t ) :: parsed_digits result_ = many1 ( parse_digit , state_ ) if ( result_ % ok ) then select type ( results => result_ % parsed ) type is ( parsed_items_t ) allocate ( digits ( size ( results % items ))) do i = 1 , size ( digits ) select type ( string => results % items ( i )% item ) type is ( parsed_character_t ) digits ( i ) = string % value_ end select end do end select deallocate ( result_ % parsed ) parsed_digits % value_ = join ( digits , \"\" ) allocate ( result_ % parsed , source = parsed_digits ) end if end function end function pure function parse_nothing ( the_state ) result ( the_result ) type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = return_ ( PARSED_NOTHING , the_state ) end function pure function parse_rational ( the_state ) result ( the_result ) type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = with_label ( \"rational\" , the_parser , the_state ) contains pure function the_parser ( state_ ) result ( result_ ) use iso_varying_string , only : assignment ( = ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ double precision :: the_number character ( len = 64 ) :: the_string type ( parsed_rational_t ) :: the_value result_ = sequence ( & sequence ( parse_sign , then_parse_number , state_ ), & then_parse_exponent ) if ( result_ % ok ) then select type ( parsed_string => result_ % parsed ) type is ( parsed_string_t ) the_string = parsed_string % value_ read ( the_string , * ) the_number the_value % value_ = the_number deallocate ( result_ % parsed ) allocate ( result_ % parsed , source = the_value ) end select end if end function pure function parse_sign ( state_ ) result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), var_str type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( parsed_string_t ) :: the_string result_ = either ( parse_plus , parse_minus , state_ ) if ( result_ % ok ) then select type ( the_character => result_ % parsed ) type is ( parsed_character_t ) the_string % value_ = the_character % value_ deallocate ( result_ % parsed ) allocate ( result_ % parsed , source = the_string ) end select else the_string % value_ = \"\" result_ = empty_ok ( & the_string , & state_ % input , & state_ % position , & message ( state_ % position , var_str ( \"\" ), [ varying_string :: ])) end if end function pure function parse_plus ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"+\" , state_ ) end function pure function parse_minus ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"-\" , state_ ) end function pure function then_parse_number ( previous , state_ ) result ( result_ ) use iso_varying_string , only : operator ( // ) class ( parsed_value_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = either ( parse_covered_decimal , parse_uncovered_decimal , state_ ) if ( result_ % ok ) then select type ( previous ) type is ( parsed_string_t ) select type ( next => result_ % parsed ) type is ( parsed_string_t ) next % value_ = previous % value_ // next % value_ end select end select end if end function pure function parse_covered_decimal ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = sequence ( parse_digits , then_parse_fraction , state_ ) end function pure function parse_digits ( state_ ) result ( result_ ) use iso_varying_string , only : assignment ( = ), varying_string use strff , only : join type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( varying_string ), allocatable :: digits (:) integer :: i type ( parsed_string_t ) :: parsed_digits result_ = many1 ( parse_digit , state_ ) if ( result_ % ok ) then select type ( results => result_ % parsed ) type is ( parsed_items_t ) allocate ( digits ( size ( results % items ))) do i = 1 , size ( digits ) select type ( string => results % items ( i )% item ) type is ( parsed_character_t ) digits ( i ) = string % value_ end select end do deallocate ( result_ % parsed ) parsed_digits % value_ = join ( digits , \"\" ) allocate ( result_ % parsed , source = parsed_digits ) end select end if end function pure function then_parse_fraction ( previous , state_ ) result ( result_ ) use iso_varying_string , only : varying_string , operator ( // ), var_str class ( parsed_value_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = sequence ( parse_decimal , then_parse_maybe_digits , state_ ) if ( result_ % ok ) then select type ( previous ) type is ( parsed_string_t ) select type ( next => result_ % parsed ) type is ( parsed_string_t ) next % value_ = previous % value_ // next % value_ end select end select else result_ = empty_ok ( & previous , & state_ % input , & state_ % position , & message ( state_ % position , var_str ( \"\" ), [ varying_string :: ])) end if end function pure function parse_decimal ( state_ ) result ( result_ ) use iso_varying_string , only : assignment ( = ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( parsed_string_t ) :: the_string result_ = parse_char ( \".\" , state_ ) if ( result_ % ok ) then select type ( the_character => result_ % parsed ) type is ( parsed_character_t ) the_string % value_ = the_character % value_ deallocate ( result_ % parsed ) allocate ( result_ % parsed , source = the_string ) end select end if end function pure function then_parse_maybe_digits ( previous , state_ ) result ( result_ ) use iso_varying_string , only : operator ( // ) class ( parsed_value_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_maybe_digits ( state_ ) if ( result_ % ok ) then select type ( previous ) type is ( parsed_string_t ) select type ( next => result_ % parsed ) type is ( parsed_string_t ) next % value_ = previous % value_ // next % value_ end select end select end if end function pure function parse_maybe_digits ( state_ ) result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ) use strff , only : join type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( varying_string ), allocatable :: digits (:) integer :: i type ( parsed_string_t ) :: parsed_digits result_ = many ( parse_digit , state_ ) select type ( results => result_ % parsed ) type is ( parsed_items_t ) allocate ( digits ( size ( results % items ))) do i = 1 , size ( digits ) select type ( string => results % items ( i )% item ) type is ( parsed_character_t ) digits ( i ) = string % value_ end select end do deallocate ( result_ % parsed ) parsed_digits % value_ = join ( digits , \"\" ) allocate ( result_ % parsed , source = parsed_digits ) end select end function pure function parse_uncovered_decimal ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = sequence ( parse_decimal , then_parse_digits , state_ ) end function pure function then_parse_digits ( previous , state_ ) result ( result_ ) use iso_varying_string , only : operator ( // ) class ( parsed_value_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_digits ( state_ ) if ( result_ % ok ) then select type ( previous ) type is ( parsed_string_t ) select type ( next => result_ % parsed ) type is ( parsed_string_t ) next % value_ = previous % value_ // next % value_ end select end select end if end function pure function then_parse_exponent ( previous , state_ ) result ( result_ ) use iso_varying_string , only : varying_string , operator ( // ), var_str class ( parsed_value_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_exponent ( state_ ) if ( result_ % ok ) then select type ( previous ) type is ( parsed_string_t ) select type ( next => result_ % parsed ) type is ( parsed_string_t ) next % value_ = previous % value_ // next % value_ end select end select else result_ = empty_ok ( & previous , & state_ % input , & state_ % position , & message ( state_ % position , var_str ( \"\" ), [ varying_string :: ])) end if end function pure function parse_exponent ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = sequence ( & sequence ( parse_letter , then_parse_sign , state_ ), & then_parse_digits ) end function pure function parse_letter ( state_ ) result ( result_ ) use iso_varying_string , only : assignment ( = ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( parsed_string_t ) :: the_string result_ = either ( parse_e , parse_d , state_ ) if ( result_ % ok ) then select type ( the_character => result_ % parsed ) type is ( parsed_character_t ) the_string % value_ = the_character % value_ deallocate ( result_ % parsed ) allocate ( result_ % parsed , source = the_string ) end select end if end function pure function parse_e ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = either ( parse_upper_e , parse_lower_e , state_ ) end function pure function parse_upper_e ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"E\" , state_ ) end function pure function parse_lower_e ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"e\" , state_ ) end function pure function parse_d ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = either ( parse_upper_d , parse_lower_d , state_ ) end function pure function parse_upper_d ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"D\" , state_ ) end function pure function parse_lower_d ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_char ( \"d\" , state_ ) end function pure function then_parse_sign ( previous , state_ ) result ( result_ ) use iso_varying_string , only : operator ( // ) class ( parsed_value_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = parse_sign ( state_ ) if ( result_ % ok ) then select type ( previous ) type is ( parsed_string_t ) select type ( next => result_ % parsed ) type is ( parsed_string_t ) next % value_ = previous % value_ // next % value_ end select end select end if end function end function pure function parse_string_c ( string , the_state ) result ( the_result ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: string type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = parse_string ( var_str ( string ), the_state ) end function pure function parse_string_s ( string , the_state ) result ( the_result ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: string type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = with_label ( string , start , the_state ) contains pure function start ( state_ ) result ( result_ ) use iso_varying_string , only : & varying_string , assignment ( = ), operator ( == ), var_str type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( parsed_string_t ) :: empty type ( intermediate_parsed_string_t ) :: initial if ( string == \"\" ) then empty % value_ = \"\" result_ = empty_ok ( empty , state_ % input , state_ % position , message ( & state_ % position , var_str ( \"\" ), [ varying_string :: ])) else initial % left_to_parse = string initial % parsed_so_far = \"\" result_ = sequence ( return_ ( initial , state_ ), recurse ) end if end function pure recursive function recurse ( previous , state_ ) result ( result_ ) use iso_varying_string , only : varying_string , len , var_str class ( parsed_value_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( parsed_string_t ) :: final_string select type ( previous ) type is ( intermediate_parsed_string_t ) if ( len ( previous % left_to_parse ) == 0 ) then final_string % value_ = previous % parsed_so_far result_ = consumed_ok ( & final_string , & state_ % input , & state_ % position , & message ( state_ % position , var_str ( \"\" ), [ varying_string :: ])) else result_ = sequence ( parse_next ( previous , state_ ), recurse ) end if end select end function pure function parse_next ( previous , state_ ) result ( result_ ) use iso_varying_string , only : operator ( // ) use strff , only : first_character , without_first_character type ( intermediate_parsed_string_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( intermediate_parsed_string_t ) :: next result_ = parse_char ( first_character ( previous % left_to_parse ), state_ ) if ( result_ % ok ) then next % left_to_parse = without_first_character ( previous % left_to_parse ) select type ( the_char => result_ % parsed ) type is ( parsed_character_t ) next % parsed_so_far = previous % parsed_so_far // the_char % value_ deallocate ( result_ % parsed ) allocate ( result_ % parsed , source = next ) end select end if end function end function pure function parse_whitespace ( the_state ) result ( the_result ) type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = with_label ( \"whitespace\" , the_parser , the_state ) contains pure function the_parser ( state_ ) result ( result_ ) type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = satisfy ( the_matcher , state_ ) end function pure function the_matcher ( char_ ) result ( matches ) use strff , only : operator (. includes .), NEWLINE character ( len = 1 ), intent ( in ) :: char_ logical :: matches character ( len = 1 ), parameter :: TAB = char ( 9 ) character ( len = 1 ), parameter :: CARRIAGE_RETURN = char ( 13 ) character ( len = 1 ), parameter :: SPACE = char ( 32 ) character ( len =* ), parameter :: WHITESPACE = & TAB // NEWLINE // CARRIAGE_RETURN // SPACE matches = WHITESPACE . includes . char_ end function end function pure function parse_with_c ( parser , string ) result ( result_ ) use iso_varying_string , only : var_str procedure ( parser_i ) :: parser character ( len =* ), intent ( in ) :: string type ( parse_result_t ) :: result_ result_ = parse_with ( parser , var_str ( string )) end function pure function parse_with_s ( parser , string ) result ( result_ ) use iso_varying_string , only : varying_string procedure ( parser_i ) :: parser type ( varying_string ), intent ( in ) :: string type ( parse_result_t ) :: result_ type ( parser_output_t ) :: the_results the_results = parser ( new_state ( string )) if ( the_results % ok ) then result_ % ok = . true . allocate ( result_ % parsed , source = the_results % parsed ) else result_ % ok = . false . result_ % message = the_results % message % to_string () end if end function pure function repeat_ ( the_parser , times , the_state ) result ( the_result ) procedure ( parser_i ) :: the_parser integer , intent ( in ) :: times type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = start ( the_state ) contains pure function start ( state_ ) result ( result_ ) use iso_varying_string , only : varying_string , var_str type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( parsed_items_t ) :: empty type ( intermediate_repeat_t ) :: initial if ( times <= 0 ) then allocate ( empty % items , source = [ parsed_item_t :: ]) result_ = empty_ok ( empty , state_ % input , state_ % position , message ( & state_ % position , var_str ( \"\" ), [ varying_string :: ])) else initial % remaining = times allocate ( initial % parsed_so_far % items , source = [ parsed_item_t :: ]) result_ = sequence ( return_ ( initial , state_ ), recurse ) end if end function pure recursive function recurse ( previous , state_ ) result ( result_ ) use iso_varying_string , only : varying_string , var_str class ( parsed_value_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( parsed_items_t ) :: final_list select type ( previous ) type is ( intermediate_repeat_t ) if ( previous % remaining <= 0 ) then allocate ( final_list % items , source = & previous % parsed_so_far % items ) result_ = consumed_ok ( & final_list , & state_ % input , & state_ % position , & message ( state_ % position , var_str ( \"\" ), [ varying_string :: ])) else result_ = sequence ( parse_next ( previous , state_ ), recurse ) end if end select end function pure function parse_next ( previous , state_ ) result ( result_ ) type ( intermediate_repeat_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( intermediate_repeat_t ) :: next type ( parsed_item_t ) :: this_item result_ = the_parser ( state_ ) if ( result_ % ok ) then next % remaining = previous % remaining - 1 allocate ( this_item % item , source = result_ % parsed ) allocate ( next % parsed_so_far % items , source = [ previous % parsed_so_far % items , this_item ]) deallocate ( result_ % parsed ) allocate ( result_ % parsed , source = next ) end if end function end function pure function return_ ( parsed , state_ ) result ( result_ ) use iso_varying_string , only : varying_string , var_str class ( parsed_value_t ), intent ( in ) :: parsed type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = empty_ok ( & parsed , state_ % input , state_ % position , message ( & state_ % position , var_str ( \"\" ), [ varying_string :: ])) end function pure function satisfy ( matches , state_ ) result ( result_ ) use iso_varying_string , only : varying_string , len , var_str use strff , only : first_character , without_first_character procedure ( match_i ) :: matches type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ character ( len = 1 ) :: first_character_ type ( position_t ) :: new_position type ( parsed_character_t ) :: parsed_character if ( len ( state_ % input ) > 0 ) then first_character_ = first_character ( state_ % input ) if ( matches ( first_character_ )) then new_position = next_position ( first_character_ , state_ % position ) parsed_character % value_ = first_character_ result_ = consumed_ok ( & parsed_character , & without_first_character ( state_ % input ), & new_position , & message ( & new_position , & var_str ( \"\" ), & [ varying_string :: ])) else result_ = empty_error ( message ( & state_ % position , & var_str ( first_character_ ), & [ varying_string :: ])) end if else result_ = empty_error ( message ( & state_ % position , & var_str ( \"end of input\" ), & [ varying_string :: ])) end if end function pure recursive function sequence_parser ( parser1 , parser2 , state_ ) result ( result_ ) procedure ( parser_i ) :: parser1 procedure ( then_parser_i ) :: parser2 type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = sequence ( parser1 ( state_ ), parser2 ) end function pure recursive function sequence_result ( previous , parser ) result ( result_ ) type ( parser_output_t ), intent ( in ) :: previous procedure ( then_parser_i ) :: parser type ( parser_output_t ) :: result_ if ( previous % ok ) then result_ = parser ( & previous % parsed , & state ( previous % remaining , previous % position )) if (. not . previous % empty ) then result_ % empty = . false . end if else result_ = previous end if end function pure function state ( input , position ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: input type ( position_t ), intent ( in ) :: position type ( state_t ) :: state state % input = input state % position = position end function pure function then_drop_parser ( parser1 , parser2 , state_ ) result ( result_ ) procedure ( parser_i ) :: parser1 procedure ( parser_i ) :: parser2 type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = then_drop ( parser1 ( state_ ), parser2 ) end function pure function then_drop_result ( previous , parser ) result ( result_ ) type ( parser_output_t ), intent ( in ) :: previous procedure ( parser_i ) :: parser type ( parser_output_t ) :: result_ if ( previous % ok ) then result_ = parser ( & state ( previous % remaining , previous % position )) result_ % empty = previous % empty . and . result_ % empty if ( result_ % ok ) then deallocate ( result_ % parsed ) allocate ( result_ % parsed , source = previous % parsed ) end if else result_ = previous end if end function pure recursive function with_label_c ( label , parse , state_ ) result ( result_ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: label procedure ( parser_i ) :: parse type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = with_label ( var_str ( label ), parse , state_ ) end function pure recursive function with_label_s ( label , parse , state_ ) result ( result_ ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: label procedure ( parser_i ) :: parse type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ type ( parser_output_t ) :: the_result type ( message_t ) :: the_message the_result = parse ( state_ ) if ( the_result % empty ) then if ( the_result % ok ) then the_message = expect ( the_result % message , label ) result_ = empty_ok ( & the_result % parsed , & the_result % remaining , & the_result % position , & the_message ) else the_message = expect ( the_result % message , label ) result_ = empty_error ( the_message ) end if else result_ = the_result end if end function end module","tags":"","loc":"sourcefile/parff.f90.html","title":"parff.f90 – miniFAVOR"},{"text":"Contents Programs simple_put_line Source Code main.f90 Source Code program simple_put_line use iso_varying_string , only : put_line implicit none call put_line ( \"hello from simple_put_line\" ) end program","tags":"","loc":"sourcefile/main.f90~2.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Programs simple_get Source Code main.f90 Source Code program simple_get use iso_varying_string , only : & varying_string , operator ( // ), operator ( /= ), get , put_line implicit none type ( varying_string ) :: string call get ( string ) if ( string /= \"hello simple_get\" ) then call put_line ( \"expected 'hello simple_get' but got '\" // string // \"'\" ) error stop end if end program","tags":"","loc":"sourcefile/main.f90~3.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Modules split_character_set_test Source Code split_character_set_test.f90 Source Code module split_character_set_test implicit none private public :: test_split_character contains function test_split_character () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: back_tests ( 3 ) type ( test_item_t ) :: forward_separator_tests ( 2 ) type ( test_item_t ) :: not_back_separator_tests ( 2 ) type ( test_item_t ) :: back_separator_tests ( 2 ) type ( test_item_t ) :: forward_no_separator_set_tests ( 3 ) type ( test_item_t ) :: forward_separator_set_tests ( 3 ) type ( test_item_t ) :: not_back_no_separator_set_tests ( 3 ) type ( test_item_t ) :: not_back_separator_set_tests ( 3 ) type ( test_item_t ) :: back_no_separator_set_tests ( 3 ) type ( test_item_t ) :: back_separator_set_tests ( 3 ) forward_no_separator_set_tests ( 1 ) = it ( & \"The characters passed over in the search are returned in the\" & // \" argument word, and the remainder of the string, not\" & // \" including the sperator character is returned in the argument string\" , & check_forward_no_separator ) forward_no_separator_set_tests ( 2 ) = it ( & \"If no character from set is found, string is returned as zero length\" , & check_forward_no_separator_not_found ) forward_no_separator_set_tests ( 3 ) = it ( & \"If set is of zero length, string is returned as zero length\" , & check_forward_no_separator_empty_set ) forward_separator_set_tests ( 1 ) = it ( & \"The characters passed over in the search are returned in the\" & // \" argument word, and the remainder of the string, not\" & // \" including the sperator character is returned in the argument string\" , & check_forward_with_separator ) forward_separator_set_tests ( 2 ) = it ( & \"If no character from set is found, separator is returned as zero length\" , & check_forward_with_separator_not_found ) forward_separator_set_tests ( 3 ) = it ( & \"If set is of zero length, separator is returned as zero length\" , & check_forward_with_separator_empty_set ) not_back_no_separator_set_tests ( 1 ) = it ( & \"The characters passed over in the search are returned in the\" & // \" argument word, and the remainder of the string, not\" & // \" including the sperator character is returned in the argument string\" , & check_not_backward_no_separator ) not_back_no_separator_set_tests ( 2 ) = it ( & \"If no character from set is found, string is returned as zero length\" , & check_not_backward_no_separator_not_found ) not_back_no_separator_set_tests ( 3 ) = it ( & \"If set is of zero length, string is returned as zero length\" , & check_not_backward_no_separator_empty_set ) not_back_separator_set_tests ( 1 ) = it ( & \"The characters passed over in the search are returned in the\" & // \" argument word, and the remainder of the string, not\" & // \" including the sperator character is returned in the argument string\" , & check_not_backward_with_separator ) not_back_separator_set_tests ( 2 ) = it ( & \"If no character from set is found, separator is returned as zero length\" , & check_not_backward_with_separator_not_found ) not_back_separator_set_tests ( 3 ) = it ( & \"If set is of zero length, separator is returned as zero length\" , & check_not_backward_with_separator_empty_set ) back_no_separator_set_tests ( 1 ) = it ( & \"The characters passed over in the search are returned in the\" & // \" argument word, and the remainder of the string, not\" & // \" including the sperator character is returned in the argument string\" , & check_backward_no_separator ) back_no_separator_set_tests ( 2 ) = it ( & \"If no character from set is found, string is returned as zero length\" , & check_backward_no_separator_not_found ) back_no_separator_set_tests ( 3 ) = it ( & \"If set is of zero length, string is returned as zero length\" , & check_backward_no_separator_empty_set ) back_separator_set_tests ( 1 ) = it ( & \"The characters passed over in the search are returned in the\" & // \" argument word, and the remainder of the string, not\" & // \" including the sperator character is returned in the argument string\" , & check_backward_with_separator ) back_separator_set_tests ( 2 ) = it ( & \"If no character from set is found, separator is returned as zero length\" , & check_backward_with_separator_not_found ) back_separator_set_tests ( 3 ) = it ( & \"If set is of zero length, separator is returned as zero length\" , & check_backward_with_separator_empty_set ) forward_separator_tests ( 1 ) = describe ( & \"Without separator argument\" , & forward_no_separator_set_tests ) forward_separator_tests ( 2 ) = describe ( & \"If the argument seprator is present, the actual character\" & // \" found which separates the word from the remainder of the\" & // \" string is returned in separator\" , & forward_separator_set_tests ) not_back_separator_tests ( 1 ) = describe ( & \"Without separator argument\" , & not_back_no_separator_set_tests ) not_back_separator_tests ( 2 ) = describe ( & \"If the argument seprator is present, the actual character\" & // \" found which separates the word from the remainder of the\" & // \" string is returned in separator\" , & not_back_separator_set_tests ) back_separator_tests ( 1 ) = describe ( & \"Without separator argument\" , & back_no_separator_set_tests ) back_separator_tests ( 2 ) = describe ( & \"If the argument seprator is present, the actual character\" & // \" found which separates the word from the remainder of the\" & // \" string is returned in separator\" , & back_separator_set_tests ) back_tests ( 1 ) = describe ( & \"The string is searched in the forward direction\" , & forward_separator_tests ) back_tests ( 2 ) = describe ( & \"The string is searched in the forward direction if back is false\" , & not_back_separator_tests ) back_tests ( 3 ) = describe ( & \"The string is searched in the backward direction if back is true\" , & back_separator_tests ) tests = describe ( & \"Sec. 3.7.5: SPLIT divides the string at the first occurence of a character that is in set (character)\" , & back_tests ) end function pure function check_forward_no_separator () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \" ,\" ) result_ = & assert_equals ( \"split\" , word ) & . and . assert_equals ( \" this\" , string ) end function pure function check_forward_no_separator_not_found () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \"!\" ) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) end function pure function check_forward_no_separator_empty_set () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \"\" ) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) end function pure function check_forward_with_separator () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \" ,\" , separator ) result_ = & assert_equals ( \"split\" , word ) & . and . assert_equals ( \" this\" , string ) & . and . assert_equals ( \",\" , separator ) end function pure function check_forward_with_separator_not_found () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \"!\" , separator ) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) & . and . assert_empty ( separator ) end function pure function check_forward_with_separator_empty_set () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \"\" , separator ) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) & . and . assert_empty ( separator ) end function pure function check_not_backward_no_separator () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \" ,\" , back = . false .) result_ = & assert_equals ( \"split\" , word ) & . and . assert_equals ( \" this\" , string ) end function pure function check_not_backward_no_separator_not_found () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \"!\" , back = . false .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) end function pure function check_not_backward_no_separator_empty_set () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \"\" , back = . false .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) end function pure function check_not_backward_with_separator () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \" ,\" , separator , . false .) result_ = & assert_equals ( \"split\" , word ) & . and . assert_equals ( \" this\" , string ) & . and . assert_equals ( \",\" , separator ) end function pure function check_not_backward_with_separator_not_found () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \"!\" , separator , . false .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) & . and . assert_empty ( separator ) end function pure function check_not_backward_with_separator_empty_set () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \"\" , separator , . false .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) & . and . assert_empty ( separator ) end function pure function check_backward_no_separator () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \" ,\" , back = . true .) result_ = & assert_equals ( \"this\" , word ) & . and . assert_equals ( \"split,\" , string ) end function pure function check_backward_no_separator_not_found () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \"!\" , back = . true .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) end function pure function check_backward_no_separator_empty_set () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \"\" , back = . true .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) end function pure function check_backward_with_separator () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \" ,\" , separator , . true .) result_ = & assert_equals ( \"this\" , word ) & . and . assert_equals ( \"split,\" , string ) & . and . assert_equals ( \" \" , separator ) end function pure function check_backward_with_separator_not_found () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \"!\" , separator , . true .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) & . and . assert_empty ( separator ) end function pure function check_backward_with_separator_empty_set () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , \"\" , separator , . true .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) & . and . assert_empty ( separator ) end function end module","tags":"","loc":"sourcefile/split_character_set_test.f90.html","title":"split_character_set_test.f90 – miniFAVOR"},{"text":"Contents Modules llt_test Source Code llt_test.f90 Source Code module llt_test implicit none private public :: test_llt contains function test_llt () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_llt_string ) individual_tests ( 2 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_character_llt_string ) individual_tests ( 3 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_llt_character ) tests = describe ( & \"Sec. 3.4.12: LLT functions the same as for two characters for\" , & individual_tests ) end function pure function check_string_llt_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , llt use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & llt ( char ( strings % first ), char ( strings % second )) & . eqv . llt ( strings % first , strings % second ), & 'llt(\"' // strings % first // '\", \"' // strings % second // '\")' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_character_llt_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , llt use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & llt ( char ( strings % first ), char ( strings % second )) & . eqv . llt ( char ( strings % first ), strings % second ), & 'llt(\"' // strings % first // '\", \"' // strings % second // '\")' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_string_llt_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , llt use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & llt ( char ( strings % first ), char ( strings % second )) & . eqv . llt ( strings % first , char ( strings % second )), & 'llt(\"' // strings % first // '\", \"' // strings % second // '\")' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/llt_test.f90.html","title":"llt_test.f90 – miniFAVOR"},{"text":"Contents Modules custom_generator Source Code custom_generator.f90 Source Code module custom_generator use iso_varying_string , only : varying_string use vegetables , only : generator_t , input_t implicit none private public :: & character_input_t , & string_and_integer_input_t , & string_pair_input_t , & ascii_character_generator_t , & ascii_string_and_integer_generator_t , & ascii_string_pair_generator_t , & ASCII_CHARACTER_GENERATOR , & ASCII_STRING_AND_INTEGER_GENERATOR , & ASCII_STRING_PAIR_GENERATOR type , extends ( input_t ) :: character_input_t character ( len = 1 ) :: value_ end type type , extends ( input_t ) :: string_and_integer_input_t type ( varying_string ) :: string integer :: integer_ end type type , extends ( input_t ) :: string_pair_input_t type ( varying_string ) :: first type ( varying_string ) :: second end type type , extends ( generator_t ) :: ascii_character_generator_t contains private procedure , public :: generate => generate_character procedure , public , nopass :: shrink => shrink_character end type type , extends ( generator_t ) :: ascii_string_and_integer_generator_t contains private procedure , public :: generate => generate_string_and_integer procedure , public , nopass :: shrink => shrink_string_and_integer end type type , extends ( generator_t ) :: ascii_string_pair_generator_t contains private procedure , public :: generate => generate_string_pair procedure , public , nopass :: shrink => shrink_string_pair end type type ( ascii_character_generator_t ), parameter :: & ASCII_CHARACTER_GENERATOR = ascii_character_generator_t () type ( ascii_string_and_integer_generator_t ), parameter :: & ASCII_STRING_AND_INTEGER_GENERATOR = ascii_string_and_integer_generator_t () type ( ascii_string_pair_generator_t ), parameter :: & ASCII_STRING_PAIR_GENERATOR = ascii_string_pair_generator_t () contains function generate_character ( self ) result ( generated_value ) use vegetables , only : generated_t , generated , get_random_ascii_character class ( ascii_character_generator_t ), intent ( in ) :: self type ( generated_t ) :: generated_value type ( character_input_t ) :: the_input associate ( a => self ) end associate the_input % value_ = get_random_ascii_character () generated_value = generated ( the_input ) end function function generate_string_and_integer ( self ) result ( generated_value ) use vegetables , only : & generated_t , & generated , & get_random_integer_with_range , & get_random_ascii_string class ( ascii_string_and_integer_generator_t ), intent ( in ) :: self type ( generated_t ) :: generated_value type ( string_and_integer_input_t ) :: pair associate ( a => self ) end associate pair % string = get_random_ascii_string () pair % integer_ = get_random_integer_with_range ( 0 , 10 ) generated_value = generated ( pair ) end function function generate_string_pair ( self ) result ( generated_value ) use vegetables , only : generated_t , generated , get_random_ascii_string class ( ascii_string_pair_generator_t ), intent ( in ) :: self type ( generated_t ) :: generated_value type ( string_pair_input_t ) :: pair associate ( a => self ) end associate pair % first = get_random_ascii_string () pair % second = get_random_ascii_string () generated_value = generated ( pair ) end function pure function shrink_character ( input ) result ( shrunk ) use vegetables , only : input_t , shrink_result_t , simplest_value class ( input_t ), intent ( in ) :: input type ( shrink_result_t ) :: shrunk shrunk = simplest_value ( input ) end function pure function shrink_string_and_integer ( input ) result ( shrunk ) use iso_varying_string , only : assignment ( = ), char , len use vegetables , only : & input_t , shrink_result_t , shrunk_value , simplest_value class ( input_t ), intent ( in ) :: input type ( shrink_result_t ) :: shrunk type ( string_and_integer_input_t ) :: shrunk_value_ select type ( input ) type is ( string_and_integer_input_t ) if ( input % integer_ == 0 ) then if ( len ( input % string ) <= 1 ) then shrunk_value_ % integer_ = 0 shrunk_value_ % string = \"\" shrunk = simplest_value ( shrunk_value_ ) else shrunk_value_ % integer_ = 0 shrunk_value_ % string = char ( input % string , len ( input % string ) - 1 ) shrunk = shrunk_value ( shrunk_value_ ) end if else if ( len ( input % string ) <= 1 ) then shrunk_value_ % integer_ = input % integer_ / 2 shrunk_value_ % string = \"\" shrunk = shrunk_value ( shrunk_value_ ) else shrunk_value_ % integer_ = input % integer_ / 2 shrunk_value_ % string = char ( input % string , len ( input % string ) - 1 ) shrunk = shrunk_value ( shrunk_value_ ) end if end if end select end function pure function shrink_string_pair ( input ) result ( shrunk ) use iso_varying_string , only : assignment ( = ), char , len use vegetables , only : & input_t , shrink_result_t , shrunk_value , simplest_value class ( input_t ), intent ( in ) :: input type ( shrink_result_t ) :: shrunk type ( string_pair_input_t ) :: shrunk_value_ select type ( input ) type is ( string_pair_input_t ) if ( len ( input % first ) <= 1 ) then if ( len ( input % second ) <= 1 ) then shrunk_value_ % first = \"\" shrunk_value_ % second = \"\" shrunk = simplest_value ( shrunk_value_ ) else shrunk_value_ % first = \"\" shrunk_value_ % second = char ( input % second , len ( input % second ) - 1 ) shrunk = shrunk_value ( shrunk_value_ ) end if else if ( len ( input % second ) <= 1 ) then shrunk_value_ % first = char ( input % first , len ( input % first ) - 1 ) shrunk_value_ % second = \"\" shrunk = shrunk_value ( shrunk_value_ ) else shrunk_value_ % first = char ( input % first , len ( input % first ) - 1 ) shrunk_value_ % second = char ( input % second , len ( input % second ) - 1 ) shrunk = shrunk_value ( shrunk_value_ ) end if end if end select end function end module","tags":"","loc":"sourcefile/custom_generator.f90.html","title":"custom_generator.f90 – miniFAVOR"},{"text":"Contents Modules adjustr_test Source Code adjustr_test.f90 Source Code module adjustr_test implicit none private public :: test_adjustr contains function test_adjustr () result ( tests ) use vegetables , only : test_item_t , describe , it , ASCII_STRING_GENERATOR type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 1 ) individual_tests = it ( & \"works the same for characters and strings\" , & ASCII_STRING_GENERATOR , & check_adjustr ) tests = describe ( \"Sec 3.4.2: ADJUSTR\" , individual_tests ) end function pure function check_adjustr ( string ) result ( result_ ) use iso_varying_string , only : adjustr , char use vegetables , only : & input_t , result_t , string_input_t , assert_equals , fail class ( input_t ), intent ( in ) :: string type ( result_t ) :: result_ select type ( string ) type is ( string_input_t ) result_ = assert_equals ( & adjustr ( char ( string % value_ )), & adjustr ( string % value_ )) class default result_ = fail ( \"Expected to get a string_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/adjustr_test.f90.html","title":"adjustr_test.f90 – miniFAVOR"},{"text":"Contents Modules not_equal_test Source Code not_equal_test.f90 Source Code module not_equal_test implicit none private public :: test_not_equals contains function test_not_equals () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_not_equal_string ) individual_tests ( 2 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_character_not_equal_string ) individual_tests ( 3 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_not_equal_character ) tests = describe ( & \"Sec. 3.3.3: operator(/=) functions the same as for two characters for\" , & individual_tests ) end function pure function check_string_not_equal_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( /= ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) /= char ( strings % second ) & . eqv . strings % first /= strings % second , & '\"' // strings % first // '\" /= \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_character_not_equal_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( /= ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) /= char ( strings % second ) & . eqv . char ( strings % first ) /= strings % second , & '\"' // strings % first // '\" /= \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_string_not_equal_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( /= ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) /= char ( strings % second ) & . eqv . strings % first /= char ( strings % second ), & '\"' // strings % first // '\" /= \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/not_equal_test.f90.html","title":"not_equal_test.f90 – miniFAVOR"},{"text":"Contents Modules split_string_set_test Source Code split_string_set_test.f90 Source Code module split_string_set_test implicit none private public :: test_split_character contains function test_split_character () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: back_tests ( 3 ) type ( test_item_t ) :: forward_separator_tests ( 2 ) type ( test_item_t ) :: not_back_separator_tests ( 2 ) type ( test_item_t ) :: back_separator_tests ( 2 ) type ( test_item_t ) :: forward_no_separator_set_tests ( 3 ) type ( test_item_t ) :: forward_separator_set_tests ( 3 ) type ( test_item_t ) :: not_back_no_separator_set_tests ( 3 ) type ( test_item_t ) :: not_back_separator_set_tests ( 3 ) type ( test_item_t ) :: back_no_separator_set_tests ( 3 ) type ( test_item_t ) :: back_separator_set_tests ( 3 ) forward_no_separator_set_tests ( 1 ) = it ( & \"The characters passed over in the search are returned in the\" & // \" argument word, and the remainder of the string, not\" & // \" including the sperator character is returned in the argument string\" , & check_forward_no_separator ) forward_no_separator_set_tests ( 2 ) = it ( & \"If no character from set is found, string is returned as zero length\" , & check_forward_no_separator_not_found ) forward_no_separator_set_tests ( 3 ) = it ( & \"If set is of zero length, string is returned as zero length\" , & check_forward_no_separator_empty_set ) forward_separator_set_tests ( 1 ) = it ( & \"The characters passed over in the search are returned in the\" & // \" argument word, and the remainder of the string, not\" & // \" including the sperator character is returned in the argument string\" , & check_forward_with_separator ) forward_separator_set_tests ( 2 ) = it ( & \"If no character from set is found, separator is returned as zero length\" , & check_forward_with_separator_not_found ) forward_separator_set_tests ( 3 ) = it ( & \"If set is of zero length, separator is returned as zero length\" , & check_forward_with_separator_empty_set ) not_back_no_separator_set_tests ( 1 ) = it ( & \"The characters passed over in the search are returned in the\" & // \" argument word, and the remainder of the string, not\" & // \" including the sperator character is returned in the argument string\" , & check_not_backward_no_separator ) not_back_no_separator_set_tests ( 2 ) = it ( & \"If no character from set is found, string is returned as zero length\" , & check_not_backward_no_separator_not_found ) not_back_no_separator_set_tests ( 3 ) = it ( & \"If set is of zero length, string is returned as zero length\" , & check_not_backward_no_separator_empty_set ) not_back_separator_set_tests ( 1 ) = it ( & \"The characters passed over in the search are returned in the\" & // \" argument word, and the remainder of the string, not\" & // \" including the sperator character is returned in the argument string\" , & check_not_backward_with_separator ) not_back_separator_set_tests ( 2 ) = it ( & \"If no character from set is found, separator is returned as zero length\" , & check_not_backward_with_separator_not_found ) not_back_separator_set_tests ( 3 ) = it ( & \"If set is of zero length, separator is returned as zero length\" , & check_not_backward_with_separator_empty_set ) back_no_separator_set_tests ( 1 ) = it ( & \"The characters passed over in the search are returned in the\" & // \" argument word, and the remainder of the string, not\" & // \" including the sperator character is returned in the argument string\" , & check_backward_no_separator ) back_no_separator_set_tests ( 2 ) = it ( & \"If no character from set is found, string is returned as zero length\" , & check_backward_no_separator_not_found ) back_no_separator_set_tests ( 3 ) = it ( & \"If set is of zero length, string is returned as zero length\" , & check_backward_no_separator_empty_set ) back_separator_set_tests ( 1 ) = it ( & \"The characters passed over in the search are returned in the\" & // \" argument word, and the remainder of the string, not\" & // \" including the sperator character is returned in the argument string\" , & check_backward_with_separator ) back_separator_set_tests ( 2 ) = it ( & \"If no character from set is found, separator is returned as zero length\" , & check_backward_with_separator_not_found ) back_separator_set_tests ( 3 ) = it ( & \"If set is of zero length, separator is returned as zero length\" , & check_backward_with_separator_empty_set ) forward_separator_tests ( 1 ) = describe ( & \"Without separator argument\" , & forward_no_separator_set_tests ) forward_separator_tests ( 2 ) = describe ( & \"If the argument seprator is present, the actual character\" & // \" found which separates the word from the remainder of the\" & // \" string is returned in separator\" , & forward_separator_set_tests ) not_back_separator_tests ( 1 ) = describe ( & \"Without separator argument\" , & not_back_no_separator_set_tests ) not_back_separator_tests ( 2 ) = describe ( & \"If the argument seprator is present, the actual character\" & // \" found which separates the word from the remainder of the\" & // \" string is returned in separator\" , & not_back_separator_set_tests ) back_separator_tests ( 1 ) = describe ( & \"Without separator argument\" , & back_no_separator_set_tests ) back_separator_tests ( 2 ) = describe ( & \"If the argument seprator is present, the actual character\" & // \" found which separates the word from the remainder of the\" & // \" string is returned in separator\" , & back_separator_set_tests ) back_tests ( 1 ) = describe ( & \"The string is searched in the forward direction\" , & forward_separator_tests ) back_tests ( 2 ) = describe ( & \"The string is searched in the forward direction if back is false\" , & not_back_separator_tests ) back_tests ( 3 ) = describe ( & \"The string is searched in the backward direction if back is true\" , & back_separator_tests ) tests = describe ( & \"Sec. 3.7.5: SPLIT divides the string at the first occurence of a character that is in set (string)\" , & back_tests ) end function pure function check_forward_no_separator () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \" ,\" )) result_ = & assert_equals ( \"split\" , word ) & . and . assert_equals ( \" this\" , string ) end function pure function check_forward_no_separator_not_found () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \"!\" )) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) end function pure function check_forward_no_separator_empty_set () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \"\" )) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) end function pure function check_forward_with_separator () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \" ,\" ), separator ) result_ = & assert_equals ( \"split\" , word ) & . and . assert_equals ( \" this\" , string ) & . and . assert_equals ( \",\" , separator ) end function pure function check_forward_with_separator_not_found () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \"!\" ), separator ) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) & . and . assert_empty ( separator ) end function pure function check_forward_with_separator_empty_set () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \"\" ), separator ) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) & . and . assert_empty ( separator ) end function pure function check_not_backward_no_separator () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \" ,\" ), back = . false .) result_ = & assert_equals ( \"split\" , word ) & . and . assert_equals ( \" this\" , string ) end function pure function check_not_backward_no_separator_not_found () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \"!\" ), back = . false .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) end function pure function check_not_backward_no_separator_empty_set () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \"\" ), back = . false .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) end function pure function check_not_backward_with_separator () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \" ,\" ), separator , . false .) result_ = & assert_equals ( \"split\" , word ) & . and . assert_equals ( \" this\" , string ) & . and . assert_equals ( \",\" , separator ) end function pure function check_not_backward_with_separator_not_found () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \"!\" ), separator , . false .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) & . and . assert_empty ( separator ) end function pure function check_not_backward_with_separator_empty_set () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \"\" ), separator , . false .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) & . and . assert_empty ( separator ) end function pure function check_backward_no_separator () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \" ,\" ), back = . true .) result_ = & assert_equals ( \"this\" , word ) & . and . assert_equals ( \"split,\" , string ) end function pure function check_backward_no_separator_not_found () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \"!\" ), back = . true .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) end function pure function check_backward_no_separator_empty_set () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \"\" ), back = . true .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) end function pure function check_backward_with_separator () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \" ,\" ), separator , . true .) result_ = & assert_equals ( \"this\" , word ) & . and . assert_equals ( \"split,\" , string ) & . and . assert_equals ( \" \" , separator ) end function pure function check_backward_with_separator_not_found () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \"!\" ), separator , . true .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) & . and . assert_empty ( separator ) end function pure function check_backward_with_separator_empty_set () result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), split , var_str use vegetables , only : result_t , assert_empty , assert_equals type ( result_t ) :: result_ type ( varying_string ) :: separator type ( varying_string ) :: string type ( varying_string ) :: word string = \"split, this\" call split ( string , word , var_str ( \"\" ), separator , . true .) result_ = & assert_empty ( string ) & . and . assert_equals ( \"split, this\" , word ) & . and . assert_empty ( separator ) end function end module","tags":"","loc":"sourcefile/split_string_set_test.f90.html","title":"split_string_set_test.f90 – miniFAVOR"},{"text":"Contents Modules lge_test Source Code lge_test.f90 Source Code module lge_test implicit none private public :: test_lge contains function test_lge () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_lge_string ) individual_tests ( 2 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_character_lge_string ) individual_tests ( 3 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_lge_character ) tests = describe ( & \"Sec. 3.4.9: LGE functions the same as for two characters for\" , & individual_tests ) end function pure function check_string_lge_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , lge use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & lge ( char ( strings % first ), char ( strings % second )) & . eqv . lge ( strings % first , strings % second ), & 'lge(\"' // strings % first // '\", \"' // strings % second // '\")' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_character_lge_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , lge use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & lge ( char ( strings % first ), char ( strings % second )) & . eqv . lge ( char ( strings % first ), strings % second ), & 'lge(\"' // strings % first // '\", \"' // strings % second // '\")' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_string_lge_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , lge use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & lge ( char ( strings % first ), char ( strings % second )) & . eqv . lge ( strings % first , char ( strings % second )), & 'lge(\"' // strings % first // '\", \"' // strings % second // '\")' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/lge_test.f90.html","title":"lge_test.f90 – miniFAVOR"},{"text":"Contents Modules index_test Source Code index_test.f90 Source Code module index_test implicit none private public :: test_index contains function test_index () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_index_strings ) individual_tests ( 2 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_index_string_and_character ) individual_tests ( 3 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_index_character_and_string ) tests = describe ( & \"Sec. 3.4.6: INDEX functions the same as for two characters for\" , & individual_tests ) end function pure function check_index_strings ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , index use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = & assert_equals ( & index ( char ( strings % first ), char ( strings % second )), & index ( strings % first , strings % second ), & 'index(\"' // strings % first // '\", \"' // strings % second // '\")' ) & . and . assert_equals ( & index ( char ( strings % first ), char ( strings % second ), . false .), & index ( strings % first , strings % second , . false .), & 'index(\"' // strings % first // '\", \"' // strings % second // '\", .false.)' ) & . and . assert_equals ( & index ( char ( strings % first ), char ( strings % second ), . true .), & index ( strings % first , strings % second , . true .), & 'index(\"' // strings % first // '\", \"' // strings % second // '\", .true.)' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_index_string_and_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , index use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = & assert_equals ( & index ( char ( strings % first ), char ( strings % second )), & index ( strings % first , char ( strings % second )), & 'index(\"' // strings % first // '\", \"' // strings % second // '\")' ) & . and . assert_equals ( & index ( char ( strings % first ), char ( strings % second ), . false .), & index ( strings % first , char ( strings % second ), . false .), & 'index(\"' // strings % first // '\", \"' // strings % second // '\", .false.)' ) & . and . assert_equals ( & index ( char ( strings % first ), char ( strings % second ), . true .), & index ( strings % first , char ( strings % second ), . true .), & 'index(\"' // strings % first // '\", \"' // strings % second // '\", .true.)' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_index_character_and_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , index use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = & assert_equals ( & index ( char ( strings % first ), char ( strings % second )), & index ( char ( strings % first ), strings % second ), & 'index(\"' // strings % first // '\", \"' // strings % second // '\")' ) & . and . assert_equals ( & index ( char ( strings % first ), char ( strings % second ), . false .), & index ( char ( strings % first ), strings % second , . false .), & 'index(\"' // strings % first // '\", \"' // strings % second // '\", .false.)' ) & . and . assert_equals ( & index ( char ( strings % first ), char ( strings % second ), . true .), & index ( char ( strings % first ), strings % second , . true .), & 'index(\"' // strings % first // '\", \"' // strings % second // '\", .true.)' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/index_test.f90.html","title":"index_test.f90 – miniFAVOR"},{"text":"Contents Modules lgt_test Source Code lgt_test.f90 Source Code module lgt_test implicit none private public :: test_lgt contains function test_lgt () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_lgt_string ) individual_tests ( 2 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_character_lgt_string ) individual_tests ( 3 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_lgt_character ) tests = describe ( & \"Sec. 3.4.10: LGT functions the same as for two characters for\" , & individual_tests ) end function pure function check_string_lgt_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , lgt use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & lgt ( char ( strings % first ), char ( strings % second )) & . eqv . lgt ( strings % first , strings % second ), & 'lgt(\"' // strings % first // '\", \"' // strings % second // '\")' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_character_lgt_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , lgt use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & lgt ( char ( strings % first ), char ( strings % second )) & . eqv . lgt ( char ( strings % first ), strings % second ), & 'lgt(\"' // strings % first // '\", \"' // strings % second // '\")' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_string_lgt_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , lgt use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & lgt ( char ( strings % first ), char ( strings % second )) & . eqv . lgt ( strings % first , char ( strings % second )), & 'lgt(\"' // strings % first // '\", \"' // strings % second // '\")' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/lgt_test.f90.html","title":"lgt_test.f90 – miniFAVOR"},{"text":"Contents Modules iachar_test Source Code iachar_test.f90 Source Code module iachar_test implicit none private public :: test_iachar contains function test_iachar () result ( tests ) use custom_generator , only : ASCII_CHARACTER_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 1 ) individual_tests ( 1 ) = it ( & \"works the same for characters and strings\" , & ASCII_CHARACTER_GENERATOR , & check_iachar ) tests = describe ( \"Sec. 3.4.4: IACHAR\" , individual_tests ) end function pure function check_iachar ( char_ ) result ( result_ ) use custom_generator , only : character_input_t use iso_varying_string , only : iachar , var_str use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: char_ type ( result_t ) :: result_ select type ( char_ ) type is ( character_input_t ) result_ = assert_equals ( & iachar ( char_ % value_ ), & iachar ( var_str ( char_ % value_ )), & char_ % value_ ) class default result_ = fail ( \"Expected to get a character_input_t.\" ) end select end function end module","tags":"","loc":"sourcefile/iachar_test.f90.html","title":"iachar_test.f90 – miniFAVOR"},{"text":"Contents Modules char_test Source Code char_test.f90 Source Code module char_test implicit none private public :: test_char contains function test_char () result ( tests ) use vegetables , only : test_item_t , describe , it , ASCII_STRING_GENERATOR type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 5 ) individual_tests ( 1 ) = it ( & \"converts a varying string to a character with the same length\" , & ASCII_STRING_GENERATOR , & check_char_without_length ) individual_tests ( 2 ) = it ( & \"converts a varying string to a shorter character\" , & check_char_with_shorter_length ) individual_tests ( 3 ) = it ( & \"converts a varying string to a longer character\" , & check_char_with_longer_length ) individual_tests ( 4 ) = it ( & \"gives a zero length character for length = 0\" , & check_char_with_zero_length ) individual_tests ( 5 ) = it ( & \"gives a zero length character for negative length\" , & check_char_with_negative_length ) tests = describe ( \"Sec. 3.4.3: CHAR\" , individual_tests ) end function pure function check_char_without_length ( example ) result ( result_ ) use iso_varying_string , only : char use vegetables , only : & input_t , result_t , string_input_t , assert_equals , fail class ( input_t ), intent ( in ) :: example type ( result_t ) :: result_ select type ( example ) type is ( string_input_t ) result_ = assert_equals ( & example % value_ , & char ( example % value_ ), & \"If length is absent, the result is a copy of the\" & // \" characters in the argument string\" ) class default result_ = fail ( \"Expected to get a string_input_t\" ) end select end function pure function check_char_with_shorter_length () result ( result_ ) use iso_varying_string , only : char , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"EXAM\" , & char ( var_str ( \"EXAMPLE\" ), 4 ), & \"If string is longer than length, result is truncated on the right.\" ) end function pure function check_char_with_longer_length () result ( result_ ) use iso_varying_string , only : char , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"EXAMPLE   \" , & char ( var_str ( \"EXAMPLE\" ), 10 ), & \"If string is shorter than length, the result is padded on the\" & // \" right with blanks.\" ) end function pure function check_char_with_zero_length () result ( result_ ) use iso_varying_string , only : char , var_str use vegetables , only : result_t , assert_empty type ( result_t ) :: result_ result_ = assert_empty ( & char ( var_str ( \"EXAMPLE\" ), 0 ), & \"If length is less than one, the result is of zero length.\" ) end function pure function check_char_with_negative_length () result ( result_ ) use iso_varying_string , only : char , var_str use vegetables , only : result_t , assert_empty type ( result_t ) :: result_ result_ = assert_empty ( & char ( var_str ( \"EXAMPLE\" ), - 1 ), & \"If length is less than one, the result is of zero length.\" ) end function end module","tags":"","loc":"sourcefile/char_test.f90.html","title":"char_test.f90 – miniFAVOR"},{"text":"Contents Programs main Source Code main.f90 Source Code ! Generated by make_vegetable_driver. DO NOT EDIT program main implicit none call run () contains subroutine run () use adjustl_test , only : & adjustl_adjustl => test_adjustl use adjustr_test , only : & adjustr_adjustr => test_adjustr use assignment_test , only : & assignment_assignment => test_assignment use char_test , only : & char_char => test_char use concat_test , only : & concat_concat => test_concat use equal_test , only : & equal_equals => test_equals use extract_test , only : & extract_extract_character => test_extract_character , & extract_extract_string => test_extract_string use greater_than_equal_test , only : & greater_than_equal_greater_than_equals => test_greater_than_equals use greater_than_test , only : & greater_than_greater_than => test_greater_than use iachar_test , only : & iachar_iachar => test_iachar use ichar_test , only : & ichar_ichar => test_ichar use index_test , only : & index_index => test_index use insert_test , only : & insert_insert_character_into_character => test_insert_character_into_character , & insert_insert_character_into_string => test_insert_character_into_string , & insert_insert_string_into_character => test_insert_string_into_character , & insert_insert_string_into_string => test_insert_string_into_string use len_test , only : & len_len => test_len use len_trim_test , only : & len_trim_len_trim => test_len_trim use less_than_equal_test , only : & less_than_equal_less_than_equals => test_less_than_equals use less_than_test , only : & less_than_less_than => test_less_than use lge_test , only : & lge_lge => test_lge use lgt_test , only : & lgt_lgt => test_lgt use lle_test , only : & lle_lle => test_lle use llt_test , only : & llt_llt => test_llt use not_equal_test , only : & not_equal_not_equals => test_not_equals use remove_test , only : & remove_remove_character => test_remove_character , & remove_remove_string => test_remove_string use repeat_test , only : & repeat_repeat => test_repeat use replace_range_test , only : & replace_range_replace_character_in_character_range => test_replace_character_in_character_range , & replace_range_replace_character_in_string_range => test_replace_character_in_string_range , & replace_range_replace_string_in_character_range => test_replace_string_in_character_range , & replace_range_replace_string_in_string_range => test_replace_string_in_string_range use replace_start_test , only : & replace_start_replace_character_in_character_start => test_replace_character_in_character_start , & replace_start_replace_character_in_string_start => test_replace_character_in_string_start , & replace_start_replace_string_in_character_start => test_replace_string_in_character_start , & replace_start_replace_string_in_string_start => test_replace_string_in_string_start use replace_target_test , only : & replace_target_replace_character_with_character_in_character => & test_replace_character_with_character_in_character , & replace_target_replace_character_with_character_in_string => & test_replace_character_with_character_in_string , & replace_target_replace_character_with_string_in_character => & test_replace_character_with_string_in_character , & replace_target_replace_character_with_string_in_string => & test_replace_character_with_string_in_string , & replace_target_replace_string_with_character_in_character => & test_replace_string_with_character_in_character , & replace_target_replace_string_with_character_in_string => & test_replace_string_with_character_in_string , & replace_target_replace_string_with_string_in_character => & test_replace_string_with_string_in_character , & replace_target_replace_string_with_string_in_string => & test_replace_string_with_string_in_string use scan_test , only : & scan_scan => test_scan use split_character_set_test , only : & split_character_set_split_character => test_split_character use split_string_set_test , only : & split_string_set_split_character => test_split_character use trim_test , only : & trim_trim => test_trim use var_str_test , only : & var_str_var_str => test_var_str use verify_test , only : & verify_verify => test_verify use vegetables , only : test_item_t , test_that , run_tests type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 51 ) individual_tests ( 1 ) = adjustl_adjustl () individual_tests ( 2 ) = adjustr_adjustr () individual_tests ( 3 ) = assignment_assignment () individual_tests ( 4 ) = char_char () individual_tests ( 5 ) = concat_concat () individual_tests ( 6 ) = equal_equals () individual_tests ( 7 ) = extract_extract_character () individual_tests ( 8 ) = extract_extract_string () individual_tests ( 9 ) = greater_than_equal_greater_than_equals () individual_tests ( 10 ) = greater_than_greater_than () individual_tests ( 11 ) = iachar_iachar () individual_tests ( 12 ) = ichar_ichar () individual_tests ( 13 ) = index_index () individual_tests ( 14 ) = insert_insert_character_into_character () individual_tests ( 15 ) = insert_insert_character_into_string () individual_tests ( 16 ) = insert_insert_string_into_character () individual_tests ( 17 ) = insert_insert_string_into_string () individual_tests ( 18 ) = len_len () individual_tests ( 19 ) = len_trim_len_trim () individual_tests ( 20 ) = less_than_equal_less_than_equals () individual_tests ( 21 ) = less_than_less_than () individual_tests ( 22 ) = lge_lge () individual_tests ( 23 ) = lgt_lgt () individual_tests ( 24 ) = lle_lle () individual_tests ( 25 ) = llt_llt () individual_tests ( 26 ) = not_equal_not_equals () individual_tests ( 27 ) = remove_remove_character () individual_tests ( 28 ) = remove_remove_string () individual_tests ( 29 ) = repeat_repeat () individual_tests ( 30 ) = replace_range_replace_character_in_character_range () individual_tests ( 31 ) = replace_range_replace_character_in_string_range () individual_tests ( 32 ) = replace_range_replace_string_in_character_range () individual_tests ( 33 ) = replace_range_replace_string_in_string_range () individual_tests ( 34 ) = replace_start_replace_character_in_character_start () individual_tests ( 35 ) = replace_start_replace_character_in_string_start () individual_tests ( 36 ) = replace_start_replace_string_in_character_start () individual_tests ( 37 ) = replace_start_replace_string_in_string_start () individual_tests ( 38 ) = replace_target_replace_character_with_character_in_character () individual_tests ( 39 ) = replace_target_replace_character_with_character_in_string () individual_tests ( 40 ) = replace_target_replace_character_with_string_in_character () individual_tests ( 41 ) = replace_target_replace_character_with_string_in_string () individual_tests ( 42 ) = replace_target_replace_string_with_character_in_character () individual_tests ( 43 ) = replace_target_replace_string_with_character_in_string () individual_tests ( 44 ) = replace_target_replace_string_with_string_in_character () individual_tests ( 45 ) = replace_target_replace_string_with_string_in_string () individual_tests ( 46 ) = scan_scan () individual_tests ( 47 ) = split_character_set_split_character () individual_tests ( 48 ) = split_string_set_split_character () individual_tests ( 49 ) = trim_trim () individual_tests ( 50 ) = var_str_var_str () individual_tests ( 51 ) = verify_verify () tests = test_that ( individual_tests ) call run_tests ( tests ) end subroutine end program","tags":"","loc":"sourcefile/main.f90~4.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Modules repeat_test Source Code repeat_test.f90 Source Code module repeat_test implicit none private public :: test_repeat contains function test_repeat () result ( tests ) use custom_generator , only : ASCII_STRING_AND_INTEGER_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 1 ) individual_tests ( 1 ) = it ( & \"works the same for characters and strings\" , & ASCII_STRING_AND_INTEGER_GENERATOR , & check_repeat ) tests = describe ( & \"Sec. 3.4.13: REPEAT\" , individual_tests ) end function pure function check_repeat ( example ) result ( result_ ) use custom_generator , only : string_and_integer_input_t use iso_varying_string , only : char , repeat use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example type ( result_t ) :: result_ select type ( example ) type is ( string_and_integer_input_t ) result_ = assert_equals ( & repeat ( char ( example % string ), example % integer_ ), & repeat ( example % string , example % integer_ )) class default result_ = fail ( \"Expected to get a string_and_integer_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/repeat_test.f90~2.html","title":"repeat_test.f90 – miniFAVOR"},{"text":"Contents Modules extract_test Source Code extract_test.f90 Source Code module extract_test implicit none private public :: test_extract_character , test_extract_string contains function test_extract_character () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 6 ) individual_tests ( 1 ) = it ( & \"The result value is a copy of the characters of the argument\" & // \" string between positions start and finish, inclusive.\" , & check_extract_character ) individual_tests ( 2 ) = it ( & \"If start is absent, the value one is used for start.\" , & check_extract_character_without_start ) individual_tests ( 3 ) = it ( & \"If start is less than one, the value one is used for start.\" , & check_extract_character_with_start_lt_one ) individual_tests ( 4 ) = it ( & \"If finish is absent, the value LEN(string) is used for finish.\" , & check_extract_character_without_finish ) individual_tests ( 5 ) = it ( & \"If finish is greater than LEN(string), the value LEN(string) is used for finish.\" , & check_extract_character_with_finish_gt_len_string ) individual_tests ( 6 ) = it ( & \"If finish is less than start, the result is a zero-length string.\" , & check_extract_character_zero_length ) tests = describe ( \"Sec. 3.7.1 EXTRACT character\" , individual_tests ) end function function test_extract_string () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 6 ) individual_tests ( 1 ) = it ( & \"The result value is a copy of the characters of the argument\" & // \" string between positions start and finish, inclusive.\" , & check_extract_string ) individual_tests ( 2 ) = it ( & \"If start is absent, the value one is used for start.\" , & check_extract_string_without_start ) individual_tests ( 3 ) = it ( & \"If start is less than one, the value one is used for start.\" , & check_extract_string_with_start_lt_one ) individual_tests ( 4 ) = it ( & \"If finish is absent, the value LEN(string) is used for finish.\" , & check_extract_string_without_finish ) individual_tests ( 5 ) = it ( & \"If finish is greater than LEN(string), the value LEN(string) is used for finish.\" , & check_extract_string_with_finish_gt_len_string ) individual_tests ( 6 ) = it ( & \"If finish is less than start, the result is a zero-length string.\" , & check_extract_string_zero_length ) tests = describe ( \"Sec. 3.7.1 EXTRACT string\" , individual_tests ) end function pure function check_extract_character () result ( result_ ) use iso_varying_string , only : extract use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: example = \"EXAMPLE\" result_ = assert_equals ( example ( 2 : 4 ), extract ( example , 2 , 4 )) end function pure function check_extract_character_without_start () result ( result_ ) use iso_varying_string , only : extract use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: example = \"EXAMPLE\" result_ = assert_equals ( example ( 1 : 4 ), extract ( example , finish = 4 )) end function pure function check_extract_character_with_start_lt_one () result ( result_ ) use iso_varying_string , only : extract use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: example = \"EXAMPLE\" result_ = assert_equals ( example ( 1 : 4 ), extract ( example , - 1 , 4 )) end function pure function check_extract_character_without_finish () result ( result_ ) use iso_varying_string , only : extract use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: example = \"EXAMPLE\" result_ = assert_equals ( example ( 2 :), extract ( example , 2 )) end function pure function check_extract_character_with_finish_gt_len_string () result ( result_ ) use iso_varying_string , only : extract use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: example = \"EXAMPLE\" result_ = assert_equals ( example ( 2 :), extract ( example , 2 , len ( example ) + 1 )) end function pure function check_extract_character_zero_length () result ( result_ ) use iso_varying_string , only : extract use vegetables , only : result_t , assert_empty type ( result_t ) :: result_ character ( len =* ), parameter :: example = \"EXAMPLE\" result_ = assert_empty ( extract ( example , 10 , - 2 )) end function pure function check_extract_string () result ( result_ ) use iso_varying_string , only : extract , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: example = \"EXAMPLE\" result_ = assert_equals ( example ( 2 : 4 ), extract ( var_str ( example ), 2 , 4 )) end function pure function check_extract_string_without_start () result ( result_ ) use iso_varying_string , only : extract , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: example = \"EXAMPLE\" result_ = assert_equals ( example ( 1 : 4 ), extract ( var_str ( example ), finish = 4 )) end function pure function check_extract_string_with_start_lt_one () result ( result_ ) use iso_varying_string , only : extract , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: example = \"EXAMPLE\" result_ = assert_equals ( example ( 1 : 4 ), extract ( var_str ( example ), - 1 , 4 )) end function pure function check_extract_string_without_finish () result ( result_ ) use iso_varying_string , only : extract , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: example = \"EXAMPLE\" result_ = assert_equals ( example ( 2 :), extract ( var_str ( example ), 2 )) end function pure function check_extract_string_with_finish_gt_len_string () result ( result_ ) use iso_varying_string , only : extract , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: example = \"EXAMPLE\" result_ = assert_equals ( example ( 2 :), extract ( var_str ( example ), 2 , len ( example ) + 1 )) end function pure function check_extract_string_zero_length () result ( result_ ) use iso_varying_string , only : extract , var_str use vegetables , only : result_t , assert_empty type ( result_t ) :: result_ character ( len =* ), parameter :: example = \"EXAMPLE\" result_ = assert_empty ( extract ( var_str ( example ), 10 , - 2 )) end function end module","tags":"","loc":"sourcefile/extract_test.f90.html","title":"extract_test.f90 – miniFAVOR"},{"text":"Contents Modules len_test Source Code len_test.f90 Source Code module len_test implicit none private public :: test_len contains function test_len () result ( tests ) use vegetables , only : test_item_t , describe , it , ASCII_STRING_GENERATOR type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 1 ) individual_tests = it ( & \"works the same for characters and strings\" , & ASCII_STRING_GENERATOR , & check_len ) tests = describe ( \"Sec 3.4.7: LEN\" , individual_tests ) end function pure function check_len ( string ) result ( result_ ) use iso_varying_string , only : char , len use vegetables , only : & input_t , result_t , string_input_t , assert_equals , fail class ( input_t ), intent ( in ) :: string type ( result_t ) :: result_ select type ( string ) type is ( string_input_t ) result_ = assert_equals ( & len ( char ( string % value_ )), & len ( string % value_ ), & string % value_ ) class default result_ = fail ( \"Expected to get a string_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/len_test.f90.html","title":"len_test.f90 – miniFAVOR"},{"text":"Contents Modules replace_start_test Source Code replace_start_test.f90 Source Code module replace_start_test implicit none private public :: & test_replace_character_in_character_start , & test_replace_character_in_string_start , & test_replace_string_in_character_start , & test_replace_string_in_string_start contains function test_replace_character_in_character_start () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 4 ) individual_tests ( 1 ) = it ( & \"The characters of substring are inserted into a copy of string\" & // \" at the position start, and the characters in postions from\" & // \" start to min(start+len(substring)-1, len(string)) are deleted.\" , & check_replace_character_in_character ) individual_tests ( 2 ) = it ( & \"If start is greater than len(string), the substring is appended to the copy of string.\" , & check_replace_character_in_character_after ) individual_tests ( 3 ) = it ( & \"If start is less than one, the value one is used for start\" , & check_replace_character_in_character_before ) individual_tests ( 4 ) = it ( & \"If substring runs off the end, the resulting string is longer?\" , & check_replace_character_in_character_overrun ) tests = describe ( \"Sec. 3.7.4: REPLACE in character with character at start\" , individual_tests ) end function function test_replace_character_in_string_start () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 4 ) individual_tests ( 1 ) = it ( & \"The characters of substring are inserted into a copy of string\" & // \" at the position start, and the characters in postions from\" & // \" start to min(start+len(substring)-1, len(string)) are deleted.\" , & check_replace_character_in_string ) individual_tests ( 2 ) = it ( & \"If start is greater than len(string), the substring is appended to the copy of string.\" , & check_replace_character_in_string_after ) individual_tests ( 3 ) = it ( & \"If start is less than one, the value one is used for start\" , & check_replace_character_in_string_before ) individual_tests ( 4 ) = it ( & \"If substring runs off the end, the resulting string is longer?\" , & check_replace_character_in_string_overrun ) tests = describe ( \"Sec. 3.7.4: REPLACE in string with character at start\" , individual_tests ) end function function test_replace_string_in_character_start () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 4 ) individual_tests ( 1 ) = it ( & \"The characters of substring are inserted into a copy of string\" & // \" at the position start, and the characters in postions from\" & // \" start to min(start+len(substring)-1, len(string)) are deleted.\" , & check_replace_string_in_character ) individual_tests ( 2 ) = it ( & \"If start is greater than len(string), the substring is appended to the copy of string.\" , & check_replace_string_in_character_after ) individual_tests ( 3 ) = it ( & \"If start is less than one, the value one is used for start\" , & check_replace_string_in_character_before ) individual_tests ( 4 ) = it ( & \"If substring runs off the end, the resulting string is longer?\" , & check_replace_string_in_character_overrun ) tests = describe ( \"Sec. 3.7.4: REPLACE in character with string at start\" , individual_tests ) end function function test_replace_string_in_string_start () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 4 ) individual_tests ( 1 ) = it ( & \"The characters of substring are inserted into a copy of string\" & // \" at the position start, and the characters in postions from\" & // \" start to min(start+len(substring)-1, len(string)) are deleted.\" , & check_replace_string_in_string ) individual_tests ( 2 ) = it ( & \"If start is greater than len(string), the substring is appended to the copy of string.\" , & check_replace_string_in_string_after ) individual_tests ( 3 ) = it ( & \"If start is less than one, the value one is used for start\" , & check_replace_string_in_string_before ) individual_tests ( 4 ) = it ( & \"If substring runs off the end, the resulting string is longer?\" , & check_replace_string_in_string_overrun ) tests = describe ( \"Sec. 3.7.4: REPLACE in string with string at start\" , individual_tests ) end function pure function check_replace_character_in_character () result ( result_ ) use iso_varying_string , only : replace use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"SOMETHRING\" , replace ( \"SOMESTRING\" , 5 , \"TH\" )) end function pure function check_replace_character_in_character_after () result ( result_ ) use iso_varying_string , only : replace use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"SOMETHINGELSE\" , replace ( \"SOMETHING\" , 10 , \"ELSE\" )) end function pure function check_replace_character_in_character_before () result ( result_ ) use iso_varying_string , only : replace use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"ELSETHING\" , replace ( \"SOMETHING\" , - 1 , \"ELSE\" )) end function pure function check_replace_character_in_character_overrun () result ( result_ ) use iso_varying_string , only : replace use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"OVERRUN\" , replace ( \"OVERT\" , 5 , \"RUN\" )) end function pure function check_replace_character_in_string () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"SOMETHRING\" , replace ( var_str ( \"SOMESTRING\" ), 5 , \"TH\" )) end function pure function check_replace_character_in_string_after () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"SOMETHINGELSE\" , replace ( var_str ( \"SOMETHING\" ), 10 , \"ELSE\" )) end function pure function check_replace_character_in_string_before () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"ELSETHING\" , replace ( var_str ( \"SOMETHING\" ), - 1 , \"ELSE\" )) end function pure function check_replace_character_in_string_overrun () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"OVERRUN\" , replace ( var_str ( \"OVERT\" ), 5 , \"RUN\" )) end function pure function check_replace_string_in_character () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"SOMETHRING\" , replace ( \"SOMESTRING\" , 5 , var_str ( \"TH\" ))) end function pure function check_replace_string_in_character_after () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"SOMETHINGELSE\" , replace ( \"SOMETHING\" , 10 , var_str ( \"ELSE\" ))) end function pure function check_replace_string_in_character_before () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"ELSETHING\" , replace ( \"SOMETHING\" , - 1 , var_str ( \"ELSE\" ))) end function pure function check_replace_string_in_character_overrun () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"OVERRUN\" , replace ( \"OVERT\" , 5 , var_str ( \"RUN\" ))) end function pure function check_replace_string_in_string () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"SOMETHRING\" , replace ( var_str ( \"SOMESTRING\" ), 5 , var_str ( \"TH\" ))) end function pure function check_replace_string_in_string_after () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"SOMETHINGELSE\" , replace ( var_str ( \"SOMETHING\" ), 10 , var_str ( \"ELSE\" ))) end function pure function check_replace_string_in_string_before () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"ELSETHING\" , replace ( var_str ( \"SOMETHING\" ), - 1 , var_str ( \"ELSE\" ))) end function pure function check_replace_string_in_string_overrun () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"OVERRUN\" , replace ( var_str ( \"OVERT\" ), 5 , var_str ( \"RUN\" ))) end function end module","tags":"","loc":"sourcefile/replace_start_test.f90.html","title":"replace_start_test.f90 – miniFAVOR"},{"text":"Contents Modules replace_target_test Source Code replace_target_test.f90 Source Code module replace_target_test implicit none private public :: & test_replace_character_with_character_in_character , & test_replace_character_with_character_in_string , & test_replace_character_with_string_in_character , & test_replace_character_with_string_in_string , & test_replace_string_with_character_in_character , & test_replace_string_with_character_in_string , & test_replace_string_with_string_in_character , & test_replace_string_with_string_in_string contains function test_replace_character_with_character_in_character () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"The copy of string is searched for occurences of target. If\" & // \" target is found, it is replaced by substring.\" , & check_replace_character_with_character_in_character ) individual_tests ( 2 ) = it ( & \"The search is done in the backward direction if the argument\" & // \" back is present with the value true.\" , & check_replace_character_with_character_in_character_backward ) individual_tests ( 3 ) = it ( & \"If every is present with the value true, the search and replace\" & // \" is continued from the character following target in the\" & // \" search direction specified until all occurrences of\" & // \" target in the copy string are replaced.\" , & check_replace_character_with_character_in_character_every ) tests = describe ( & \"Sec. 3.7.4: REPLACE target character with character in character\" , & individual_tests ) end function function test_replace_character_with_character_in_string () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"The copy of string is searched for occurences of target. If\" & // \" target is found, it is replaced by substring.\" , & check_replace_character_with_character_in_string ) individual_tests ( 2 ) = it ( & \"The search is done in the backward direction if the argument\" & // \" back is present with the value true.\" , & check_replace_character_with_character_in_string_backward ) individual_tests ( 3 ) = it ( & \"If every is present with the value true, the search and replace\" & // \" is continued from the character following target in the\" & // \" search direction specified until all occurrences of\" & // \" target in the copy string are replaced.\" , & check_replace_character_with_character_in_string_every ) tests = describe ( & \"Sec. 3.7.4: REPLACE target character with character in string\" , & individual_tests ) end function function test_replace_character_with_string_in_character () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"The copy of string is searched for occurences of target. If\" & // \" target is found, it is replaced by substring.\" , & check_replace_character_with_string_in_character ) individual_tests ( 2 ) = it ( & \"The search is done in the backward direction if the argument\" & // \" back is present with the value true.\" , & check_replace_character_with_string_in_character_backward ) individual_tests ( 3 ) = it ( & \"If every is present with the value true, the search and replace\" & // \" is continued from the character following target in the\" & // \" search direction specified until all occurrences of\" & // \" target in the copy string are replaced.\" , & check_replace_character_with_string_in_character_every ) tests = describe ( & \"Sec. 3.7.4: REPLACE target character with string in character\" , & individual_tests ) end function function test_replace_character_with_string_in_string () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"The copy of string is searched for occurences of target. If\" & // \" target is found, it is replaced by substring.\" , & check_replace_character_with_string_in_string ) individual_tests ( 2 ) = it ( & \"The search is done in the backward direction if the argument\" & // \" back is present with the value true.\" , & check_replace_character_with_string_in_string_backward ) individual_tests ( 3 ) = it ( & \"If every is present with the value true, the search and replace\" & // \" is continued from the character following target in the\" & // \" search direction specified until all occurrences of\" & // \" target in the copy string are replaced.\" , & check_replace_character_with_string_in_string_every ) tests = describe ( & \"Sec. 3.7.4: REPLACE target character with string in string\" , & individual_tests ) end function function test_replace_string_with_character_in_character () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"The copy of string is searched for occurences of target. If\" & // \" target is found, it is replaced by substring.\" , & check_replace_string_with_character_in_character ) individual_tests ( 2 ) = it ( & \"The search is done in the backward direction if the argument\" & // \" back is present with the value true.\" , & check_replace_string_with_character_in_character_backward ) individual_tests ( 3 ) = it ( & \"If every is present with the value true, the search and replace\" & // \" is continued from the character following target in the\" & // \" search direction specified until all occurrences of\" & // \" target in the copy string are replaced.\" , & check_replace_string_with_character_in_character_every ) tests = describe ( & \"Sec. 3.7.4: REPLACE target string with character in character\" , & individual_tests ) end function function test_replace_string_with_character_in_string () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"The copy of string is searched for occurences of target. If\" & // \" target is found, it is replaced by substring.\" , & check_replace_string_with_character_in_string ) individual_tests ( 2 ) = it ( & \"The search is done in the backward direction if the argument\" & // \" back is present with the value true.\" , & check_replace_string_with_character_in_string_backward ) individual_tests ( 3 ) = it ( & \"If every is present with the value true, the search and replace\" & // \" is continued from the character following target in the\" & // \" search direction specified until all occurrences of\" & // \" target in the copy string are replaced.\" , & check_replace_string_with_character_in_string_every ) tests = describe ( & \"Sec. 3.7.4: REPLACE target string with character in string\" , & individual_tests ) end function function test_replace_string_with_string_in_character () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"The copy of string is searched for occurences of target. If\" & // \" target is found, it is replaced by substring.\" , & check_replace_string_with_string_in_character ) individual_tests ( 2 ) = it ( & \"The search is done in the backward direction if the argument\" & // \" back is present with the value true.\" , & check_replace_string_with_string_in_character_backward ) individual_tests ( 3 ) = it ( & \"If every is present with the value true, the search and replace\" & // \" is continued from the character following target in the\" & // \" search direction specified until all occurrences of\" & // \" target in the copy string are replaced.\" , & check_replace_string_with_string_in_character_every ) tests = describe ( & \"Sec. 3.7.4: REPLACE target string with string in character\" , & individual_tests ) end function function test_replace_string_with_string_in_string () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"The copy of string is searched for occurences of target. If\" & // \" target is found, it is replaced by substring.\" , & check_replace_string_with_string_in_string ) individual_tests ( 2 ) = it ( & \"The search is done in the backward direction if the argument\" & // \" back is present with the value true.\" , & check_replace_string_with_string_in_string_backward ) individual_tests ( 3 ) = it ( & \"If every is present with the value true, the search and replace\" & // \" is continued from the character following target in the\" & // \" search direction specified until all occurrences of\" & // \" target in the copy string are replaced.\" , & check_replace_string_with_string_in_string_every ) tests = describe ( & \"Sec. 3.7.4: REPLACE target string with string in string\" , & individual_tests ) end function pure function check_replace_character_with_character_in_character () result ( result_ ) use iso_varying_string , only : replace use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"with this in this string\" , & replace ( & \"this in this string\" , & \"this\" , & \"with this\" )) end function pure function check_replace_character_with_character_in_character_backward () result ( result_ ) use iso_varying_string , only : replace use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"this in with this string\" , & replace (& \"this in this string\" , & \"this\" , & \"with this\" , & back = . TRUE .)) end function pure function check_replace_character_with_character_in_character_every () result ( result_ ) use iso_varying_string , only : replace use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( & \"with this in with this string\" , & replace (& \"this in this string\" , & \"this\" , & \"with this\" , & every = . TRUE .)) & . and . assert_equals ( & \"with this in with this string\" , & replace ( & \"this in this string\" , & \"this\" , & \"with this\" , & every = . TRUE ., & back = . TRUE .)) end function pure function check_replace_character_with_character_in_string () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"with this in this string\" , & replace ( & var_str ( \"this in this string\" ), & \"this\" , & \"with this\" )) end function pure function check_replace_character_with_character_in_string_backward () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"this in with this string\" , & replace (& var_str ( \"this in this string\" ), & \"this\" , & \"with this\" , & back = . TRUE .)) end function pure function check_replace_character_with_character_in_string_every () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( & \"with this in with this string\" , & replace (& var_str ( \"this in this string\" ), & \"this\" , & \"with this\" , & every = . TRUE .)) & . and . assert_equals ( & \"with this in with this string\" , & replace ( & var_str ( \"this in this string\" ), & \"this\" , & \"with this\" , & every = . TRUE ., & back = . TRUE .)) end function pure function check_replace_character_with_string_in_character () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"with this in this string\" , & replace ( & \"this in this string\" , & \"this\" , & var_str ( \"with this\" ))) end function pure function check_replace_character_with_string_in_character_backward () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"this in with this string\" , & replace (& \"this in this string\" , & \"this\" , & var_str ( \"with this\" ), & back = . TRUE .)) end function pure function check_replace_character_with_string_in_character_every () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( & \"with this in with this string\" , & replace (& \"this in this string\" , & \"this\" , & var_str ( \"with this\" ), & every = . TRUE .)) & . and . assert_equals ( & \"with this in with this string\" , & replace ( & \"this in this string\" , & \"this\" , & var_str ( \"with this\" ), & every = . TRUE ., & back = . TRUE .)) end function pure function check_replace_character_with_string_in_string () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"with this in this string\" , & replace ( & var_str ( \"this in this string\" ), & \"this\" , & var_str ( \"with this\" ))) end function pure function check_replace_character_with_string_in_string_backward () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"this in with this string\" , & replace (& var_str ( \"this in this string\" ), & \"this\" , & var_str ( \"with this\" ), & back = . TRUE .)) end function pure function check_replace_character_with_string_in_string_every () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( & \"with this in with this string\" , & replace (& var_str ( \"this in this string\" ), & \"this\" , & var_str ( \"with this\" ), & every = . TRUE .)) & . and . assert_equals ( & \"with this in with this string\" , & replace ( & var_str ( \"this in this string\" ), & \"this\" , & var_str ( \"with this\" ), & every = . TRUE ., & back = . TRUE .)) end function pure function check_replace_string_with_character_in_character () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"with this in this string\" , & replace ( & \"this in this string\" , & var_str ( \"this\" ), & \"with this\" )) end function pure function check_replace_string_with_character_in_character_backward () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"this in with this string\" , & replace (& \"this in this string\" , & var_str ( \"this\" ), & \"with this\" , & back = . TRUE .)) end function pure function check_replace_string_with_character_in_character_every () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( & \"with this in with this string\" , & replace (& \"this in this string\" , & var_str ( \"this\" ), & \"with this\" , & every = . TRUE .)) & . and . assert_equals ( & \"with this in with this string\" , & replace ( & \"this in this string\" , & var_str ( \"this\" ), & \"with this\" , & every = . TRUE ., & back = . TRUE .)) end function pure function check_replace_string_with_character_in_string () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"with this in this string\" , & replace ( & var_str ( \"this in this string\" ), & var_str ( \"this\" ), & \"with this\" )) end function pure function check_replace_string_with_character_in_string_backward () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"this in with this string\" , & replace (& var_str ( \"this in this string\" ), & var_str ( \"this\" ), & \"with this\" , & back = . TRUE .)) end function pure function check_replace_string_with_character_in_string_every () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( & \"with this in with this string\" , & replace (& var_str ( \"this in this string\" ), & var_str ( \"this\" ), & \"with this\" , & every = . TRUE .)) & . and . assert_equals ( & \"with this in with this string\" , & replace ( & var_str ( \"this in this string\" ), & var_str ( \"this\" ), & \"with this\" , & every = . TRUE ., & back = . TRUE .)) end function pure function check_replace_string_with_string_in_character () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"with this in this string\" , & replace ( & \"this in this string\" , & var_str ( \"this\" ), & var_str ( \"with this\" ))) end function pure function check_replace_string_with_string_in_character_backward () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"this in with this string\" , & replace (& \"this in this string\" , & var_str ( \"this\" ), & var_str ( \"with this\" ), & back = . TRUE .)) end function pure function check_replace_string_with_string_in_character_every () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( & \"with this in with this string\" , & replace (& \"this in this string\" , & var_str ( \"this\" ), & var_str ( \"with this\" ), & every = . TRUE .)) & . and . assert_equals ( & \"with this in with this string\" , & replace ( & \"this in this string\" , & var_str ( \"this\" ), & var_str ( \"with this\" ), & every = . TRUE ., & back = . TRUE .)) end function pure function check_replace_string_with_string_in_string () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"with this in this string\" , & replace ( & var_str ( \"this in this string\" ), & var_str ( \"this\" ), & var_str ( \"with this\" ))) end function pure function check_replace_string_with_string_in_string_backward () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"this in with this string\" , & replace (& var_str ( \"this in this string\" ), & var_str ( \"this\" ), & var_str ( \"with this\" ), & back = . TRUE .)) end function pure function check_replace_string_with_string_in_string_every () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( & \"with this in with this string\" , & replace (& var_str ( \"this in this string\" ), & var_str ( \"this\" ), & var_str ( \"with this\" ), & every = . TRUE .)) & . and . assert_equals ( & \"with this in with this string\" , & replace ( & var_str ( \"this in this string\" ), & var_str ( \"this\" ), & var_str ( \"with this\" ), & every = . TRUE ., & back = . TRUE .)) end function end module","tags":"","loc":"sourcefile/replace_target_test.f90.html","title":"replace_target_test.f90 – miniFAVOR"},{"text":"Contents Modules greater_than_equal_test Source Code greater_than_equal_test.f90 Source Code module greater_than_equal_test implicit none private public :: test_greater_than_equals contains function test_greater_than_equals () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_greater_than_equal_string ) individual_tests ( 2 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_character_greater_than_equal_string ) individual_tests ( 3 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_greater_than_equal_character ) tests = describe ( & \"Sec. 3.3.3: operator(>=) functions the same as for two characters for\" , & individual_tests ) end function pure function check_string_greater_than_equal_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( >= ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) >= char ( strings % second ) & . eqv . strings % first >= strings % second , & '\"' // strings % first // '\" >= \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_character_greater_than_equal_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( >= ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) >= char ( strings % second ) & . eqv . char ( strings % first ) >= strings % second , & '\"' // strings % first // '\" >= \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_string_greater_than_equal_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( >= ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) >= char ( strings % second ) & . eqv . strings % first >= char ( strings % second ), & '\"' // strings % first // '\" >= \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/greater_than_equal_test.f90.html","title":"greater_than_equal_test.f90 – miniFAVOR"},{"text":"Contents Modules greater_than_test Source Code greater_than_test.f90 Source Code module greater_than_test implicit none private public :: test_greater_than contains function test_greater_than () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_greater_than_string ) individual_tests ( 2 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_character_greater_than_string ) individual_tests ( 3 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_greater_than_character ) tests = describe ( & \"Sec. 3.3.3: operator(>) functions the same as for two characters for\" , & individual_tests ) end function pure function check_string_greater_than_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( > ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) > char ( strings % second ) & . eqv . strings % first > strings % second , & '\"' // strings % first // '\" > \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_character_greater_than_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( > ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) > char ( strings % second ) & . eqv . char ( strings % first ) > strings % second , & '\"' // strings % first // '\" > \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_string_greater_than_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( > ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) > char ( strings % second ) & . eqv . strings % first > char ( strings % second ), & '\"' // strings % first // '\" > \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/greater_than_test.f90.html","title":"greater_than_test.f90 – miniFAVOR"},{"text":"Contents Modules concat_test Source Code concat_test.f90 Source Code module concat_test implicit none private public :: test_concat contains function test_concat () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_concat_strings ) individual_tests ( 2 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_concat_string_and_character ) individual_tests ( 3 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_concat_character_and_string ) tests = describe ( & \"Sec. 3.3.2: operator(//) functions the same as for two characters for\" , & individual_tests ) end function test_concat pure function check_concat_strings ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_equals ( & char ( strings % first ) // char ( strings % second ), & strings % first // strings % second ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_concat_string_and_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_equals ( & char ( strings % first ) // char ( strings % second ), & strings % first // char ( strings % second )) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_concat_character_and_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_equals ( & char ( strings % first ) // char ( strings % second ), & char ( strings % first ) // strings % second ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/concat_test.f90.html","title":"concat_test.f90 – miniFAVOR"},{"text":"Contents Modules trim_test Source Code trim_test.f90 Source Code module trim_test implicit none private public :: test_trim contains function test_trim () result ( tests ) use vegetables , only : test_item_t , describe , it , ASCII_STRING_GENERATOR type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 1 ) individual_tests = It ( & \"works the same for characters and strings\" , & ASCII_STRING_GENERATOR , & check_trim ) tests = Describe ( \"Sec 3.4.15: TRIM\" , individual_tests ) end function pure function check_trim ( string ) result ( result_ ) use iso_varying_string , only : char , trim use vegetables , only : & input_t , result_t , string_input_t , assert_equals , fail class ( input_t ), intent ( in ) :: string type ( result_t ) :: result_ select type ( string ) type is ( string_input_t ) result_ = assert_equals ( & trim ( char ( string % value_ )), & trim ( string % value_ )) class default result_ = fail ( \"Expected to get a string_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/trim_test.f90.html","title":"trim_test.f90 – miniFAVOR"},{"text":"Contents Modules len_trim_test Source Code len_trim_test.f90 Source Code module len_trim_test implicit none private public :: test_len_trim contains function test_len_trim () result ( tests ) use vegetables , only : test_item_t , describe , it , ASCII_STRING_GENERATOR type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 1 ) individual_tests = it ( & \"works the same for characters and strings\" , & ASCII_STRING_GENERATOR , & check_len_trim ) tests = describe ( \"Sec 3.4.8: LEN_TRIM\" , individual_tests ) end function pure function check_len_trim ( string ) result ( result_ ) use iso_varying_string , only : char , len_trim use vegetables , only : & input_t , result_t , string_input_t , assert_equals , fail class ( input_t ), intent ( in ) :: string type ( result_t ) :: result_ select type ( string ) type is ( string_input_t ) result_ = assert_equals ( & len_trim ( char ( string % value_ )), & len_trim ( string % value_ ), & string % value_ ) class default result_ = fail ( \"Expected to get a string_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/len_trim_test.f90.html","title":"len_trim_test.f90 – miniFAVOR"},{"text":"Contents Modules insert_test Source Code insert_test.f90 Source Code module insert_test implicit none private public :: & test_insert_character_into_character , & test_insert_character_into_string , & test_insert_string_into_character , & test_insert_string_into_string contains function test_insert_character_into_character () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"The result value is a copy of the characters of the argument\" & // \" string with the characters of substring inserted into the\" & // \" copy of string before the character at the position start.\" , & check_insert_character_into_character ) individual_tests ( 2 ) = it ( & \"If start is greater than LEN(string), then substring is appended to the copy of string\" , & check_insert_character_into_character_at_end ) individual_tests ( 3 ) = it ( & \"If start is less than one, then substring is prepended to the copy of string\" , & check_insert_character_into_character_at_beginning ) tests = describe ( \"Sec. 3.7.2: INSERT character into character\" , individual_tests ) end function function test_insert_character_into_string () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"The result value is a copy of the characters of the argument\" & // \" string with the characters of substring inserted into the\" & // \" copy of string before the character at the position start.\" , & check_insert_character_into_string ) individual_tests ( 2 ) = it ( & \"If start is greater than LEN(string), then substring is appended to the copy of string\" , & check_insert_character_into_string_at_end ) individual_tests ( 3 ) = it ( & \"If start is less than one, then substring is prepended to the copy of string\" , & check_insert_character_into_string_at_beginning ) tests = describe ( \"Sec. 3.7.2: INSERT character into string\" , individual_tests ) end function function test_insert_string_into_character () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"The result value is a copy of the characters of the argument\" & // \" string with the characters of substring inserted into the\" & // \" copy of string before the character at the position start.\" , & check_insert_string_into_character ) individual_tests ( 2 ) = it ( & \"If start is greater than LEN(string), then substring is appended to the copy of string\" , & check_insert_string_into_character_at_end ) individual_tests ( 3 ) = it ( & \"If start is less than one, then substring is prepended to the copy of string\" , & check_insert_string_into_character_at_beginning ) tests = describe ( \"Sec. 3.7.2: INSERT string into character\" , individual_tests ) end function function test_insert_string_into_string () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"The result value is a copy of the characters of the argument\" & // \" string with the characters of substring inserted into the\" & // \" copy of string before the character at the position start.\" , & check_insert_string_into_string ) individual_tests ( 2 ) = it ( & \"If start is greater than LEN(string), then substring is appended to the copy of string\" , & check_insert_string_into_string_at_end ) individual_tests ( 3 ) = it ( & \"If start is less than one, then substring is prepended to the copy of string\" , & check_insert_string_into_string_at_beginning ) tests = describe ( \"Sec. 3.7.2: INSERT string into string\" , individual_tests ) end function pure function check_insert_character_into_character () result ( result_ ) use iso_varying_string , only : insert use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: string = \"STRING\" character ( len =* ), parameter :: substring = \"SUBSTRING\" character ( len =* ), parameter :: expected = \"STRSUBSTRINGING\" integer , parameter :: start = 4 result_ = assert_equals ( expected , insert ( string , start , substring )) end function pure function check_insert_character_into_character_at_end () result ( result_ ) use iso_varying_string , only : insert use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: string = \"STRING\" character ( len =* ), parameter :: substring = \"SUBSTRING\" character ( len =* ), parameter :: expected = \"STRINGSUBSTRING\" integer , parameter :: start = 7 result_ = assert_equals ( expected , insert ( string , start , substring )) end function pure function check_insert_character_into_character_at_beginning () result ( result_ ) use iso_varying_string , only : insert use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: string = \"STRING\" character ( len =* ), parameter :: substring = \"SUBSTRING\" character ( len =* ), parameter :: expected = \"SUBSTRINGSTRING\" integer , parameter :: start = - 1 result_ = assert_equals ( expected , insert ( string , start , substring )) end function pure function check_insert_character_into_string () result ( result_ ) use iso_varying_string , only : insert , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: string = \"STRING\" character ( len =* ), parameter :: substring = \"SUBSTRING\" character ( len =* ), parameter :: expected = \"STRSUBSTRINGING\" integer , parameter :: start = 4 result_ = assert_equals ( expected , insert ( var_str ( string ), start , substring )) end function pure function check_insert_character_into_string_at_end () result ( result_ ) use iso_varying_string , only : insert , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: string = \"STRING\" character ( len =* ), parameter :: substring = \"SUBSTRING\" character ( len =* ), parameter :: expected = \"STRINGSUBSTRING\" integer , parameter :: start = 7 result_ = assert_equals ( expected , insert ( var_str ( string ), start , substring )) end function pure function check_insert_character_into_string_at_beginning () result ( result_ ) use iso_varying_string , only : insert , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: string = \"STRING\" character ( len =* ), parameter :: substring = \"SUBSTRING\" character ( len =* ), parameter :: expected = \"SUBSTRINGSTRING\" integer , parameter :: start = - 1 result_ = assert_equals ( expected , insert ( var_str ( string ), start , substring )) end function pure function check_insert_string_into_character () result ( result_ ) use iso_varying_string , only : insert , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: string = \"STRING\" character ( len =* ), parameter :: substring = \"SUBSTRING\" character ( len =* ), parameter :: expected = \"STRSUBSTRINGING\" integer , parameter :: start = 4 result_ = assert_equals ( expected , insert ( string , start , var_str ( substring ))) end function pure function check_insert_string_into_character_at_end () result ( result_ ) use iso_varying_string , only : insert , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: string = \"STRING\" character ( len =* ), parameter :: substring = \"SUBSTRING\" character ( len =* ), parameter :: expected = \"STRINGSUBSTRING\" integer , parameter :: start = 7 result_ = assert_equals ( expected , insert ( string , start , var_str ( substring ))) end function pure function check_insert_string_into_character_at_beginning () result ( result_ ) use iso_varying_string , only : insert , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: string = \"STRING\" character ( len =* ), parameter :: substring = \"SUBSTRING\" character ( len =* ), parameter :: expected = \"SUBSTRINGSTRING\" integer , parameter :: start = - 1 result_ = assert_equals ( expected , insert ( string , start , var_str ( substring ))) end function pure function check_insert_string_into_string () result ( result_ ) use iso_varying_string , only : insert , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: string = \"STRING\" character ( len =* ), parameter :: substring = \"SUBSTRING\" character ( len =* ), parameter :: expected = \"STRSUBSTRINGING\" integer , parameter :: start = 4 result_ = assert_equals ( expected , insert ( var_str ( string ), start , var_str ( substring ))) end function pure function check_insert_string_into_string_at_end () result ( result_ ) use iso_varying_string , only : insert , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: string = \"STRING\" character ( len =* ), parameter :: substring = \"SUBSTRING\" character ( len =* ), parameter :: expected = \"STRINGSUBSTRING\" integer , parameter :: start = 7 result_ = assert_equals ( expected , insert ( var_str ( string ), start , var_str ( substring ))) end function pure function check_insert_string_into_string_at_beginning () result ( result_ ) use iso_varying_string , only : insert , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: string = \"STRING\" character ( len =* ), parameter :: substring = \"SUBSTRING\" character ( len =* ), parameter :: expected = \"SUBSTRINGSTRING\" integer , parameter :: start = - 1 result_ = assert_equals ( expected , insert ( var_str ( string ), start , var_str ( substring ))) end function end module","tags":"","loc":"sourcefile/insert_test.f90.html","title":"insert_test.f90 – miniFAVOR"},{"text":"Contents Modules scan_test Source Code scan_test.f90 Source Code module scan_test implicit none private public :: test_scan contains function test_scan () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_scan_strings ) individual_tests ( 2 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_scan_string_and_character ) individual_tests ( 3 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_scan_character_and_string ) tests = describe ( & \"Sec. 3.4.14: SCAN functions the same as for two characters for\" , & individual_tests ) end function pure function check_scan_strings ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , scan use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = & assert_equals ( & scan ( char ( strings % first ), char ( strings % second )), & scan ( strings % first , strings % second ), & 'scan(\"' // strings % first // '\", \"' // strings % second // '\")' ) & . and . assert_equals ( & scan ( char ( strings % first ), char ( strings % second ), . false .), & scan ( strings % first , strings % second , . false .), & 'scan(\"' // strings % first // '\", \"' // strings % second // '\", .false.)' ) & . and . assert_equals ( & scan ( char ( strings % first ), char ( strings % second ), . true .), & scan ( strings % first , strings % second , . true .), & 'scan(\"' // strings % first // '\", \"' // strings % second // '\", .true.)' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_scan_string_and_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , scan use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = & assert_equals ( & scan ( char ( strings % first ), char ( strings % second )), & scan ( strings % first , char ( strings % second )), & 'scan(\"' // strings % first // '\", \"' // strings % second // '\")' ) & . and . assert_equals ( & scan ( char ( strings % first ), char ( strings % second ), . false .), & scan ( strings % first , char ( strings % second ), . false .), & 'scan(\"' // strings % first // '\", \"' // strings % second // '\", .false.)' ) & . and . assert_equals ( & scan ( char ( strings % first ), char ( strings % second ), . true .), & scan ( strings % first , char ( strings % second ), . true .), & 'scan(\"' // strings % first // '\", \"' // strings % second // '\", .true.)' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_scan_character_and_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , scan use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = & assert_equals ( & scan ( char ( strings % first ), char ( strings % second )), & scan ( char ( strings % first ), strings % second ), & 'scan(\"' // strings % first // '\", \"' // strings % second // '\")' ) & . and . assert_equals ( & scan ( char ( strings % first ), char ( strings % second ), . false .), & scan ( char ( strings % first ), strings % second , . false .), & 'scan(\"' // strings % first // '\", \"' // strings % second // '\", .false.)' ) & . and . assert_equals ( & scan ( char ( strings % first ), char ( strings % second ), . true .), & scan ( char ( strings % first ), strings % second , . true .), & 'scan(\"' // strings % first // '\", \"' // strings % second // '\", .true.)' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/scan_test.f90.html","title":"scan_test.f90 – miniFAVOR"},{"text":"Contents Modules less_than_equal_test Source Code less_than_equal_test.f90 Source Code module less_than_equal_test implicit none private public :: test_less_than_equals contains function test_less_than_equals () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_less_than_equal_string ) individual_tests ( 2 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_character_less_than_equal_string ) individual_tests ( 3 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_less_than_equal_character ) tests = describe ( & \"Sec. 3.3.3: operator(<=) functions the same as for two characters for\" , & individual_tests ) end function pure function check_string_less_than_equal_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( <= ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) <= char ( strings % second ) & . eqv . strings % first <= strings % second , & '\"' // strings % first // '\" <= \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_character_less_than_equal_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( <= ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) <= char ( strings % second ) & . eqv . char ( strings % first ) <= strings % second , & '\"' // strings % first // '\" <= \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_string_less_than_equal_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( <= ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) <= char ( strings % second ) & . eqv . strings % first <= char ( strings % second ), & '\"' // strings % first // '\" <= \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/less_than_equal_test.f90.html","title":"less_than_equal_test.f90 – miniFAVOR"},{"text":"Contents Modules assignment_test Source Code assignment_test.f90 Source Code module assignment_test implicit none private public :: test_assignment contains function test_assignment () result ( tests ) use vegetables , only : test_item_t , describe , it , ASCII_STRING_GENERATOR type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 4 ) individual_tests ( 1 ) = it ( & \"can assign a character to a string\" , & ASCII_STRING_GENERATOR , & check_assign_character_to_string ) individual_tests ( 2 ) = it ( & \"can assign a string to a string\" , & ASCII_STRING_GENERATOR , & check_assign_string_to_string ) individual_tests ( 3 ) = it ( & \"can assign a string to a shorter character\" , & check_assign_to_shorter_character ) individual_tests ( 4 ) = it ( & \"can assign a string to a longer character\" , & check_assign_to_longer_character ) tests = describe ( \"Sec. 3.3.1: assignment\" , individual_tests ) end function pure function check_assign_character_to_string ( string ) result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ), char use vegetables , only : & input_t , result_t , string_input_t , assert_equals , fail class ( input_t ), intent ( in ) :: string type ( result_t ) :: result_ type ( varying_string ) :: assigned select type ( string ) type is ( string_input_t ) assigned = char ( string % value_ ) result_ = assert_equals ( & string % value_ , & assigned , & \"Where the variable is of type VARYING_STRING, the length\" & // \" of the variable becomes that of the expression\" ) class default result_ = fail ( \"Expected to get a string_input_t\" ) end select end function pure function check_assign_string_to_string ( string ) result ( result_ ) use iso_varying_string , only : varying_string , assignment ( = ) use vegetables , only : & input_t , result_t , string_input_t , assert_equals , fail class ( input_t ), intent ( in ) :: string type ( result_t ) :: result_ type ( varying_string ) :: assigned select type ( string ) type is ( string_input_t ) assigned = string % value_ result_ = assert_equals ( & string % value_ , & assigned , & \"Where the variable is of type VARYING_STRING, the length\" & // \" of the variable becomes that of the expression\" ) class default result_ = fail ( \"Expected to get a string_input_t\" ) end select end function pure function check_assign_to_shorter_character () result ( result_ ) use iso_varying_string , only : assignment ( = ), var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len = 4 ) :: assigned assigned = var_str ( \"EXAMPLE\" ) result_ = assert_equals ( & \"EXAM\" , & assigned , & \"if the expression string is longer than the declared length of\" & // \" the character variable, only the left-most characters are assigned.\" ) end function pure function check_assign_to_longer_character () result ( result_ ) use iso_varying_string , only : assignment ( = ), var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len = 10 ) :: assigned assigned = var_str ( \"EXAMPLE\" ) result_ = assert_equals ( & \"EXAMPLE   \" , & assigned , & \"If the character variable is longer than that of the string\" & // \" expression, it is padded on the right with blanks.\" ) end function end module","tags":"","loc":"sourcefile/assignment_test.f90.html","title":"assignment_test.f90 – miniFAVOR"},{"text":"Contents Modules ichar_test Source Code ichar_test.f90 Source Code module ichar_test implicit none private public :: test_ichar contains function test_ichar () result ( tests ) use custom_generator , only : ASCII_CHARACTER_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 1 ) individual_tests ( 1 ) = it ( & \"works the same for characters and strings\" , & ASCII_CHARACTER_GENERATOR , & check_ichar ) tests = describe ( \"Sec. 3.4.5: ICHAR\" , individual_tests ) end function pure function check_ichar ( char_ ) result ( result_ ) use custom_generator , only : character_input_t use iso_varying_string , only : ichar , var_str use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: char_ type ( result_t ) :: result_ select type ( char_ ) type is ( character_input_t ) result_ = assert_equals ( & ichar ( char_ % value_ ), & ichar ( var_str ( char_ % value_ )), & char_ % value_ ) class default result_ = fail ( \"Expected to get a character_input_t.\" ) end select end function end module","tags":"","loc":"sourcefile/ichar_test.f90.html","title":"ichar_test.f90 – miniFAVOR"},{"text":"Contents Modules lle_test Source Code lle_test.f90 Source Code module lle_test implicit none private public :: test_lle contains function test_lle () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_lle_string ) individual_tests ( 2 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_character_lle_string ) individual_tests ( 3 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_lle_character ) tests = describe ( & \"Sec. 3.4.11: LLE functions the same as for two characters for\" , & individual_tests ) end function pure function check_string_lle_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , lle use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & lle ( char ( strings % first ), char ( strings % second )) & . eqv . lle ( strings % first , strings % second ), & 'lle(\"' // strings % first // '\", \"' // strings % second // '\")' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_character_lle_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , lle use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & lle ( char ( strings % first ), char ( strings % second )) & . eqv . lle ( char ( strings % first ), strings % second ), & 'lle(\"' // strings % first // '\", \"' // strings % second // '\")' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_string_lle_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , lle use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & lle ( char ( strings % first ), char ( strings % second )) & . eqv . lle ( strings % first , char ( strings % second )), & 'lle(\"' // strings % first // '\", \"' // strings % second // '\")' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/lle_test.f90.html","title":"lle_test.f90 – miniFAVOR"},{"text":"Contents Modules less_than_test Source Code less_than_test.f90 Source Code module less_than_test implicit none private public :: test_less_than contains function test_less_than () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_less_than_string ) individual_tests ( 2 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_character_less_than_string ) individual_tests ( 3 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_less_than_character ) tests = describe ( & \"Sec. 3.3.3: operator(<) functions the same as for two characters for\" , & individual_tests ) end function pure function check_string_less_than_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( < ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) < char ( strings % second ) & . eqv . strings % first < strings % second , & '\"' // strings % first // '\" < \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_character_less_than_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( < ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) < char ( strings % second ) & . eqv . char ( strings % first ) < strings % second , & '\"' // strings % first // '\" < \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_string_less_than_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( < ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) < char ( strings % second ) & . eqv . strings % first < char ( strings % second ), & '\"' // strings % first // '\" < \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/less_than_test.f90.html","title":"less_than_test.f90 – miniFAVOR"},{"text":"Contents Modules remove_test Source Code remove_test.f90 Source Code module remove_test implicit none private public :: test_remove_character , test_remove_string contains function test_remove_character () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 6 ) individual_tests ( 1 ) = it ( & \"The result value is a copy of the characters of the argument\" & // \" string between positions start and finish, inclusive.\" , & check_remove_character ) individual_tests ( 2 ) = it ( & \"If start is absent, the value one is used for start.\" , & check_remove_character_without_start ) individual_tests ( 3 ) = it ( & \"If start is less than one, the value one is used for start.\" , & check_remove_character_with_start_lt_one ) individual_tests ( 4 ) = it ( & \"If finish is absent, the value LEN(string) is used for finish.\" , & check_remove_character_without_finish ) individual_tests ( 5 ) = it ( & \"If finish is greater than LEN(string), the value LEN(string) is used for finish.\" , & check_remove_character_with_finish_gt_len_string ) individual_tests ( 6 ) = it ( & \"If finish is less than start, the characters of string are delivered unchanged.\" , & check_remove_character_zero_length ) tests = describe ( \"Sec. 3.7.3 REMOVE character\" , individual_tests ) end function function test_remove_string () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 6 ) individual_tests ( 1 ) = it ( & \"The result value is a copy of the characters of the argument\" & // \" string between positions start and finish, inclusive.\" , & check_remove_string ) individual_tests ( 2 ) = it ( & \"If start is absent, the value one is used for start.\" , & check_remove_string_without_start ) individual_tests ( 3 ) = it ( & \"If start is less than one, the value one is used for start.\" , & check_remove_string_with_start_lt_one ) individual_tests ( 4 ) = it ( & \"If finish is absent, the value LEN(string) is used for finish.\" , & check_remove_string_without_finish ) individual_tests ( 5 ) = it ( & \"If finish is greater than LEN(string), the value LEN(string) is used for finish.\" , & check_remove_string_with_finish_gt_len_string ) individual_tests ( 6 ) = it ( & \"If finish is less than start, the characters of string are delivered unchanged.\" , & check_remove_string_zero_length ) tests = describe ( \"Sec. 3.7.3 REMOVE string\" , individual_tests ) end function pure function check_remove_character () result ( result_ ) use iso_varying_string , only : remove use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"EPLE\" , remove ( \"EXAMPLE\" , 2 , 4 )) end function pure function check_remove_character_without_start () result ( result_ ) use iso_varying_string , only : remove use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"PLE\" , remove ( \"EXAMPLE\" , finish = 4 )) end function pure function check_remove_character_with_start_lt_one () result ( result_ ) use iso_varying_string , only : remove use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"PLE\" , remove ( \"EXAMPLE\" , - 1 , 4 )) end function pure function check_remove_character_without_finish () result ( result_ ) use iso_varying_string , only : remove use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"E\" , remove ( \"EXAMPLE\" , 2 )) end function pure function check_remove_character_with_finish_gt_len_string () result ( result_ ) use iso_varying_string , only : remove use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"E\" , remove ( \"EXAMPLE\" , 2 , 8 )) end function pure function check_remove_character_zero_length () result ( result_ ) use iso_varying_string , only : remove use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"EXAMPLE\" , remove ( \"EXAMPLE\" , 10 , - 2 )) end function pure function check_remove_string () result ( result_ ) use iso_varying_string , only : remove , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"EPLE\" , remove ( var_str ( \"EXAMPLE\" ), 2 , 4 )) end function pure function check_remove_string_without_start () result ( result_ ) use iso_varying_string , only : remove , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"PLE\" , remove ( var_str ( \"EXAMPLE\" ), finish = 4 )) end function pure function check_remove_string_with_start_lt_one () result ( result_ ) use iso_varying_string , only : remove , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"PLE\" , remove ( var_str ( \"EXAMPLE\" ), - 1 , 4 )) end function pure function check_remove_string_without_finish () result ( result_ ) use iso_varying_string , only : remove , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"E\" , remove ( var_str ( \"EXAMPLE\" ), 2 )) end function pure function check_remove_string_with_finish_gt_len_string () result ( result_ ) use iso_varying_string , only : remove , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"E\" , remove ( var_str ( \"EXAMPLE\" ), 2 , 8 )) end function pure function check_remove_string_zero_length () result ( result_ ) use iso_varying_string , only : remove , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"EXAMPLE\" , remove ( var_str ( \"EXAMPLE\" ), 10 , - 2 )) end function end module","tags":"","loc":"sourcefile/remove_test.f90.html","title":"remove_test.f90 – miniFAVOR"},{"text":"Contents Modules verify_test Source Code verify_test.f90 Source Code module verify_test implicit none private public :: test_verify contains function test_verify () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_verify_strings ) individual_tests ( 2 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_verify_string_and_character ) individual_tests ( 3 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_verify_character_and_string ) tests = describe ( & \"Sec. 3.4.16: VERIFY functions the same as for two characters for\" , & individual_tests ) end function pure function check_verify_strings ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , verify use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = & assert_equals ( & verify ( char ( strings % first ), char ( strings % second )), & verify ( strings % first , strings % second ), & 'verify(\"' // strings % first // '\", \"' // strings % second // '\")' ) & . and . assert_equals ( & verify ( char ( strings % first ), char ( strings % second ), . false .), & verify ( strings % first , strings % second , . false .), & 'verify(\"' // strings % first // '\", \"' // strings % second // '\", .false.)' ) & . and . assert_equals ( & verify ( char ( strings % first ), char ( strings % second ), . true .), & verify ( strings % first , strings % second , . true .), & 'verify(\"' // strings % first // '\", \"' // strings % second // '\", .true.)' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_verify_string_and_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , verify use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = & assert_equals ( & verify ( char ( strings % first ), char ( strings % second )), & verify ( strings % first , char ( strings % second )), & 'verify(\"' // strings % first // '\", \"' // strings % second // '\")' ) & . and . assert_equals ( & verify ( char ( strings % first ), char ( strings % second ), . false .), & verify ( strings % first , char ( strings % second ), . false .), & 'verify(\"' // strings % first // '\", \"' // strings % second // '\", .false.)' ) & . and . assert_equals ( & verify ( char ( strings % first ), char ( strings % second ), . true .), & verify ( strings % first , char ( strings % second ), . true .), & 'verify(\"' // strings % first // '\", \"' // strings % second // '\", .true.)' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_verify_character_and_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), char , verify use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = & assert_equals ( & verify ( char ( strings % first ), char ( strings % second )), & verify ( char ( strings % first ), strings % second ), & 'verify(\"' // strings % first // '\", \"' // strings % second // '\")' ) & . and . assert_equals ( & verify ( char ( strings % first ), char ( strings % second ), . false .), & verify ( char ( strings % first ), strings % second , . false .), & 'verify(\"' // strings % first // '\", \"' // strings % second // '\", .false.)' ) & . and . assert_equals ( & verify ( char ( strings % first ), char ( strings % second ), . true .), & verify ( char ( strings % first ), strings % second , . true .), & 'verify(\"' // strings % first // '\", \"' // strings % second // '\", .true.)' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/verify_test.f90.html","title":"verify_test.f90 – miniFAVOR"},{"text":"Contents Modules equal_test Source Code equal_test.f90 Source Code module equal_test implicit none private public :: test_equals contains function test_equals () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_equal_string ) individual_tests ( 2 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_character_equal_string ) individual_tests ( 3 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_string_equal_character ) tests = describe ( & \"Sec. 3.3.3: operator(==) functions the same as for two characters for\" , & individual_tests ) end function pure function check_string_equal_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( == ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) == char ( strings % second ) & . eqv . strings % first == strings % second , & '\"' // strings % first // '\" == \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_character_equal_string ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( == ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) == char ( strings % second ) & . eqv . char ( strings % first ) == strings % second , & '\"' // strings % first // '\" == \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function pure function check_string_equal_character ( strings ) result ( result_ ) use custom_generator , only : string_pair_input_t use iso_varying_string , only : operator ( // ), operator ( == ), char use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: strings type ( result_t ) :: result_ select type ( strings ) type is ( string_pair_input_t ) result_ = assert_that ( & char ( strings % first ) == char ( strings % second ) & . eqv . strings % first == char ( strings % second ), & '\"' // strings % first // '\" == \"' // strings % second // '\"' ) class default result_ = fail ( \"Expected to get a string_pair_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/equal_test.f90.html","title":"equal_test.f90 – miniFAVOR"},{"text":"Contents Modules replace_range_test Source Code replace_range_test.f90 Source Code module replace_range_test implicit none private public :: & test_replace_character_in_character_range , & test_replace_character_in_string_range , & test_replace_string_in_character_range , & test_replace_string_in_string_range contains function test_replace_character_in_character_range () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 4 ) individual_tests ( 1 ) = it ( & \"The characters in the copy of string between positions start\" & // \" and finish, including those at start and finish, are\" & // \" deleted and replaced by characters of substring.\" , & check_replace_character_in_character ) individual_tests ( 2 ) = it ( & \"If start is less than one, the value one is used for start.\" , & check_replace_character_in_character_start_lt_one ) individual_tests ( 3 ) = it ( & \"If finish is greater than len(string), the value len(string)\" & // \" is used for finish.\" , & check_replace_character_in_character_start_gt_end ) individual_tests ( 4 ) = it ( & \"If finish is less than start, the characters of substring\" & // \" are inserted before the character at start and no\" & // \" characters are deleted.\" , & check_replace_character_in_character_start_gt_finish ) tests = describe ( & \"Sec. 3.7.4: REPLACE in character with character in range\" , & individual_tests ) end function function test_replace_character_in_string_range () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 4 ) individual_tests ( 1 ) = it ( & \"The characters in the copy of string between positions start\" & // \" and finish, including those at start and finish, are\" & // \" deleted and replaced by characters of substring.\" , & check_replace_character_in_string ) individual_tests ( 2 ) = it ( & \"If start is less than one, the value one is used for start.\" , & check_replace_character_in_string_start_lt_one ) individual_tests ( 3 ) = it ( & \"If finish is greater than len(string), the value len(string)\" & // \" is used for finish.\" , & check_replace_character_in_string_start_gt_end ) individual_tests ( 4 ) = it ( & \"If finish is less than start, the characters of substring\" & // \" are inserted before the character at start and no\" & // \" characters are deleted.\" , & check_replace_character_in_string_start_gt_finish ) tests = describe ( & \"Sec. 3.7.4: REPLACE in string with character in range\" , & individual_tests ) end function function test_replace_string_in_character_range () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 4 ) individual_tests ( 1 ) = it ( & \"The characters in the copy of string between positions start\" & // \" and finish, including those at start and finish, are\" & // \" deleted and replaced by characters of substring.\" , & check_replace_string_in_character ) individual_tests ( 2 ) = it ( & \"If start is less than one, the value one is used for start.\" , & check_replace_string_in_character_start_lt_one ) individual_tests ( 3 ) = it ( & \"If finish is greater than len(string), the value len(string)\" & // \" is used for finish.\" , & check_replace_string_in_character_start_gt_end ) individual_tests ( 4 ) = it ( & \"If finish is less than start, the characters of substring\" & // \" are inserted before the character at start and no\" & // \" characters are deleted.\" , & check_replace_string_in_character_start_gt_finish ) tests = describe ( & \"Sec. 3.7.4: REPLACE in character with string in range\" , & individual_tests ) end function function test_replace_string_in_string_range () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 4 ) individual_tests ( 1 ) = it ( & \"The characters in the copy of string between positions start\" & // \" and finish, including those at start and finish, are\" & // \" deleted and replaced by characters of substring.\" , & check_replace_string_in_string ) individual_tests ( 2 ) = it ( & \"If start is less than one, the value one is used for start.\" , & check_replace_string_in_string_start_lt_one ) individual_tests ( 3 ) = it ( & \"If finish is greater than len(string), the value len(string)\" & // \" is used for finish.\" , & check_replace_string_in_string_start_gt_end ) individual_tests ( 4 ) = it ( & \"If finish is less than start, the characters of substring\" & // \" are inserted before the character at start and no\" & // \" characters are deleted.\" , & check_replace_string_in_string_start_gt_finish ) tests = describe ( & \"Sec. 3.7.4: REPLACE in string with string in range\" , & individual_tests ) end function pure function check_replace_character_in_character () result ( result_ ) use iso_varying_string , only : replace use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"THAT WAS CRAZY\" , & replace ( \"THAT IS CRAZY\" , 6 , 7 , \"WAS\" )) end function pure function check_replace_character_in_character_start_lt_one () result ( result_ ) use iso_varying_string , only : replace use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"WAS CRAZY\" , & replace ( \"THAT IS CRAZY\" , - 1 , 7 , \"WAS\" )) end function pure function check_replace_character_in_character_start_gt_end () result ( result_ ) use iso_varying_string , only : replace use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"THAT WAS\" , & replace ( \"THAT IS CRAZY\" , 6 , 15 , \"WAS\" )) end function pure function check_replace_character_in_character_start_gt_finish () result ( result_ ) use iso_varying_string , only : replace use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"THAT WASIS CRAZY\" , & replace ( \"THAT IS CRAZY\" , 6 , 1 , \"WAS\" )) end function pure function check_replace_character_in_string () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"THAT WAS CRAZY\" , & replace ( var_str ( \"THAT IS CRAZY\" ), 6 , 7 , \"WAS\" )) end function pure function check_replace_character_in_string_start_lt_one () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"WAS CRAZY\" , & replace ( var_str ( \"THAT IS CRAZY\" ), - 1 , 7 , \"WAS\" )) end function pure function check_replace_character_in_string_start_gt_end () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"THAT WAS\" , & replace ( var_str ( \"THAT IS CRAZY\" ), 6 , 15 , \"WAS\" )) end function pure function check_replace_character_in_string_start_gt_finish () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"THAT WASIS CRAZY\" , & replace ( var_str ( \"THAT IS CRAZY\" ), 6 , 1 , \"WAS\" )) end function pure function check_replace_string_in_character () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"THAT WAS CRAZY\" , & replace ( \"THAT IS CRAZY\" , 6 , 7 , var_str ( \"WAS\" ))) end function pure function check_replace_string_in_character_start_lt_one () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"WAS CRAZY\" , & replace ( \"THAT IS CRAZY\" , - 1 , 7 , var_str ( \"WAS\" ))) end function pure function check_replace_string_in_character_start_gt_end () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"THAT WAS\" , & replace ( \"THAT IS CRAZY\" , 6 , 15 , var_str ( \"WAS\" ))) end function pure function check_replace_string_in_character_start_gt_finish () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"THAT WASIS CRAZY\" , & replace ( \"THAT IS CRAZY\" , 6 , 1 , var_str ( \"WAS\" ))) end function pure function check_replace_string_in_string () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"THAT WAS CRAZY\" , & replace ( var_str ( \"THAT IS CRAZY\" ), 6 , 7 , var_str ( \"WAS\" ))) end function pure function check_replace_string_in_string_start_lt_one () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"WAS CRAZY\" , & replace ( var_str ( \"THAT IS CRAZY\" ), - 1 , 7 , var_str ( \"WAS\" ))) end function pure function check_replace_string_in_string_start_gt_end () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"THAT WAS\" , & replace ( var_str ( \"THAT IS CRAZY\" ), 6 , 15 , var_str ( \"WAS\" ))) end function pure function check_replace_string_in_string_start_gt_finish () result ( result_ ) use iso_varying_string , only : replace , var_str use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"THAT WASIS CRAZY\" , & replace ( var_str ( \"THAT IS CRAZY\" ), 6 , 1 , var_str ( \"WAS\" ))) end function end module","tags":"","loc":"sourcefile/replace_range_test.f90.html","title":"replace_range_test.f90 – miniFAVOR"},{"text":"Contents Modules var_str_test Source Code var_str_test.f90 Source Code module var_str_test implicit none private public :: test_var_str contains function test_var_str () result ( tests ) use vegetables , only : test_item_t , describe , it , ASCII_STRING_GENERATOR type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 1 ) individual_tests ( 1 ) = it ( & \"Converts an intrinsic fixed-length character value into the\" & // \" equivalent varying-length string value.\" , & ASCII_STRING_GENERATOR , & check_var_str ) tests = describe ( \"Sec. 3.5.1: VAR_STR\" , individual_tests ) end function pure function check_var_str ( string ) result ( result_ ) use iso_varying_string , only : char , var_str use vegetables , only : & input_t , result_t , string_input_t , assert_equals , fail class ( input_t ), intent ( in ) :: string type ( result_t ) :: result_ select type ( string ) type is ( string_input_t ) result_ = assert_equals ( & string % value_ , & var_str ( char ( string % value_ )), & \"The result value is the same string of characters as the argument.\" ) class default result_ = fail ( \"Expected to get a string_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/var_str_test.f90.html","title":"var_str_test.f90 – miniFAVOR"},{"text":"Contents Modules adjustl_test Source Code adjustl_test.f90 Source Code module adjustl_test implicit none private public :: test_adjustl contains function test_adjustl () result ( tests ) use vegetables , only : test_item_t , describe , it , ASCII_STRING_GENERATOR type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 1 ) individual_tests = it ( & \"works the same for characters and strings\" , & ASCII_STRING_GENERATOR , & check_adjustl ) tests = describe ( \"Sec 3.4.1: ADJUSTL\" , individual_tests ) end function pure function check_adjustl ( string ) result ( result_ ) use iso_varying_string , only : adjustl , char use vegetables , only : & input_t , result_t , string_input_t , assert_equals , fail class ( input_t ), intent ( in ) :: string type ( result_t ) :: result_ select type ( string ) type is ( string_input_t ) result_ = assert_equals ( & adjustl ( char ( string % value_ )), & adjustl ( string % value_ )) class default result_ = fail ( \"Expected to get a string_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/adjustl_test.f90.html","title":"adjustl_test.f90 – miniFAVOR"},{"text":"Contents Programs simple_put Source Code main.f90 Source Code program simple_put use iso_varying_string , only : put implicit none call put ( \"hello from simple_put\" ) end program","tags":"","loc":"sourcefile/main.f90~5.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Programs round_trip Source Code main.f90 Source Code program round_trip use iso_fortran_env , only : IOSTAT_EOR , IOSTAT_END use iso_varying_string , only : & varying_string , & operator ( // ), & operator ( /= ), & get , & put , & put_line , & var_str integer :: file_unit type ( varying_string ) :: string type ( varying_string ) :: separator integer :: stat open ( newunit = file_unit , status = \"SCRATCH\" ) call put ( file_unit , \"hello from simple_put\" ) call put_line ( file_unit , \"\" ) call put ( file_unit , var_str ( \"hello from string_put\" )) call put_line ( file_unit , \"\" ) call put_line ( file_unit , \"hello from simple_put_line\" ) call put_line ( file_unit , var_str ( \"hello from string_put_line\" )) call put_line ( file_unit , \"hello get_maxlen\" ) call put_line ( file_unit , \"hello,get terminator\" ) rewind ( file_unit ) call get ( file_unit , string ) if ( string /= \"hello from simple_put\" ) then call put_line ( \"expected 'hello from simple_put' but got '\" // string // \"'\" ) error stop end if call get ( file_unit , string ) if ( string /= \"hello from string_put\" ) then call put_line ( \"expected 'hello from string_put' but got '\" // string // \"'\" ) error stop end if call get ( file_unit , string ) if ( string /= \"hello from simple_put_line\" ) then call put_line ( \"expected 'hello from simple_put_line' but got '\" // string // \"'\" ) error stop end if call get ( file_unit , string ) if ( string /= \"hello from string_put_line\" ) then call put_line ( \"expected 'hello from string_put_line' but got '\" // string // \"'\" ) error stop end if call get ( file_unit , string , 5 ) if ( string /= \"hello\" ) then call put_line ( \"expected 'hello' but got '\" // string // \"'\" ) error stop end if call get ( file_unit , string ) if ( string /= \" get_maxlen\" ) then call put_line ( \"expected ' get_maxlen' but got '\" // string // \"'\" ) error stop end if call get ( file_unit , string , \", \" , separator ) if ( string /= \"hello\" ) then call put_line ( \"expected 'hello' but got '\" // string // \"'\" ) error stop end if if ( separator /= \",\" ) then call put_line ( \"separator should have been ',' but was '\" // separator // \"'\" ) error stop end if call get ( file_unit , string , \", \" , separator ) if ( string /= \"get\" ) then call put_line ( \"expected 'get' but got '\" // string // \"'\" ) error stop end if if ( separator /= \" \" ) then call put_line ( \"separator should have been ' ' but was '\" // separator // \"'\" ) error stop end if call get ( file_unit , string , \", \" , separator ) if ( string /= \"terminator\" ) then call put_line ( \"expected 'terminator' but got '\" // string // \"'\" ) error stop end if if ( separator /= \"\" ) then call put_line ( \"separator should have been empty, but was '\" // separator // \"'\" ) error stop end if call get ( file_unit , string , iostat = stat ) if ( stat /= IOSTAT_EOR ) then call put_line ( \"didn't get EOR\" ) error stop end if call get ( file_unit , string , iostat = stat ) if ( stat /= IOSTAT_END ) then call put_line ( \"didn't get EOF\" ) error stop end if close ( file_unit ) end program","tags":"","loc":"sourcefile/main.f90~6.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Programs get_iostat Source Code main.f90 Source Code program get_iostat use iso_fortran_env , only : IOSTAT_EOR , IOSTAT_END use iso_varying_string , only : varying_string , get , put_line integer :: stat type ( varying_string ) :: string call get ( string , iostat = stat ) if ( stat /= IOSTAT_EOR ) then call put_line ( \"didn't get EOR\" ) error stop end if call get ( string , iostat = stat ) if ( stat /= IOSTAT_END ) then call put_line ( \"didn't get EOF\" ) error stop end if end program","tags":"","loc":"sourcefile/main.f90~7.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Programs get_terminator Source Code main.f90 Source Code program get_terminator use iso_varying_string , only : & varying_string , operator ( // ), operator ( /= ), get , put_line implicit none type ( varying_string ) :: string type ( varying_string ) :: separator call get ( string , \", \" , separator ) if ( string /= \"hello\" ) then call put_line ( \"expected 'hello' but got '\" // string // \"'\" ) error stop end if if ( separator /= \",\" ) then call put_line ( \"separator should have been ',' but was '\" // separator // \"'\" ) error stop end if call get ( string , \", \" , separator ) if ( string /= \"get\" ) then call put_line ( \"expected 'get' but got '\" // string // \"'\" ) error stop end if if ( separator /= \" \" ) then call put_line ( \"separator should have been ' ' but was '\" // separator // \"'\" ) error stop end if call get ( string , \", \" , separator ) if ( string /= \"terminator\" ) then call put_line ( \"expected 'terminator' but got '\" // string // \"'\" ) error stop end if if ( separator /= \"\" ) then call put_line ( \"separator should have been empty, but was '\" // separator // \"'\" ) error stop end if end program","tags":"","loc":"sourcefile/main.f90~8.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Programs get_maxlen Source Code main.f90 Source Code program get_maxlen use iso_varying_string , only : & varying_string , operator ( // ), operator ( /= ), get , put_line implicit none type ( varying_string ) :: hello type ( varying_string ) :: remaining call get ( hello , 5 ) if ( hello /= \"hello\" ) then call put_line ( \"expected 'hello' but got '\" // hello // \"'\" ) error stop end if call get ( remaining ) if ( remaining /= \" get_maxlen\" ) then call put_line ( \"expected ' get_maxlen' but got '\" // remaining // \"'\" ) error stop end if end program","tags":"","loc":"sourcefile/main.f90~9.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Programs string_put_line Source Code main.f90 Source Code program string_put_line use iso_varying_string , only : put_line , var_str implicit none call put_line ( var_str ( \"hello from string_put_line\" )) end program","tags":"","loc":"sourcefile/main.f90~10.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Programs string_put Source Code main.f90 Source Code program string_put use iso_varying_string , only : put , var_str implicit none call put ( var_str ( \"hello from string_put\" )) end program","tags":"","loc":"sourcefile/main.f90~11.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Modules iso_varying_string Source Code ISO_VARYING_STRING.f90 Source Code module iso_varying_string implicit none private public :: & varying_string , & assignment ( = ), & operator ( // ), & operator ( == ), & operator ( /= ), & operator ( < ), & operator ( <= ), & operator ( > ), & operator ( >= ), & adjustl , & adjustr , & char , & iachar , & ichar , & index , & len , & len_trim , & lge , & lgt , & lle , & llt , & repeat , & scan , & trim , & verify , & var_str , & get , & put , & put_line , & extract , & insert , & remove , & replace , & split type :: varying_string ! Sec. 3.2 private character ( len = 1 ), allocatable :: characters (:) end type interface assignment ( = ) ! Sec. 3.3.1 module procedure assign_character_to_string module procedure assign_string_to_character end interface interface operator ( // ) ! Sec. 3.3.2 module procedure concat_strings module procedure concat_string_and_character module procedure concat_character_and_string end interface interface operator ( == ) ! Sec. 3.3.3 module procedure string_eq_string module procedure character_eq_string module procedure string_eq_character end interface interface operator ( /= ) ! Sec. 3.3.3 module procedure string_ne_string module procedure character_ne_string module procedure string_ne_character end interface interface operator ( < ) ! Sec. 3.3.3 module procedure string_lt_string module procedure character_lt_string module procedure string_lt_character end interface interface operator ( <= ) ! Sec. 3.3.3 module procedure string_le_string module procedure character_le_string module procedure string_le_character end interface interface operator ( > ) ! Sec. 3.3.3 module procedure string_gt_string module procedure character_gt_string module procedure string_gt_character end interface interface operator ( >= ) ! Sec. 3.3.3 module procedure string_ge_string module procedure character_ge_string module procedure string_ge_character end interface interface adjustl ! Sec. 3.4.1 module procedure string_adjustl end interface interface adjustr ! Sec. 3.4.1 module procedure string_adjustr end interface interface char ! Sec. 3.4.3 module procedure string_to_char module procedure string_to_char_with_length end interface interface iachar ! Sec. 3.4.4 module procedure string_iachar end interface interface ichar ! Sec. 3.4.5 module procedure string_ichar end interface interface index ! Sec. 3.4.6 module procedure string_index_string module procedure string_index_character module procedure character_index_string end interface interface len ! Sec. 3.4.7 module procedure len_string end interface interface len_trim ! Sec. 3.4.8 module procedure len_trim_string end interface interface lge ! Sec. 3.4.9 module procedure string_lge_string module procedure character_lge_string module procedure string_lge_character end interface interface lgt ! Sec. 3.4.10 module procedure string_lgt_string module procedure character_lgt_string module procedure string_lgt_character end interface interface lle ! Sec. 3.4.11 module procedure string_lle_string module procedure character_lle_string module procedure string_lle_character end interface interface llt ! Sec. 3.4.12 module procedure string_llt_string module procedure character_llt_string module procedure string_llt_character end interface interface repeat ! Sec. 3.4.13 module procedure string_repeat end interface interface scan ! Sec. 3.4.14 module procedure string_scan_string module procedure string_scan_character module procedure character_scan_string end interface interface trim ! Sec. 3.4.15 module procedure trim_string end interface interface verify ! Sec. 3.4.16 module procedure string_verify_string module procedure string_verify_character module procedure character_verify_string end interface interface get ! Sec. 3.6.1 module procedure get_default_unit_to_end_of_record module procedure get_with_unit_to_end_of_record module procedure get_default_unit_to_terminator_string module procedure get_with_unit_to_terminator_string module procedure get_default_unit_to_terminator_characters module procedure get_with_unit_to_terminator_characters end interface interface put ! Sec. 3.6.2 module procedure put_String_Default_Unit module procedure put_string_with_unit module procedure put_characters_default_unit module procedure put_characters_with_unit end interface interface put_line ! Sec. 3.6.3 module procedure put_line_string_default_unit module procedure put_line_string_with_unit module procedure put_line_characters_default_unit module procedure put_line_characters_with_unit end interface interface extract ! Sec. 3.7.1 module procedure extract_character module procedure extract_string end interface interface insert ! Sec. 3.7.2 module procedure insert_character_into_character module procedure insert_character_into_string module procedure insert_string_into_character module procedure insert_string_into_string end interface interface remove ! Sec. 3.7.3 module procedure remove_character module procedure remove_string end interface interface replace ! Sec. 3.7.4 module procedure replace_character_with_character_start module procedure replace_string_with_character_start module procedure replace_character_with_string_start module procedure replace_string_with_string_start module procedure replace_character_with_character_range module procedure replace_string_with_character_range module procedure replace_character_with_string_range module procedure replace_string_with_string_range module procedure replace_target_character_with_character_in_character module procedure replace_target_character_with_character_in_string module procedure replace_target_character_with_string_in_character module procedure replace_target_character_with_string_in_string module procedure replace_target_string_with_character_in_character module procedure replace_target_string_with_character_in_string module procedure replace_target_string_with_string_in_character module procedure replace_target_string_with_string_in_string end interface interface split ! Sec. 3.7.5 module procedure split_character module procedure split_string end interface contains elemental subroutine assign_character_to_string ( lhs , rhs ) ! Sec. 3.3.1 type ( varying_string ), intent ( out ) :: lhs character ( len =* ), intent ( in ) :: rhs integer :: i integer :: length length = len ( rhs ) allocate ( lhs % characters ( length )) do concurrent ( i = 1 : length ) lhs % characters ( i ) = rhs ( i : i ) end do end subroutine elemental subroutine assign_string_to_character ( lhs , rhs ) ! Sec. 3.3.1 character ( len =* ), intent ( out ) :: lhs type ( varying_string ), intent ( in ) :: rhs integer :: i integer :: length_input integer :: length_output length_output = len ( lhs ) if ( allocated ( rhs % characters )) then length_input = size ( rhs % characters ) do concurrent ( i = 1 : min ( length_input , length_output )) lhs ( i : i ) = rhs % characters ( i ) end do if ( length_input < length_output ) then do concurrent ( i = length_input + 1 : length_output ) lhs ( i : i ) = \" \" end do end if else do concurrent ( i = 1 : length_output ) lhs ( i : i ) = \" \" end do end if end subroutine elemental function concat_strings ( lhs , rhs ) result ( concatenated ) ! Sec. 3.3.2 type ( varying_string ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs type ( varying_string ) :: concatenated concatenated = char ( lhs ) // char ( rhs ) end function elemental function concat_string_and_character ( lhs , rhs ) result ( concatenated ) ! Sec. 3.3.2 type ( varying_string ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs type ( varying_string ) :: concatenated concatenated = char ( lhs ) // rhs end function elemental function concat_character_and_string ( lhs , rhs ) result ( concatenated ) ! Sec. 3.3.2 character ( len =* ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs type ( varying_string ) :: concatenated concatenated = lhs // char ( rhs ) end function elemental function string_eq_string ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 type ( varying_string ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs logical :: equals equals = char ( lhs ) == char ( rhs ) end function elemental function character_eq_string ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 character ( len =* ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs logical :: equals equals = lhs == char ( rhs ) end function elemental function string_eq_character ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 type ( varying_string ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: equals equals = char ( lhs ) == rhs end function elemental function string_ne_string ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 type ( varying_string ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs logical :: equals equals = char ( lhs ) /= char ( rhs ) end function elemental function character_ne_string ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 character ( len =* ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs logical :: equals equals = lhs /= char ( rhs ) end function elemental function string_ne_character ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 type ( varying_string ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: equals equals = char ( lhs ) /= rhs end function elemental function string_lt_string ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 type ( varying_string ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs logical :: equals equals = char ( lhs ) < char ( rhs ) end function elemental function character_lt_string ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 character ( len =* ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs logical :: equals equals = lhs < char ( rhs ) end function elemental function string_lt_character ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 type ( varying_string ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: equals equals = char ( lhs ) < rhs end function elemental function string_le_string ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 type ( varying_string ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs logical :: equals equals = char ( lhs ) <= char ( rhs ) end function elemental function character_le_string ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 character ( len =* ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs logical :: equals equals = lhs <= char ( rhs ) end function elemental function string_le_character ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 type ( varying_string ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: equals equals = char ( lhs ) <= rhs end function elemental function string_gt_string ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 type ( varying_string ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs logical :: equals equals = char ( lhs ) > char ( rhs ) end function elemental function character_gt_string ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 character ( len =* ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs logical :: equals equals = lhs > char ( rhs ) end function elemental function string_gt_character ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 type ( varying_string ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: equals equals = char ( lhs ) > rhs end function elemental function string_ge_string ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 type ( varying_string ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs logical :: equals equals = char ( lhs ) >= char ( rhs ) end function elemental function character_ge_string ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 character ( len =* ), intent ( in ) :: lhs type ( varying_string ), intent ( in ) :: rhs logical :: equals equals = lhs >= char ( rhs ) end function elemental function string_ge_character ( lhs , rhs ) result ( equals ) ! Sec. 3.3.3 type ( varying_string ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: equals equals = char ( lhs ) >= rhs end function elemental function string_adjustl ( string ) result ( adjusted ) ! Sec. 3.4.1 type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: adjusted adjusted = adjustl ( char ( string )) end function elemental function string_adjustr ( string ) result ( adjusted ) ! Sec. 3.4.2 type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: adjusted adjusted = adjustr ( char ( string )) end function pure function string_to_char ( string ) result ( chars ) ! Sec. 3.4.3 type ( varying_string ), intent ( in ) :: string character ( len = :), allocatable :: chars if ( allocated ( string % characters )) then block character ( len = size ( string % characters )) :: tmp tmp = string chars = tmp end block else chars = \"\" end if end function pure function string_to_char_with_length ( string , length ) result ( chars ) ! Sec. 3.4.3 type ( varying_string ), intent ( in ) :: string integer , intent ( in ) :: length character ( len = length ) :: chars if ( allocated ( string % characters )) then chars = string end if end function elemental function string_iachar ( c ) ! Sec. 3.4.4 type ( varying_string ), intent ( in ) :: c integer :: string_iachar string_iachar = iachar ( char ( c )) end function elemental function string_ichar ( c ) ! Sec. 3.4.5 type ( varying_string ), intent ( in ) :: c integer :: string_ichar string_ichar = ichar ( char ( c )) end function elemental function string_index_string ( string , substring , back ) result ( position ) ! Sec. 3.4.6 type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: substring logical , optional , intent ( in ) :: back integer :: position position = index ( char ( string ), char ( substring ), back ) end function elemental function string_index_character ( string , substring , back ) result ( position ) ! Sec. 3.4.6 type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical , optional , intent ( in ) :: back integer :: position position = index ( char ( string ), substring , back ) end function elemental function character_index_string ( string , substring , back ) result ( position ) ! Sec. 3.4.6 character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: substring logical , optional , intent ( in ) :: back integer :: position position = index ( string , char ( substring ), back ) end function elemental function len_string ( string ) result ( length ) ! Sec. 3.4.7 type ( varying_string ), intent ( in ) :: string integer :: length length = len ( char ( string )) end function elemental function len_trim_string ( string ) result ( length ) ! Sec. 3.4.8 type ( varying_string ), intent ( in ) :: string integer :: length length = len_trim ( char ( string )) end function elemental function string_lge_string ( string_a , string_b ) result ( greater_than_or_equals ) ! Sec 3.4.9 type ( varying_string ), intent ( in ) :: string_a type ( varying_string ), intent ( in ) :: string_b logical :: greater_than_or_equals greater_than_or_equals = lge ( char ( string_a ), char ( string_b )) end function elemental function character_lge_string ( string_a , string_b ) result ( greater_than_or_equals ) ! Sec 3.4.9 character ( len =* ), intent ( in ) :: string_a type ( varying_string ), intent ( in ) :: string_b logical :: greater_than_or_equals greater_than_or_equals = lge ( string_a , char ( string_b )) end function elemental function string_lge_character ( string_a , string_b ) result ( greater_than_or_equals ) ! Sec 3.4.9 type ( varying_string ), intent ( in ) :: string_a character ( len =* ), intent ( in ) :: string_b logical :: greater_than_or_equals greater_than_or_equals = lge ( char ( string_a ), string_b ) end function elemental function string_lgt_string ( string_a , string_b ) result ( greater_than ) ! Sec 3.4.10 type ( varying_string ), intent ( in ) :: string_a type ( varying_string ), intent ( in ) :: string_b logical :: greater_than greater_than = lgt ( char ( string_a ), char ( string_b )) end function elemental function character_lgt_string ( string_a , string_b ) result ( greater_than ) ! Sec 3.4.10 character ( len =* ), intent ( in ) :: string_a type ( varying_string ), intent ( in ) :: string_b logical :: greater_than greater_than = lgt ( string_a , char ( string_b )) end function elemental function string_lgt_character ( string_a , string_b ) result ( greater_than ) ! Sec 3.4.10 type ( varying_string ), intent ( in ) :: string_a character ( len =* ), intent ( in ) :: string_b logical :: greater_than greater_than = lgt ( char ( string_a ), string_b ) end function elemental function string_lle_string ( string_a , string_b ) result ( less_than_or_equals ) ! Sec 3.4.11 type ( varying_string ), intent ( in ) :: string_a type ( varying_string ), intent ( in ) :: string_b logical :: less_than_or_equals less_than_or_equals = lle ( char ( string_a ), char ( string_b )) end function elemental function character_lle_string ( string_a , string_b ) result ( less_than_or_equals ) ! Sec 3.4.11 character ( len =* ), intent ( in ) :: string_a type ( varying_string ), intent ( in ) :: string_b logical :: less_than_or_equals less_than_or_equals = lle ( string_a , char ( string_b )) end function elemental function string_lle_character ( string_a , string_b ) result ( less_than_or_equals ) ! Sec 3.4.11 type ( varying_string ), intent ( in ) :: string_a character ( len =* ), intent ( in ) :: string_b logical :: less_than_or_equals less_than_or_equals = lle ( char ( string_a ), string_b ) end function elemental function string_llt_string ( string_a , string_b ) result ( less_than ) ! Sec 3.4.12 type ( varying_string ), intent ( in ) :: string_a type ( varying_string ), intent ( in ) :: string_b logical :: less_than less_than = llt ( char ( string_a ), char ( string_b )) end function elemental function character_llt_string ( string_a , string_b ) result ( less_than ) ! Sec 3.4.12 character ( len =* ), intent ( in ) :: string_a type ( varying_string ), intent ( in ) :: string_b logical :: less_than less_than = llt ( string_a , char ( string_b )) end function elemental function string_llt_character ( string_a , string_b ) result ( less_than ) ! Sec 3.4.12 type ( varying_string ), intent ( in ) :: string_a character ( len =* ), intent ( in ) :: string_b logical :: less_than less_than = llt ( char ( string_a ), string_b ) end function elemental function string_repeat ( string , ncopies ) result ( repeated ) ! Sec. 3.4.13 type ( varying_string ), intent ( in ) :: string integer , intent ( in ) :: ncopies type ( varying_string ) :: repeated repeated = repeat ( char ( string ), ncopies ) end function elemental function string_scan_string ( string , set , back ) result ( position ) ! Sec. 3.4.14 type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: set logical , optional , intent ( in ) :: back integer :: position position = scan ( char ( string ), char ( set ), back ) end function elemental function string_scan_character ( string , set , back ) result ( position ) ! Sec. 3.4.14 type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set logical , optional , intent ( in ) :: back integer :: position position = scan ( char ( string ), set , back ) end function elemental function character_scan_string ( string , set , back ) result ( position ) ! Sec. 3.4.14 character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: set logical , optional , intent ( in ) :: back integer :: position position = scan ( string , char ( set ), back ) end function elemental function trim_string ( string ) result ( trimmed ) ! Sec. 3.4.15 type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: trimmed trimmed = trim ( char ( string )) end function elemental function string_verify_string ( string , set , back ) result ( position ) ! Sec. 3.5.16 type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: set logical , optional , intent ( in ) :: back integer :: position position = verify ( char ( string ), char ( set ), back ) end function elemental function string_verify_character ( string , set , back ) result ( position ) ! Sec. 3.5.16 type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set logical , optional , intent ( in ) :: back integer :: position position = verify ( char ( string ), set , back ) end function elemental function character_verify_string ( string , set , back ) result ( position ) ! Sec. 3.5.16 character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: set logical , optional , intent ( in ) :: back integer :: position position = verify ( string , char ( set ), back ) end function elemental function var_str ( char ) ! Sec. 3.5.1 character ( len =* ), intent ( in ) :: char type ( varying_string ) :: var_str var_str = char end function subroutine get_default_unit_to_end_of_record ( string , maxlen , iostat ) ! Sec. 3.6.1 type ( varying_string ), intent ( out ) :: string integer , optional , intent ( in ) :: maxlen integer , optional , intent ( out ) :: iostat integer , parameter :: BUFFER_SIZE = 100 character ( len = BUFFER_SIZE ) :: buffer integer :: next_read_length integer :: num_read integer :: num_to_read if ( present ( maxlen )) then num_to_read = maxlen else num_to_read = huge ( 1 ) end if string = \"\" if ( present ( iostat )) then do if ( num_to_read <= 0 ) exit next_read_length = min ( BUFFER_SIZE , num_to_read ) read ( * , fmt = '(A)' , advance = 'NO' , eor = 9999 , size = num_read , iostat = iostat ) buffer ( 1 : next_read_length ) if ( iostat /= 0 ) return string = string // buffer ( 1 : next_read_length ) num_to_read = num_to_read - next_read_length end do else do if ( num_to_read <= 0 ) exit next_read_length = min ( BUFFER_SIZE , num_to_read ) read ( * , fmt = '(A)' , advance = 'NO' , eor = 9999 , size = num_read ) buffer ( 1 : next_read_length ) string = string // buffer ( 1 : next_read_length ) num_to_read = num_to_read - next_read_length end do end if return 9999 string = string // buffer ( 1 : num_read ) end subroutine subroutine get_with_unit_to_end_of_record ( unit , string , maxlen , iostat ) ! Sec. 3.6.1 integer , intent ( in ) :: unit type ( varying_string ), intent ( out ) :: string integer , optional , intent ( in ) :: maxlen integer , optional , intent ( out ) :: iostat integer , parameter :: BUFFER_SIZE = 100 character ( len = BUFFER_SIZE ) :: buffer integer :: next_read_length integer :: num_read integer :: num_to_read if ( present ( maxlen )) then num_to_read = maxlen else num_to_read = huge ( 1 ) end if string = \"\" if ( present ( iostat )) then do if ( num_to_read <= 0 ) exit next_read_length = min ( BUFFER_SIZE , num_to_read ) read ( unit , fmt = '(A)' , advance = 'NO' , eor = 9999 , size = num_read , iostat = iostat ) buffer ( 1 : next_read_length ) if ( iostat /= 0 ) return string = string // buffer ( 1 : next_read_length ) num_to_read = num_to_read - next_read_length end do else do if ( num_to_read <= 0 ) exit next_read_length = min ( BUFFER_SIZE , num_to_read ) read ( unit , fmt = '(A)' , advance = 'NO' , eor = 9999 , size = num_read ) buffer ( 1 : next_read_length ) string = string // buffer ( 1 : next_read_length ) num_to_read = num_to_read - next_read_length end do end if return 9999 string = string // buffer ( 1 : num_read ) end subroutine subroutine get_default_unit_to_terminator_string ( string , set , separator , maxlen , iostat ) ! Sec. 3.6.1 type ( varying_string ), intent ( out ) :: string type ( varying_string ), intent ( in ) :: set ! possible terminator characters type ( varying_string ), optional , intent ( out ) :: separator ! actual terminator integer , optional , intent ( in ) :: maxlen integer , optional , intent ( out ) :: iostat call get ( string , char ( set ), separator , maxlen , iostat ) end subroutine subroutine get_with_unit_to_terminator_string ( unit , string , set , separator , maxlen , iostat ) ! Sec. 3.6.1 integer , intent ( in ) :: unit type ( varying_string ), intent ( out ) :: string type ( varying_string ), intent ( in ) :: set ! possible terminator characters type ( varying_string ), optional , intent ( out ) :: separator ! actual terminator integer , optional , intent ( in ) :: maxlen integer , optional , intent ( out ) :: iostat call get ( unit , string , char ( set ), separator , maxlen , iostat ) end subroutine subroutine get_default_unit_to_terminator_characters ( string , set , separator , maxlen , iostat ) ! Sec. 3.6.1 type ( varying_string ), intent ( out ) :: string character ( len =* ), intent ( in ) :: set ! possible terminator characters type ( varying_string ), optional , intent ( out ) :: separator ! actual terminator integer , optional , intent ( in ) :: maxlen integer , optional , intent ( out ) :: iostat character ( len = 1 ) :: buffer integer :: num_to_read if ( present ( maxlen )) then num_to_read = maxlen else num_to_read = huge ( 1 ) end if string = \"\" if ( present ( separator )) separator = \"\" if ( present ( iostat )) then do if ( num_to_read <= 0 ) exit read ( * , fmt = '(A)' , advance = 'NO' , eor = 9999 , iostat = iostat ) buffer if ( iostat /= 0 ) return if ( index ( set , buffer ) /= 0 ) then if ( present ( separator )) separator = buffer return end if string = string // buffer num_to_read = num_to_read - 1 end do else do if ( num_to_read <= 0 ) exit read ( * , fmt = '(A)' , advance = 'NO' , eor = 9999 ) buffer if ( index ( set , buffer ) /= 0 ) then if ( present ( separator )) separator = buffer return end if string = string // buffer num_to_read = num_to_read - 1 end do end if 9999 continue end subroutine subroutine get_with_unit_to_terminator_characters ( unit , string , set , separator , maxlen , iostat ) ! Sec. 3.6.1 integer , intent ( in ) :: unit type ( varying_string ), intent ( out ) :: string character ( len =* ), intent ( in ) :: set ! possible terminator characters type ( varying_string ), optional , intent ( out ) :: separator ! actual terminator integer , optional , intent ( in ) :: maxlen integer , optional , intent ( out ) :: iostat character ( len = 1 ) :: buffer integer :: num_to_read if ( present ( maxlen )) then num_to_read = maxlen else num_to_read = huge ( 1 ) end if string = \"\" if ( present ( separator )) separator = \"\" if ( present ( iostat )) then do if ( num_to_read <= 0 ) exit read ( unit , fmt = '(A)' , advance = 'NO' , eor = 9999 , iostat = iostat ) buffer if ( iostat /= 0 ) return if ( index ( set , buffer ) /= 0 ) then if ( present ( separator )) separator = buffer return end if string = string // buffer num_to_read = num_to_read - 1 end do else do if ( num_to_read <= 0 ) exit read ( unit , fmt = '(A)' , advance = 'NO' , eor = 9999 ) buffer if ( index ( set , buffer ) /= 0 ) then if ( present ( separator )) separator = buffer return end if string = string // buffer num_to_read = num_to_read - 1 end do end if 9999 continue end subroutine subroutine put_string_default_unit ( string , iostat ) ! Sec. 3.6.2 type ( varying_string ), intent ( in ) :: string integer , optional , intent ( out ) :: iostat call put ( char ( string ), iostat ) end subroutine subroutine put_string_with_unit ( unit , string , iostat ) ! Sec. 3.6.2 integer , intent ( in ) :: unit type ( varying_string ), intent ( in ) :: string integer , optional , intent ( out ) :: iostat call put ( unit , char ( string ), iostat ) end subroutine subroutine put_characters_default_unit ( string , iostat ) ! Sec. 3.6.2 character ( len =* ), intent ( in ) :: string integer , optional , intent ( out ) :: iostat if ( present ( iostat )) then write ( * , fmt = '(A)' , advance = 'NO' , iostat = iostat ) string else write ( * , fmt = '(A)' , advance = 'NO' ) string end if end subroutine subroutine put_characters_with_unit ( unit , string , iostat ) ! Sec. 3.6.2 integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: string integer , optional , intent ( out ) :: iostat if ( present ( iostat )) then write ( unit , fmt = '(A)' , advance = 'NO' , iostat = iostat ) string else write ( unit , fmt = '(A)' , advance = 'NO' ) string end if end subroutine subroutine put_line_string_default_unit ( string , iostat ) ! Sec. 3.6.3 type ( varying_string ), intent ( in ) :: string integer , optional , intent ( out ) :: iostat call put_line ( char ( string ), iostat ) end subroutine subroutine put_line_string_with_unit ( unit , string , iostat ) ! Sec. 3.6.3 integer , intent ( in ) :: unit type ( varying_string ), intent ( in ) :: string integer , optional , intent ( out ) :: iostat call put_line ( unit , char ( string ), iostat ) end subroutine subroutine put_line_characters_default_unit ( string , iostat ) ! Sec. 3.6.3 character ( len =* ), intent ( in ) :: string integer , optional , intent ( out ) :: iostat if ( present ( iostat )) then write ( * , fmt = '(A,/)' , advance = 'NO' , iostat = iostat ) string else write ( * , fmt = '(A,/)' , advance = 'NO' ) string end if end subroutine subroutine put_line_characters_with_unit ( unit , string , iostat ) ! Sec. 3.6.3 integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: string integer , optional , intent ( out ) :: iostat if ( present ( iostat )) then write ( unit , fmt = '(A,/)' , advance = 'NO' , iostat = iostat ) string else write ( unit , fmt = '(A,/)' , advance = 'NO' ) string end if end subroutine elemental function extract_character ( string , start , finish ) result ( extracted ) ! Sec. 3.7.1 character ( len =* ), intent ( in ) :: string integer , optional , intent ( in ) :: start integer , optional , intent ( in ) :: finish type ( varying_string ) :: extracted integer :: start_ integer :: finish_ if ( present ( start )) then start_ = max ( 1 , start ) else start_ = 1 end if if ( present ( finish )) then finish_ = min ( len ( string ), finish ) else finish_ = len ( string ) end if extracted = string ( start_ : finish_ ) end function elemental function extract_string ( string , start , finish ) result ( extracted ) ! Sec. 3.7.1 type ( varying_string ), intent ( in ) :: string integer , optional , intent ( in ) :: start integer , optional , intent ( in ) :: finish type ( varying_string ) :: extracted extracted = extract ( char ( string ), start , finish ) end function elemental function insert_character_into_character ( string , start , substring ) result ( inserted ) ! Sec. 3.7.2 character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: start character ( len =* ), intent ( in ) :: substring type ( varying_string ) :: inserted type ( varying_string ) :: beginning type ( varying_string ) :: middle type ( varying_string ) :: end_ if ( start <= 1 ) then beginning = substring middle = string end_ = \"\" else if ( start > len ( string )) then beginning = string middle = substring end_ = \"\" else beginning = string ( 1 : start - 1 ) middle = substring end_ = string ( start :) end if inserted = beginning // middle // end_ end function elemental function insert_character_into_string ( string , start , substring ) result ( inserted ) ! Sec. 3.7.2 type ( varying_string ), intent ( in ) :: string integer , intent ( in ) :: start character ( len =* ), intent ( in ) :: substring type ( varying_string ) :: inserted inserted = insert ( char ( string ), start , substring ) end function elemental function insert_string_into_character ( string , start , substring ) result ( inserted ) ! Sec. 3.7.2 character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: start type ( varying_string ), intent ( in ) :: substring type ( varying_string ) :: inserted inserted = insert ( string , start , char ( substring )) end function elemental function insert_string_into_string ( string , start , substring ) result ( inserted ) ! Sec. 3.7.2 type ( varying_string ), intent ( in ) :: string integer , intent ( in ) :: start type ( varying_string ), intent ( in ) :: substring type ( varying_string ) :: inserted inserted = insert ( char ( string ), start , char ( substring )) end function elemental function remove_character ( string , start , finish ) result ( removed ) ! Sec. 3.7.3 character ( len =* ), intent ( in ) :: string integer , optional , intent ( in ) :: start integer , optional , intent ( in ) :: finish type ( varying_string ) :: removed integer :: start_ integer :: finish_ type ( varying_string ) :: beginning type ( varying_string ) :: end_ if ( present ( start )) then start_ = start else start_ = 1 end if if ( present ( finish )) then finish_ = finish else finish_ = len ( string ) end if if ( start_ > finish_ ) then removed = string else beginning = string ( 1 : start_ - 1 ) end_ = string ( finish_ + 1 : len ( string )) removed = beginning // end_ end if end function elemental function remove_string ( string , start , finish ) result ( removed ) ! Sec. 3.7.3 type ( varying_string ), intent ( in ) :: string integer , optional , intent ( in ) :: start integer , optional , intent ( in ) :: finish type ( varying_string ) :: removed removed = remove ( char ( string ), start , finish ) end function elemental function replace_character_with_character_start ( & string , start , substring ) result ( replaced ) ! Sec. 3.7.4 character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: start character ( len =* ), intent ( in ) :: substring type ( varying_string ) :: replaced integer :: start_ start_ = max ( 1 , start ) replaced = insert ( & remove ( string , start_ , start_ + len ( substring ) - 1 ), & start_ , & substring ) end function elemental function replace_string_with_character_start ( & string , start , substring ) result ( replaced ) ! Sec. 3.7.4 type ( varying_string ), intent ( in ) :: string integer , intent ( in ) :: start character ( len =* ), intent ( in ) :: substring type ( varying_string ) :: replaced replaced = replace ( char ( string ), start , substring ) end function elemental function replace_character_with_string_start ( & string , start , substring ) result ( replaced ) ! Sec. 3.7.4 character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: start type ( varying_string ), intent ( in ) :: substring type ( varying_string ) :: replaced replaced = replace ( string , start , char ( substring )) end function elemental function replace_string_with_string_start ( & string , start , substring ) result ( replaced ) ! Sec. 3.7.4 type ( varying_string ), intent ( in ) :: string integer , intent ( in ) :: start type ( varying_string ), intent ( in ) :: substring type ( varying_string ) :: replaced replaced = replace ( char ( string ), start , char ( substring )) end function elemental function replace_character_with_character_range ( & string , start , finish , substring ) result ( replaced ) ! Sec. 3.7.4 character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: start integer , intent ( in ) :: finish character ( len =* ), intent ( in ) :: substring type ( varying_string ) :: replaced type ( varying_string ) :: beginning type ( varying_string ) :: ending beginning = string ( 1 : start - 1 ) ending = string ( max ( finish + 1 , start ) : ) replaced = beginning // substring // ending end function elemental function replace_string_with_character_range ( & string , start , finish , substring ) result ( replaced ) ! Sec. 3.7.4 type ( varying_string ), intent ( in ) :: string integer , intent ( in ) :: start integer , intent ( in ) :: finish character ( len =* ), intent ( in ) :: substring type ( varying_string ) :: replaced replaced = replace ( char ( string ), start , finish , substring ) end function elemental function replace_character_with_string_range ( & string , start , finish , substring ) result ( replaced ) ! Sec. 3.7.4 character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: start integer , intent ( in ) :: finish type ( varying_string ), intent ( in ) :: substring type ( varying_string ) :: replaced replaced = replace ( string , start , finish , char ( substring )) end function elemental function replace_string_with_string_range ( & string , start , finish , substring ) result ( replaced ) ! Sec. 3.7.4 type ( varying_string ), intent ( in ) :: string integer , intent ( in ) :: start integer , intent ( in ) :: finish type ( varying_string ), intent ( in ) :: substring type ( varying_string ) :: replaced replaced = replace ( char ( string ), start , finish , char ( substring )) end function elemental function replace_target_character_with_character_in_character ( & string , target , substring , every , back ) result ( replaced ) ! Sec. 3.7.4 character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: target character ( len =* ), intent ( in ) :: substring logical , optional , intent ( in ) :: every logical , optional , intent ( in ) :: back type ( varying_string ) :: replaced logical :: back_ logical :: every_ if ( present ( back )) then back_ = back else back_ = . false . end if if ( present ( every )) then every_ = every else every_ = . false . end if replaced = recursive_replace ( string ) contains pure recursive function recursive_replace ( string_ ) result ( replaced_ ) character ( len =* ), intent ( in ) :: string_ type ( varying_string ) :: replaced_ integer :: position position = index ( string_ , target , back_ ) if ( position /= 0 ) then if ( every_ ) then if ( back_ ) then replaced_ = & recursive_replace ( string_ ( 1 : position - 1 )) & // substring & // string_ ( position + len ( target ):) else replaced_ = & string_ ( 1 : position - 1 ) & // substring & // recursive_replace ( string_ ( position + len ( target ):)) end if else replaced_ = replace ( & string_ , position , position + len ( target ) - 1 , substring ) end if else replaced_ = string_ end if end function end function replace_target_character_with_character_in_character elemental function replace_target_character_with_character_in_string ( & string , target , substring , every , back ) result ( replaced ) ! Sec. 3.7.4 type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: target character ( len =* ), intent ( in ) :: substring logical , optional , intent ( in ) :: every logical , optional , intent ( in ) :: back type ( varying_string ) :: replaced replaced = replace ( char ( string ), target , substring , every , back ) end function elemental function replace_target_character_with_string_in_character ( & string , target , substring , every , back ) result ( replaced ) ! Sec. 3.7.4 character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: target type ( varying_string ), intent ( in ) :: substring logical , optional , intent ( in ) :: every logical , optional , intent ( in ) :: back type ( varying_string ) :: replaced replaced = replace ( string , target , char ( substring ), every , back ) end function elemental function replace_target_character_with_string_in_string ( & string , target , substring , every , back ) result ( replaced ) ! Sec. 3.7.4 type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: target type ( varying_string ), intent ( in ) :: substring logical , optional , intent ( in ) :: every logical , optional , intent ( in ) :: back type ( varying_string ) :: replaced replaced = replace ( char ( string ), target , char ( substring ), every , back ) end function elemental function replace_target_string_with_character_in_character ( & string , target , substring , every , back ) result ( replaced ) ! Sec. 3.7.4 character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: target character ( len =* ), intent ( in ) :: substring logical , optional , intent ( in ) :: every logical , optional , intent ( in ) :: back type ( varying_string ) :: replaced replaced = replace ( string , char ( target ), substring , every , back ) end function elemental function replace_target_string_with_character_in_string ( & string , target , substring , every , back ) result ( replaced ) ! Sec. 3.7.4 type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: target character ( len =* ), intent ( in ) :: substring logical , optional , intent ( in ) :: every logical , optional , intent ( in ) :: back type ( varying_string ) :: replaced replaced = replace ( char ( string ), char ( target ), substring , every , back ) end function elemental function replace_target_string_with_string_in_character ( & string , target , substring , every , back ) result ( replaced ) ! Sec. 3.7.4 character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: target type ( varying_string ), intent ( in ) :: substring logical , optional , intent ( in ) :: every logical , optional , intent ( in ) :: back type ( varying_string ) :: replaced replaced = replace ( string , char ( target ), char ( substring ), every , back ) end function elemental function replace_target_string_with_string_in_string ( & string , target , substring , every , back ) result ( replaced ) ! Sec. 3.7.4 type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: target type ( varying_string ), intent ( in ) :: substring logical , optional , intent ( in ) :: every logical , optional , intent ( in ) :: back type ( varying_string ) :: replaced replaced = replace ( char ( string ), char ( target ), char ( substring ), every , back ) end function elemental subroutine split_character ( string , word , set , separator , back ) ! Sec. 3.7.5 type ( varying_string ), intent ( inout ) :: string type ( varying_string ), intent ( out ) :: word character ( len =* ), intent ( in ) :: set type ( varying_string ), optional , intent ( out ) :: separator logical , optional , intent ( in ) :: back logical :: backwards integer :: i integer :: string_length character ( len = :), allocatable :: temp allocate ( character ( len = 0 ) :: temp ) ! TODO: remove once gfortran bug is fixed string_length = len ( string ) if ( present ( back )) then backwards = back else backwards = . false . end if if ( backwards ) then do i = string_length , 1 , - 1 if ( index ( set , extract ( string , i , i )) /= 0 ) exit end do if ( i < 1 ) then word = string string = \"\" if ( present ( separator )) separator = \"\" else word = extract ( string , i + 1 ) temp = char ( extract ( string , 1 , i - 1 )) if ( present ( separator )) separator = extract ( string , i , i ) string = temp end if else do i = 1 , string_length if ( index ( set , extract ( string , i , i )) /= 0 ) exit end do if ( i > string_length ) then word = string string = \"\" if ( present ( separator )) separator = \"\" else word = extract ( string , 1 , i - 1 ) temp = char ( extract ( string , i + 1 )) if ( present ( separator )) separator = extract ( string , i , i ) string = temp end if end if end subroutine elemental subroutine split_string ( string , word , set , separator , back ) ! Sec. 3.7.5 type ( varying_string ), intent ( inout ) :: string type ( varying_string ), intent ( out ) :: word type ( varying_string ), intent ( in ) :: set type ( varying_string ), optional , intent ( out ) :: separator logical , optional , intent ( in ) :: back call split ( string , word , char ( set ), separator , back ) end subroutine end module","tags":"","loc":"sourcefile/iso_varying_string.f90.html","title":"ISO_VARYING_STRING.f90 – miniFAVOR"},{"text":"Contents Programs make_vegetable_driver Source Code main.f90 Source Code program make_vegetable_driver use iso_varying_string , only : varying_string , assignment ( = ) use make_driver_m , only : make_driver implicit none character ( len = 1000 ) :: argument type ( varying_string ) :: driver_file integer :: i integer :: num_arguments character ( len = 100 ) :: program_name type ( varying_string ), allocatable :: test_files (:) num_arguments = command_argument_count () if ( num_arguments < 2 ) then call get_command_argument ( 0 , program_name ) print * , \"Usage: \" // trim ( program_name ) // \" driver_name test_file [more [test [files [...]]]]\" error stop else allocate ( test_files ( num_arguments - 1 )) call get_command_argument ( 1 , argument ) driver_file = trim ( argument ) do i = 1 , num_arguments - 1 call get_command_argument ( i + 1 , argument ) test_files ( i ) = trim ( argument ) end do end if call make_driver ( driver_file , test_files ) end program","tags":"","loc":"sourcefile/main.f90~12.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Modules make_driver_m Source Code make_driver_m.f90 Source Code module make_driver_m use iso_varying_string , only : varying_string implicit none private public :: make_driver type :: test_info_t type ( varying_string ) :: module_name type ( varying_string ), allocatable :: function_names (:) end type contains subroutine make_driver ( driver_file , test_files ) use iso_varying_string , only : varying_string , char , put type ( varying_string ), intent ( in ) :: driver_file type ( varying_string ), intent ( in ) :: test_files (:) integer :: file_unit type ( varying_string ) :: program_ type ( test_info_t ) :: test_infos ( size ( test_files )) call get_test_info ( test_files , test_infos ) program_ = make_program ( take_file_name ( drop_extension ( driver_file )), test_infos ) open ( newunit = file_unit , file = char ( driver_file ), action = \"WRITE\" , status = \"REPLACE\" ) call put ( file_unit , program_ ) close ( file_unit ) end subroutine subroutine get_test_info ( filenames , test_infos ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: filenames (:) type ( test_info_t ), intent ( out ) :: test_infos ( size ( filenames )) integer :: i do i = 1 , size ( filenames ) call get_individual_test_info ( filenames ( i ), test_infos ( i )) end do end subroutine subroutine get_individual_test_info ( filename , test_info ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: filename type ( test_info_t ), intent ( out ) :: test_info test_info % module_name = take_file_name ( drop_extension ( filename )) call scan_test_file ( filename , test_info % function_names ) end subroutine pure function take_file_name ( filename ) result ( just_file ) use iso_varying_string , only : varying_string , extract , index type ( varying_string ), intent ( in ) :: filename type ( varying_string ) :: just_file just_file = extract ( filename , start = index ( filename , \"/\" , back = . true .) + 1 ) end function pure function drop_extension ( filename ) result ( without_extension ) use iso_varying_string , only : varying_string , extract , index type ( varying_string ), intent ( in ) :: filename type ( varying_string ) :: without_extension integer :: slash_position integer :: dot_position slash_position = index ( filename , \"/\" , back = . true .) dot_position = index ( filename , \".\" , back = . true .) if ( dot_position <= slash_position ) then without_extension = filename else without_extension = extract ( filename , finish = dot_position - 1 ) end if end function subroutine scan_test_file ( filename , function_names ) use iso_varying_string , only : varying_string use parff , only : parse_result_t , parsed_string_t use strff , only : read_file_lines type ( varying_string ), intent ( in ) :: filename type ( varying_string ), allocatable , intent ( out ) :: function_names (:) logical , allocatable :: function_mask (:) type ( parse_result_t ), allocatable :: function_name_results (:) integer :: i type ( varying_string ), allocatable :: lines (:) type ( parse_result_t ), allocatable :: maybe_function_names (:) integer :: num_function_names allocate ( lines ( 0 )) lines = read_file_lines ( filename ) allocate ( maybe_function_names ( size ( lines ))) maybe_function_names = parse_line ( lines ) num_function_names = count ( maybe_function_names % ok ) allocate ( function_name_results ( num_function_names )) allocate ( function_mask ( size ( lines ))) function_mask = maybe_function_names % ok function_name_results = pack ( maybe_function_names , function_mask ) allocate ( function_names ( num_function_names )) do i = 1 , num_function_names select type ( name => function_name_results ( i )% parsed ) type is ( parsed_string_t ) function_names ( i ) = name % value_ end select end do end subroutine elemental function parse_line ( line ) result ( maybe_name ) use iso_varying_string , only : varying_string use parff , only : parse_result_t , parse_with type ( varying_string ), intent ( in ) :: line type ( parse_result_t ) :: maybe_name maybe_name = parse_with ( parse_test_function_name , line ) end function pure function parse_test_function_name ( the_state ) result ( the_result ) use iso_varying_string , only : var_str use parff , only : & parsed_string_t , & parser_output_t , & state_t , & drop_then , & empty_error , & message , & then_drop use strff , only : operator (. startswith .) type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = then_drop ( & drop_then ( & drop_then ( & drop_then ( parse_at_least_one_white_space , parse_function , the_state ), & parse_at_least_one_white_space ), & parse_valid_identifier ), & parse_space_or_open_paren ) if ( the_result % ok ) then select type ( the_name => the_result % parsed ) type is ( parsed_string_t ) if (. not . ( the_name % value_ . startswith . \"test_\" )) then the_result = empty_error ( message ( & the_state % position , the_name % value_ , [ var_str ( \"test_*\" )])) end if end select end if end function pure function parse_function ( the_state ) result ( the_result ) use parff , only : parser_output_t , state_t , parse_string type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = parse_string ( \"function\" , the_state ) end function pure function parse_space_or_open_paren ( the_state ) result ( the_result ) use parff , only : parser_output_t , state_t , either type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = either ( parse_at_least_one_white_space , parse_open_paren , the_state ) end function pure function parse_open_paren ( the_state ) result ( the_result ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = parse_char ( \"(\" , the_state ) end function pure function parse_at_least_one_white_space ( the_state ) result ( the_result ) use parff , only : parser_output_t , state_t , many1 type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = many1 ( parse_white_space , the_state ) end function pure function parse_valid_identifier ( the_state ) result ( the_result ) use parff , only : parser_output_t , state_t , sequence type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = sequence ( & parse_valid_first_character , & then_parse_valid_identifiers , & the_state ) contains pure function then_parse_valid_identifiers ( previous , state_ ) result ( result_ ) use iso_varying_string , only : assignment ( = ), operator ( // ), var_str use parff , only : & parsed_character_t , & parsed_items_t , & parsed_string_t , & parsed_value_t , & parser_output_t , & state_t , & consumed_ok , & many , & message class ( parsed_value_t ), intent ( in ) :: previous type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ integer :: i type ( parsed_string_t ) :: parsed_identifier select type ( previous ) type is ( parsed_character_t ) parsed_identifier % value_ = previous % value_ result_ = many ( parse_valid_identifier_character , state_ ) if ( result_ % empty ) then result_ = consumed_ok ( & parsed_identifier , & state_ % input , & state_ % position , & message ( & state_ % position , & var_str ( \"\" ), & [ varying_string :: ])) else select type ( results => result_ % parsed ) type is ( parsed_items_t ) do i = 1 , size ( results % items ) select type ( next_char => results % items ( i )% item ) type is ( parsed_character_t ) parsed_identifier % value_ = & parsed_identifier % value_ & // next_char % value_ end select end do end select deallocate ( result_ % parsed ) allocate ( result_ % parsed , source = parsed_identifier ) end if end select end function end function pure function parse_valid_first_character ( the_state ) result ( the_result ) use parff , only : parser_output_t , state_t type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = parse_alphabet ( the_state ) end function pure function parse_valid_identifier_character ( the_state ) result ( the_result ) use parff , only : parser_output_t , state_t , either type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = either ( parse_alphabet , parse_non_letter , the_state ) contains pure function parse_non_letter ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , parse_digit type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = either ( parse_digit , parse_underscore , state_ ) end function end function pure function parse_alphabet ( the_state ) result ( the_result ) use parff , only : parser_output_t , state_t , with_label type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = with_label ( \"letter\" , the_parser , the_state ) contains pure function the_parser ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , satisfy type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = satisfy ( the_matcher , state_ ) end function pure function the_matcher ( char_ ) result ( matches ) use strff , only : operator (. includes .) character ( len = 1 ), intent ( in ) :: char_ logical :: matches character ( len =* ), parameter :: LETTER = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" matches = LETTER . includes . char_ end function end function pure function parse_underscore ( the_state ) result ( the_result ) use parff , only : parser_output_t , state_t , parse_char type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = parse_char ( \"_\" , the_state ) end function pure function parse_white_space ( the_state ) result ( the_result ) use parff , only : parser_output_t , state_t , with_label type ( state_t ), intent ( in ) :: the_state type ( parser_output_t ) :: the_result the_result = with_label ( \"whitespace\" , the_parser , the_state ) contains pure function the_parser ( state_ ) result ( result_ ) use parff , only : parser_output_t , state_t , satisfy type ( state_t ), intent ( in ) :: state_ type ( parser_output_t ) :: result_ result_ = satisfy ( the_matcher , state_ ) end function pure function the_matcher ( char_ ) result ( matches ) use strff , only : operator (. includes .) character ( len = 1 ), intent ( in ) :: char_ logical :: matches character ( len = 1 ), parameter :: TAB = char ( 9 ) character ( len = 1 ), parameter :: SPACE = char ( 32 ) character ( len =* ), parameter :: WHITESPACE = TAB // SPACE matches = WHITESPACE . includes . char_ end function end function pure function make_program ( driver_name , test_infos ) result ( program_ ) use iso_varying_string , only : varying_string , operator ( // ), var_str use strff , only : join , NEWLINE type ( varying_string ), intent ( in ) :: driver_name type ( test_info_t ), intent ( in ) :: test_infos (:) type ( varying_string ) :: program_ type ( varying_string ), allocatable :: test_array (:) type ( varying_string ) :: use_statements ( size ( test_infos )) call make_test_array ( test_infos , test_array ) use_statements = make_use_statements ( test_infos ) program_ = join ( & [ var_str ( \"! Generated by make_vegetable_driver. DO NOT EDIT\" ), & \"program \" // driver_name , & var_str ( \"    implicit none\" ), & var_str ( \"\" ), & var_str ( \"    call run()\" ), & var_str ( \"contains\" ), & var_str ( \"    subroutine run()\" ), & use_statements , & var_str ( \"        use vegetables, only: test_item_t, test_that, run_tests\" ), & var_str ( \"\" ), & var_str ( \"        type(test_item_t) :: tests\" ), & test_array , & var_str ( \"\" ), & var_str ( \"        call run_tests(tests)\" ), & var_str ( \"    end subroutine\" ), & var_str ( \"end program\" )], & NEWLINE ) end function pure function make_use_statements ( test_infos ) result ( use_statements ) use iso_varying_string , only : varying_string type ( test_info_t ), intent ( in ) :: test_infos (:) type ( varying_string ) :: use_statements ( size ( test_infos )) integer :: i do i = 1 , size ( test_infos ) use_statements ( i ) = make_use_statement ( test_infos ( i )) end do end function pure function make_use_statement ( test_info ) result ( use_statement ) use iso_varying_string , only : varying_string , assignment ( = ), operator ( // ) use strff , only : join , NEWLINE type ( test_info_t ), intent ( in ) :: test_info type ( varying_string ) :: use_statement type ( varying_string ) :: functions_part integer :: i type ( varying_string ) :: renamed_functions ( size ( test_info % function_names )) if ( size ( test_info % function_names ) == 0 ) then use_statement = \"\" else do i = 1 , size ( test_info % function_names ) renamed_functions ( i ) = & \"                \" & // rename_ ( test_info % module_name , test_info % function_names ( i )) & // \" => \" // test_info % function_names ( i ) end do functions_part = join ( renamed_functions , \", &\" // NEWLINE ) use_statement = & \"        use \" // test_info % module_name // \", only: &\" // NEWLINE & // functions_part end if end function pure function rename_ ( module_name , function_name ) result ( renamed ) use iso_varying_string , only : varying_string , operator ( // ), replace type ( varying_string ), intent ( in ) :: module_name type ( varying_string ), intent ( in ) :: function_name type ( varying_string ) :: renamed renamed = replace ( module_name // \"_\" // function_name , \"test_test_\" , \"\" ) end function pure subroutine make_test_array ( test_infos , test_array ) use iso_varying_string , only : varying_string , assignment ( = ), operator ( // ) use strff , only : to_string type ( test_info_t ), intent ( in ) :: test_infos (:) type ( varying_string ), allocatable , intent ( out ) :: test_array (:) integer :: i , j , next_entry integer :: num_individual_tests num_individual_tests = sum ([( size ( test_infos ( i )% function_names ), i = 1 , size ( test_infos ))]) allocate ( test_array ( num_individual_tests + 3 )) test_array ( 1 ) = & \"        type(test_item_t) :: individual_tests(\" & // to_string ( num_individual_tests ) // \")\" test_array ( 2 ) = \"\" next_entry = 3 do i = 1 , size ( test_infos ) do j = 1 , size ( test_infos ( i )% function_names ) test_array ( next_entry ) = & \"        individual_tests(\" // to_string ( next_entry - 2 ) // \") = \" & // rename_ ( test_infos ( i )% module_name , test_infos ( i )% function_names ( j )) & // \"()\" next_entry = next_entry + 1 end do end do test_array ( next_entry ) = \"        tests = test_that(individual_tests)\" end subroutine end module","tags":"","loc":"sourcefile/make_driver_m.f90.html","title":"make_driver_m.f90 – miniFAVOR"},{"text":"Contents Modules assert_equals_within_absolute_test Source Code assert_equals_within_absolute_test.f90 Source Code module assert_equals_within_absolute_test implicit none private public :: test_assert_equals_within_relative character ( len =* ), parameter :: BOTH_MESSAGE = \"Both Message\" character ( len =* ), parameter :: SUCCESS_MESSAGE = \"Success Message\" character ( len =* ), parameter :: FAILURE_MESSAGE = \"Failure Message\" contains function test_assert_equals_within_relative () result ( tests ) use double_precision_generator_m , only : DOUBLE_PRECISION_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"passes with the same number even with very small tolerance\" , & DOUBLE_PRECISION_GENERATOR , & check_pass_for_same_number ) individual_tests ( 2 ) = it ( & \"fails with sufficiently different numbers\" , & DOUBLE_PRECISION_GENERATOR , & check_fail_for_different_numbers ) individual_tests ( 3 ) = it ( & \"passes with sufficiently close numbers\" , & DOUBLE_PRECISION_GENERATOR , & check_pass_for_close_numbers ) tests = describe ( \"assert_equals_within_absolute\" , individual_tests ) end function pure function check_pass_for_same_number ( the_example ) result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : & double_precision_input_t , & input_t , & result_t , & assert_equals_within_absolute , & assert_that , & fail class ( input_t ), intent ( in ) :: the_example type ( result_t ) :: result_ double precision :: example type ( result_t ) :: example_result type ( result_t ) :: example_result_c type ( result_t ) :: example_result_s type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss select type ( the_example ) type is ( double_precision_input_t ) example = the_example % value_ example_result = assert_equals_within_absolute ( & example , example , tiny ( 0.0d0 )) example_result_c = assert_equals_within_absolute ( & example , example , tiny ( 0.0d0 ), BOTH_MESSAGE ) example_result_s = assert_equals_within_absolute ( & example , example , tiny ( 0.0d0 ), var_str ( BOTH_MESSAGE )) example_result_cc = assert_equals_within_absolute ( & example , & example , & tiny ( 0.0d0 ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cs = assert_equals_within_absolute ( & example , & example , & tiny ( 0.0d0 ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_sc = assert_equals_within_absolute ( & example , & example , & tiny ( 0.0d0 ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ss = assert_equals_within_absolute ( & example , & example , & tiny ( 0.0d0 ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) result_ = & assert_that ( & example_result % passed (), & example_result % verbose_description (. false .)) & . and . assert_that ( & example_result_c % passed (), & example_result_c % verbose_description (. false .)) & . and . assert_that ( & example_result_s % passed (), & example_result_s % verbose_description (. false .)) & . and . assert_that ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_that ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_that ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_that ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a double precision value\" ) end select end function pure function check_fail_for_different_numbers ( the_example ) result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : & double_precision_input_t , & input_t , & result_t , & assert_equals_within_absolute , & assert_not , & fail class ( input_t ), intent ( in ) :: the_example type ( result_t ) :: result_ double precision :: example type ( result_t ) :: example_result type ( result_t ) :: example_result_c type ( result_t ) :: example_result_s type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss select type ( the_example ) type is ( double_precision_input_t ) example = the_example % value_ example_result = assert_equals_within_absolute ( & example , example + 0.2d0 , 0.1d0 ) example_result_c = assert_equals_within_absolute ( & example , example + 0.2d0 , 0.1d0 , BOTH_MESSAGE ) example_result_s = assert_equals_within_absolute ( & example , example + 0.2d0 , 0.1d0 , var_str ( BOTH_MESSAGE )) example_result_cc = assert_equals_within_absolute ( & example , & example + 0.2d0 , & 0.1d0 , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cs = assert_equals_within_absolute ( & example , & example + 0.2d0 , & 0.1d0 , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_sc = assert_equals_within_absolute ( & example , & example + 0.2d0 , & 0.1d0 , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ss = assert_equals_within_absolute ( & example , & example + 0.2d0 , & 0.1d0 , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) result_ = & assert_not ( & example_result % passed (), & example_result % verbose_description (. false .)) & . and . assert_not ( & example_result_c % passed (), & example_result_c % verbose_description (. false .)) & . and . assert_not ( & example_result_s % passed (), & example_result_s % verbose_description (. false .)) & . and . assert_not ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_not ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_not ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_not ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a double precision value\" ) end select end function pure function check_pass_for_close_numbers ( the_example ) result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : & double_precision_input_t , & input_t , & result_t , & assert_equals_within_absolute , & assert_that , & fail class ( input_t ), intent ( in ) :: the_example type ( result_t ) :: result_ double precision :: example type ( result_t ) :: example_result type ( result_t ) :: example_result_c type ( result_t ) :: example_result_s type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss select type ( the_example ) type is ( double_precision_input_t ) example = the_example % value_ example_result = assert_equals_within_absolute ( & example , example + 0.05d0 , 0.1d0 ) example_result_c = assert_equals_within_absolute ( & example , example + 0.05d0 , 0.1d0 , BOTH_MESSAGE ) example_result_s = assert_equals_within_absolute ( & example , example + 0.05d0 , 0.1d0 , var_str ( BOTH_MESSAGE )) example_result_cc = assert_equals_within_absolute ( & example , & example + 0.05d0 , & 0.1d0 , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cs = assert_equals_within_absolute ( & example , & example + 0.05d0 , & 0.1d0 , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_sc = assert_equals_within_absolute ( & example , & example + 0.05d0 , & 0.1d0 , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ss = assert_equals_within_absolute ( & example , & example + 0.05d0 , & 0.1d0 , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) result_ = & assert_that ( & example_result % passed (), & example_result % verbose_description (. false .)) & . and . assert_that ( & example_result_c % passed (), & example_result_c % verbose_description (. false .)) & . and . assert_that ( & example_result_s % passed (), & example_result_s % verbose_description (. false .)) & . and . assert_that ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_that ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_that ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_that ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a double precision value\" ) end select end function end module","tags":"","loc":"sourcefile/assert_equals_within_absolute_test.f90.html","title":"assert_equals_within_absolute_test.f90 – miniFAVOR"},{"text":"Contents Modules failing_collection_test Source Code failing_collection_test.f90 Source Code module failing_collection_test implicit none private public :: test_failing_collection_behaviors contains function test_failing_collection_behaviors () result ( tests ) use example_collections_m , only : example_failing_collection use helpers_m , only : test_item_input_t , run_test use vegetables , only : test_item_t , given , then__ , when type ( test_item_t ) :: tests type ( test_item_t ) :: collection ( 1 ) type ( test_item_input_t ) :: the_collection type ( test_item_t ) :: individual_tests ( 15 ) the_collection % input = example_failing_collection () individual_tests ( 1 ) = then__ ( \"it knows it failed\" , check_collection_fails ) individual_tests ( 2 ) = then__ ( \"it knows how many cases there were\" , check_num_cases ) individual_tests ( 3 ) = then__ ( \"it knows how many cases failed\" , check_num_failing_cases ) individual_tests ( 4 ) = then__ ( \"it's verbose description includes the given description\" , check_verbose_top_description ) individual_tests ( 5 ) = then__ ( & \"it's verbose description includes the individual case descriptions\" , & check_verbose_case_descriptions ) individual_tests ( 6 ) = then__ ( \"it's verbose description includes the failure message\" , check_verbose_for_failure_message ) individual_tests ( 7 ) = then__ ( \"it's verbose description includes the success message\" , check_verbose_for_success_message ) individual_tests ( 8 ) = then__ ( \"it's failure description includes the given description\" , check_failure_for_top_description ) individual_tests ( 9 ) = then__ ( & \"it's failure description includes the failing case description\" , check_failure_case_description ) individual_tests ( 10 ) = then__ ( & \"it's failure description does not include the passing case descriptions\" , & check_failure_no_passing_descriptions ) individual_tests ( 11 ) = then__ ( \"it's failure description includes the failure message\" , check_failure_for_message ) individual_tests ( 12 ) = then__ ( & \"it's failure description does not include the success message\" , & check_failure_no_success_message ) individual_tests ( 13 ) = then__ ( \"it's failure description does not include blank lines\" , check_failure_no_blank_lines ) individual_tests ( 14 ) = then__ ( \"it knows how many asserts there were\" , check_num_asserts ) individual_tests ( 15 ) = then__ ( \"it knows how many asserts failed\" , check_num_failing_asserts ) collection ( 1 ) = when ( \"it is run\" , run_test , individual_tests ) tests = given ( \"a failing test collection\" , the_collection , collection ) end function pure function check_collection_fails ( example_results ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_not , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_not ( example_results % input % passed ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_cases ( example_results ) result ( result_ ) use example_collections_m , only : NUM_CASES_IN_FAILING use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_equals ( NUM_CASES_IN_FAILING , example_results % input % num_cases ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_failing_cases ( example_results ) result ( result_ ) use example_collections_m , only : NUM_FAILING_CASES use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_equals ( NUM_FAILING_CASES , example_results % input % num_failing_cases ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_verbose_top_description ( example_results ) result ( result_ ) use example_collections_m , only : EXAMPLE_COLLECTION_DESCRIPTION use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_includes ( & EXAMPLE_COLLECTION_DESCRIPTION , & example_results % input % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_verbose_case_descriptions ( example_results ) result ( result_ ) use example_collections_m , only : & EXAMPLE_CASE_DESCRIPTION_1 , & EXAMPLE_CASE_DESCRIPTION_2 , & EXAMPLE_FAILING_CASE_DESCRIPTION use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = & assert_includes ( & EXAMPLE_CASE_DESCRIPTION_1 , & example_results % input % verbose_description (. false .)) & . and . assert_includes ( & EXAMPLE_CASE_DESCRIPTION_2 , & example_results % input % verbose_description (. false .)) & . and . assert_includes ( & EXAMPLE_FAILING_CASE_DESCRIPTION , & example_results % input % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_verbose_for_failure_message ( example_results ) result ( result_ ) use example_collections_m , only : FAILURE_MESSAGE use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_includes ( & FAILURE_MESSAGE , & example_results % input % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_verbose_for_success_message ( example_results ) result ( result_ ) use example_asserts_m , only : SUCCESS_MESSAGE use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_includes ( & SUCCESS_MESSAGE , & example_results % input % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_failure_for_top_description ( example_results ) result ( result_ ) use example_collections_m , only : EXAMPLE_COLLECTION_DESCRIPTION use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_includes ( & EXAMPLE_COLLECTION_DESCRIPTION , & example_results % input % failure_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_failure_case_description ( example_results ) result ( result_ ) use example_collections_m , only : EXAMPLE_FAILING_CASE_DESCRIPTION use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_includes ( & EXAMPLE_FAILING_CASE_DESCRIPTION , & example_results % input % failure_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_failure_no_passing_descriptions ( example_results ) result ( result_ ) use example_collections_m , only : & EXAMPLE_CASE_DESCRIPTION_1 , EXAMPLE_CASE_DESCRIPTION_2 use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_doesnt_include , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = & assert_doesnt_include ( & EXAMPLE_CASE_DESCRIPTION_1 , & example_results % input % failure_description (. false .)) & . and . assert_doesnt_include ( & EXAMPLE_CASE_DESCRIPTION_2 , & example_results % input % failure_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_failure_for_message ( example_results ) result ( result_ ) use example_collections_m , only : FAILURE_MESSAGE use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_includes ( & FAILURE_MESSAGE , & example_results % input % failure_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_failure_no_success_message ( example_results ) result ( result_ ) use example_asserts_m , only : SUCCESS_MESSAGE use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_doesnt_include , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_doesnt_include ( & SUCCESS_MESSAGE , & example_results % input % failure_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_failure_no_blank_lines ( example_results ) result ( result_ ) use helpers_m , only : test_result_item_input_t use strff , only : NEWLINE use vegetables , only : input_t , result_t , assert_doesnt_include , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_doesnt_include ( & NEWLINE // NEWLINE , & example_results % input % failure_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_asserts ( example_results ) result ( result_ ) use example_collections_m , only : NUM_ASSERTS_IN_FAILING use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_equals ( NUM_ASSERTS_IN_FAILING , example_results % input % num_asserts ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_failing_asserts ( example_results ) result ( result_ ) use example_collections_m , only : NUM_FAILING_ASSERTS use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_equals ( NUM_FAILING_ASSERTS , example_results % input % num_failing_asserts ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/failing_collection_test.f90.html","title":"failing_collection_test.f90 – miniFAVOR"},{"text":"Contents Modules assert_doesnt_include_test Source Code assert_doesnt_include_test.f90 Source Code module assert_doesnt_include_test implicit none private public :: test_assert_includes character ( len =* ), parameter :: BOTH_MESSAGE = \"Both Message\" character ( len =* ), parameter :: SUCCESS_MESSAGE = \"Success Message\" character ( len =* ), parameter :: FAILURE_MESSAGE = \"Failure Message\" contains function test_assert_includes () result ( tests ) use vegetables , only : test_item_t , describe , it , ASCII_STRING_GENERATOR type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( \"passes with different strings\" , check_pass_for_different_strings ) individual_tests ( 2 ) = it ( \"fails with the same string\" , ASCII_STRING_GENERATOR , check_fail_for_same_string ) tests = describe ( \"assert_doesnt_include\" , individual_tests ) end function pure function check_pass_for_different_strings () result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : result_t , assert_doesnt_include , assert_that type ( result_t ) :: result_ character ( len =* ), parameter :: ONE_STRNIG = \"One String\" character ( len =* ), parameter :: OTHER_STRING = \"Other String\" type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss type ( result_t ) :: example_result_ccc type ( result_t ) :: example_result_ccs type ( result_t ) :: example_result_csc type ( result_t ) :: example_result_css type ( result_t ) :: example_result_scc type ( result_t ) :: example_result_scs type ( result_t ) :: example_result_ssc type ( result_t ) :: example_result_sss type ( result_t ) :: example_result_cccc type ( result_t ) :: example_result_cccs type ( result_t ) :: example_result_ccsc type ( result_t ) :: example_result_ccss type ( result_t ) :: example_result_cscc type ( result_t ) :: example_result_cscs type ( result_t ) :: example_result_cssc type ( result_t ) :: example_result_csss type ( result_t ) :: example_result_sccc type ( result_t ) :: example_result_sccs type ( result_t ) :: example_result_scsc type ( result_t ) :: example_result_scss type ( result_t ) :: example_result_sscc type ( result_t ) :: example_result_sscs type ( result_t ) :: example_result_sssc type ( result_t ) :: example_result_ssss example_result_cc = assert_doesnt_include ( & ONE_STRNIG , OTHER_STRING ) example_result_cs = assert_doesnt_include ( & ONE_STRNIG , var_str ( OTHER_STRING )) example_result_sc = assert_doesnt_include ( & var_str ( ONE_STRNIG ), OTHER_STRING ) example_result_ss = assert_doesnt_include ( & var_str ( ONE_STRNIG ), var_str ( OTHER_STRING )) example_result_ccc = assert_doesnt_include ( & ONE_STRNIG , OTHER_STRING , BOTH_MESSAGE ) example_result_ccs = assert_doesnt_include ( & ONE_STRNIG , OTHER_STRING , var_str ( BOTH_MESSAGE )) example_result_csc = assert_doesnt_include ( & ONE_STRNIG , var_str ( OTHER_STRING ), BOTH_MESSAGE ) example_result_css = assert_doesnt_include ( & ONE_STRNIG , var_str ( OTHER_STRING ), var_str ( BOTH_MESSAGE )) example_result_scc = assert_doesnt_include ( & var_str ( ONE_STRNIG ), OTHER_STRING , BOTH_MESSAGE ) example_result_scs = assert_doesnt_include ( & var_str ( ONE_STRNIG ), OTHER_STRING , var_str ( BOTH_MESSAGE )) example_result_ssc = assert_doesnt_include ( & var_str ( ONE_STRNIG ), var_str ( OTHER_STRING ), BOTH_MESSAGE ) example_result_sss = assert_doesnt_include ( & var_str ( ONE_STRNIG ), var_str ( OTHER_STRING ), var_str ( BOTH_MESSAGE )) example_result_cccc = assert_doesnt_include ( & ONE_STRNIG , & OTHER_STRING , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cccs = assert_doesnt_include ( & ONE_STRNIG , & OTHER_STRING , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_ccsc = assert_doesnt_include ( & ONE_STRNIG , & OTHER_STRING , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ccss = assert_doesnt_include ( & ONE_STRNIG , & OTHER_STRING , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_cscc = assert_doesnt_include ( & ONE_STRNIG , & var_str ( OTHER_STRING ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cscs = assert_doesnt_include ( & ONE_STRNIG , & var_str ( OTHER_STRING ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_cssc = assert_doesnt_include ( & ONE_STRNIG , & var_str ( OTHER_STRING ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_csss = assert_doesnt_include ( & ONE_STRNIG , & var_str ( OTHER_STRING ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_sccc = assert_doesnt_include ( & var_str ( ONE_STRNIG ), & OTHER_STRING , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_sccs = assert_doesnt_include ( & var_str ( ONE_STRNIG ), & OTHER_STRING , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_scsc = assert_doesnt_include ( & var_str ( ONE_STRNIG ), & OTHER_STRING , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_scss = assert_doesnt_include ( & var_str ( ONE_STRNIG ), & OTHER_STRING , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_sscc = assert_doesnt_include ( & var_str ( ONE_STRNIG ), & var_str ( OTHER_STRING ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_sscs = assert_doesnt_include ( & var_str ( ONE_STRNIG ), & var_str ( OTHER_STRING ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_sssc = assert_doesnt_include ( & var_str ( ONE_STRNIG ), & var_str ( OTHER_STRING ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ssss = assert_doesnt_include ( & var_str ( ONE_STRNIG ), & var_str ( OTHER_STRING ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) result_ = & assert_that ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_that ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_that ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_that ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) & . and . assert_that ( & example_result_ccc % passed (), & example_result_ccc % verbose_description (. false .)) & . and . assert_that ( & example_result_ccs % passed (), & example_result_ccs % verbose_description (. false .)) & . and . assert_that ( & example_result_csc % passed (), & example_result_csc % verbose_description (. false .)) & . and . assert_that ( & example_result_css % passed (), & example_result_css % verbose_description (. false .)) & . and . assert_that ( & example_result_scc % passed (), & example_result_scc % verbose_description (. false .)) & . and . assert_that ( & example_result_scs % passed (), & example_result_scs % verbose_description (. false .)) & . and . assert_that ( & example_result_ssc % passed (), & example_result_ssc % verbose_description (. false .)) & . and . assert_that ( & example_result_sss % passed (), & example_result_sss % verbose_description (. false .)) & . and . assert_that ( & example_result_cccc % passed (), & example_result_cccc % verbose_description (. false .)) & . and . assert_that ( & example_result_cccs % passed (), & example_result_cccs % verbose_description (. false .)) & . and . assert_that ( & example_result_ccsc % passed (), & example_result_ccsc % verbose_description (. false .)) & . and . assert_that ( & example_result_ccss % passed (), & example_result_ccss % verbose_description (. false .)) & . and . assert_that ( & example_result_cscc % passed (), & example_result_cscc % verbose_description (. false .)) & . and . assert_that ( & example_result_cscs % passed (), & example_result_cscs % verbose_description (. false .)) & . and . assert_that ( & example_result_cssc % passed (), & example_result_cssc % verbose_description (. false .)) & . and . assert_that ( & example_result_csss % passed (), & example_result_csss % verbose_description (. false .)) & . and . assert_that ( & example_result_sccc % passed (), & example_result_sccc % verbose_description (. false .)) & . and . assert_that ( & example_result_sccs % passed (), & example_result_sccs % verbose_description (. false .)) & . and . assert_that ( & example_result_scsc % passed (), & example_result_scsc % verbose_description (. false .)) & . and . assert_that ( & example_result_scss % passed (), & example_result_scss % verbose_description (. false .)) & . and . assert_that ( & example_result_sscc % passed (), & example_result_sscc % verbose_description (. false .)) & . and . assert_that ( & example_result_sscs % passed (), & example_result_sscs % verbose_description (. false .)) & . and . assert_that ( & example_result_sssc % passed (), & example_result_sssc % verbose_description (. false .)) & . and . assert_that ( & example_result_ssss % passed (), & example_result_ssss % verbose_description (. false .)) end function pure function check_fail_for_same_string ( the_example ) result ( result_ ) use iso_varying_string , only : varying_string , char , var_str use vegetables , only : & input_t , & result_t , & string_input_t , & assert_doesnt_include , & assert_not , fail class ( input_t ), intent ( in ) :: the_example type ( result_t ) :: result_ type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss type ( result_t ) :: example_result_ccc type ( result_t ) :: example_result_ccs type ( result_t ) :: example_result_csc type ( result_t ) :: example_result_css type ( result_t ) :: example_result_scc type ( result_t ) :: example_result_scs type ( result_t ) :: example_result_ssc type ( result_t ) :: example_result_sss type ( result_t ) :: example_result_cccc type ( result_t ) :: example_result_cccs type ( result_t ) :: example_result_ccsc type ( result_t ) :: example_result_ccss type ( result_t ) :: example_result_cscc type ( result_t ) :: example_result_cscs type ( result_t ) :: example_result_cssc type ( result_t ) :: example_result_csss type ( result_t ) :: example_result_sccc type ( result_t ) :: example_result_sccs type ( result_t ) :: example_result_scsc type ( result_t ) :: example_result_scss type ( result_t ) :: example_result_sscc type ( result_t ) :: example_result_sscs type ( result_t ) :: example_result_sssc type ( result_t ) :: example_result_ssss type ( varying_string ) :: example select type ( the_example ) type is ( string_input_t ) example = the_example % value_ example_result_cc = assert_doesnt_include ( & char ( example ), char ( example )) example_result_cs = assert_doesnt_include ( & char ( example ), example ) example_result_sc = assert_doesnt_include ( & example , char ( example )) example_result_ss = assert_doesnt_include ( & example , example ) example_result_ccc = assert_doesnt_include ( & char ( example ), char ( example ), BOTH_MESSAGE ) example_result_ccs = assert_doesnt_include ( & char ( example ), char ( example ), var_str ( BOTH_MESSAGE )) example_result_csc = assert_doesnt_include ( & char ( example ), example , BOTH_MESSAGE ) example_result_css = assert_doesnt_include ( & char ( example ), example , var_str ( BOTH_MESSAGE )) example_result_scc = assert_doesnt_include ( & example , char ( example ), BOTH_MESSAGE ) example_result_scs = assert_doesnt_include ( & example , char ( example ), var_str ( BOTH_MESSAGE )) example_result_ssc = assert_doesnt_include ( & example , example , BOTH_MESSAGE ) example_result_sss = assert_doesnt_include ( & example , example , var_str ( BOTH_MESSAGE )) example_result_cccc = assert_doesnt_include ( & char ( example ), & char ( example ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cccs = assert_doesnt_include ( & char ( example ), & char ( example ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_ccsc = assert_doesnt_include ( & char ( example ), & char ( example ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ccss = assert_doesnt_include ( & char ( example ), & char ( example ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_cscc = assert_doesnt_include ( & char ( example ), & example , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cscs = assert_doesnt_include ( & char ( example ), & example , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_cssc = assert_doesnt_include ( & char ( example ), & example , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_csss = assert_doesnt_include ( & char ( example ), & example , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_sccc = assert_doesnt_include ( & example , & char ( example ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_sccs = assert_doesnt_include ( & example , & char ( example ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_scsc = assert_doesnt_include ( & example , & char ( example ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_scss = assert_doesnt_include ( & example , & char ( example ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_sscc = assert_doesnt_include ( & example , & example , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_sscs = assert_doesnt_include ( & example , & example , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_sssc = assert_doesnt_include ( & example , & example , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ssss = assert_doesnt_include ( & example , & example , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) result_ = & assert_not ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_not ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_not ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_not ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) & . and . assert_not ( & example_result_ccc % passed (), & example_result_ccc % verbose_description (. false .)) & . and . assert_not ( & example_result_ccs % passed (), & example_result_ccs % verbose_description (. false .)) & . and . assert_not ( & example_result_csc % passed (), & example_result_csc % verbose_description (. false .)) & . and . assert_not ( & example_result_css % passed (), & example_result_css % verbose_description (. false .)) & . and . assert_not ( & example_result_scc % passed (), & example_result_scc % verbose_description (. false .)) & . and . assert_not ( & example_result_scs % passed (), & example_result_scs % verbose_description (. false .)) & . and . assert_not ( & example_result_ssc % passed (), & example_result_ssc % verbose_description (. false .)) & . and . assert_not ( & example_result_sss % passed (), & example_result_sss % verbose_description (. false .)) & . and . assert_not ( & example_result_cccc % passed (), & example_result_cccc % verbose_description (. false .)) & . and . assert_not ( & example_result_cccs % passed (), & example_result_cccs % verbose_description (. false .)) & . and . assert_not ( & example_result_ccsc % passed (), & example_result_ccsc % verbose_description (. false .)) & . and . assert_not ( & example_result_ccss % passed (), & example_result_ccss % verbose_description (. false .)) & . and . assert_not ( & example_result_cscc % passed (), & example_result_cscc % verbose_description (. false .)) & . and . assert_not ( & example_result_cscs % passed (), & example_result_cscs % verbose_description (. false .)) & . and . assert_not ( & example_result_cssc % passed (), & example_result_cssc % verbose_description (. false .)) & . and . assert_not ( & example_result_csss % passed (), & example_result_csss % verbose_description (. false .)) & . and . assert_not ( & example_result_sccc % passed (), & example_result_sccc % verbose_description (. false .)) & . and . assert_not ( & example_result_sccs % passed (), & example_result_sccs % verbose_description (. false .)) & . and . assert_not ( & example_result_scsc % passed (), & example_result_scsc % verbose_description (. false .)) & . and . assert_not ( & example_result_scss % passed (), & example_result_scss % verbose_description (. false .)) & . and . assert_not ( & example_result_sscc % passed (), & example_result_sscc % verbose_description (. false .)) & . and . assert_not ( & example_result_sscs % passed (), & example_result_sscs % verbose_description (. false .)) & . and . assert_not ( & example_result_sssc % passed (), & example_result_sssc % verbose_description (. false .)) & . and . assert_not ( & example_result_ssss % passed (), & example_result_ssss % verbose_description (. false .)) class default result_ = fail ( \"Expected a string_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/assert_doesnt_include_test.f90.html","title":"assert_doesnt_include_test.f90 – miniFAVOR"},{"text":"Contents Modules result_test Source Code result_test.f90 Source Code module result_test implicit none private public :: test_result contains function test_result () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 5 ) individual_tests ( 1 ) = it ( \"Can tell whether they passed\" , check_passed ) individual_tests ( 2 ) = it ( & \"Can tell how many assertions there were\" , check_num_asserts ) individual_tests ( 3 ) = it (& \"Can tell how many failing assertions there were\" , & check_num_failing_asserts ) individual_tests ( 4 ) = it ( & \"Verbose description includes all the messages\" , & check_verbose_includes ) individual_tests ( 5 ) = it ( & \"Failure description only includes the failing messages\" , & check_failure_includes ) tests = describe ( \"Results\" , individual_tests ) end function pure function check_passed () result ( result_ ) use vegetables , only : result_t , assert_that , assert_not , fail , succeed type ( result_t ) :: result_ type ( result_t ) :: failing_result type ( result_t ) :: passing_result passing_result = succeed ( \"Message\" ) failing_result = fail ( \"Message\" ) result_ = & assert_that ( passing_result % passed ()) & . and . assert_not ( failing_result % passed ()) end function pure function check_num_asserts () result ( result_ ) use vegetables , only : result_t , assert_equals , succeed type ( result_t ) :: result_ type ( result_t ) :: multiple_asserts multiple_asserts = succeed ( \"First\" ). and . succeed ( \"Second\" ) result_ = assert_equals ( 2 , multiple_asserts % num_asserts ()) end function pure function check_num_failing_asserts () result ( result_ ) use vegetables , only : result_t , assert_equals , fail , succeed type ( result_t ) :: result_ type ( result_t ) :: multiple_asserts multiple_asserts = succeed ( \"First\" ). and . fail ( \"Second\" ) result_ = assert_equals ( 1 , multiple_asserts % num_failing_asserts ()) end function pure function check_verbose_includes () result ( result_ ) use vegetables , only : result_t , assert_includes , fail , succeed type ( result_t ) :: result_ type ( result_t ) :: multiple_asserts multiple_asserts = succeed ( \"First\" ). and . fail ( \"Second\" ) result_ = & assert_includes ( & \"First\" , multiple_asserts % verbose_description (. false .))& . and . assert_includes ( & \"Second\" , multiple_asserts % verbose_description (. false .)) end function pure function check_failure_includes () result ( result_ ) use vegetables , only : & result_t , assert_doesnt_include , assert_includes , fail , succeed type ( result_t ) :: result_ type ( result_t ) :: multiple_asserts multiple_asserts = succeed ( \"First\" ). and . fail ( \"Second\" ) result_ = & assert_doesnt_include ( & \"First\" , multiple_asserts % failure_description (. false .))& . and . assert_includes ( & \"Second\" , multiple_asserts % failure_description (. false .)) end function end module","tags":"","loc":"sourcefile/result_test.f90.html","title":"result_test.f90 – miniFAVOR"},{"text":"Contents Modules example_collections_m Source Code example_collections_m.f90 Source Code module example_collections_m use example_asserts_m , only : NUM_PASSING_FROM_EXAMPLE => NUM_ASSERTS_IN_PASSING implicit none private public :: & example_failing_collection , & example_passing_collection , & example_test_case_1 , & example_test_case_2 , & EXAMPLE_CASE_DESCRIPTION_1 , & EXAMPLE_CASE_DESCRIPTION_2 , & EXAMPLE_COLLECTION_DESCRIPTION , & EXAMPLE_FAILING_CASE_DESCRIPTION , & FAILURE_MESSAGE , & MIDDLE_COLLECTION_DESCRIPTION , & NOT_IN_DESCRIPTIONS , & NUM_ASSERTS_IN_FAILING , & NUM_ASSERTS_IN_PASSING , & NUM_CASES_IN_FAILING , & NUM_CASES_IN_PASSING , & NUM_FAILING_ASSERTS , & NUM_FAILING_CASES character ( len =* ), parameter :: EXAMPLE_CASE_DESCRIPTION_1 = & \"Example Case Description 1\" character ( len =* ), parameter :: EXAMPLE_CASE_DESCRIPTION_2 = & \"Example Case Description 2\" character ( len =* ), parameter :: EXAMPLE_COLLECTION_DESCRIPTION = & \"Example Collection Description\" character ( len =* ), parameter :: EXAMPLE_FAILING_CASE_DESCRIPTION = & \"Example Failing Case Description\" character ( len =* ), parameter :: FAILURE_MESSAGE = \"Failure Message\" character ( len =* ), parameter :: MIDDLE_COLLECTION_DESCRIPTION = & \"Middle Collection Description\" character ( len =* ), parameter :: NOT_IN_DESCRIPTIONS = \"NOT IN DESCRIPTION\" integer , parameter :: NUM_ASSERTS_IN_FAILING = NUM_PASSING_FROM_EXAMPLE * 2 + 1 integer , parameter :: NUM_ASSERTS_IN_PASSING = NUM_PASSING_FROM_EXAMPLE * 3 integer , parameter :: NUM_CASES_IN_FAILING = 3 integer , parameter :: NUM_CASES_IN_PASSING = 3 integer , parameter :: NUM_FAILING_ASSERTS = 1 integer , parameter :: NUM_FAILING_CASES = 1 contains function example_test_case_1 () result ( test_case ) use example_asserts_m , only : example_multiple_asserts use vegetables , only : test_item_t , it type ( test_item_t ) :: test_case test_case = it ( EXAMPLE_CASE_DESCRIPTION_1 , example_multiple_asserts ) end function function example_test_case_2 () result ( test_case ) use example_asserts_m , only : example_multiple_asserts use vegetables , only : test_item_t , it type ( test_item_t ) :: test_case test_case = it ( EXAMPLE_CASE_DESCRIPTION_2 , example_multiple_asserts ) end function pure function example_fail () result ( result_ ) use vegetables , only : result_t , fail type ( result_t ) :: result_ result_ = fail ( FAILURE_MESSAGE ) end function function example_failing_test_case () result ( test_case ) use vegetables , only : test_item_t , it type ( test_item_t ) :: test_case test_case = it ( EXAMPLE_FAILING_CASE_DESCRIPTION , example_fail ) end function function example_failing_collection () result ( test_collection ) use vegetables , only : test_item_t , describe type ( test_item_t ) :: test_collection type ( test_item_t ) :: cases ( 3 ) cases ( 1 ) = example_test_case_1 () cases ( 2 ) = example_test_case_2 () cases ( 3 ) = example_failing_test_case () test_collection = describe ( EXAMPLE_COLLECTION_DESCRIPTION , cases ) end function function middle_collection () result ( test_collection ) use vegetables , only : test_item_t , describe type ( test_item_t ) :: test_collection type ( test_item_t ) :: cases ( 2 ) cases ( 1 ) = example_test_case_1 () cases ( 2 ) = example_test_case_2 () test_collection = describe ( MIDDLE_COLLECTION_DESCRIPTION , cases ) end function function example_passing_collection () result ( test_collection ) use vegetables , only : test_item_t , describe type ( test_item_t ) :: test_collection type ( test_item_t ) :: items ( 2 ) items ( 1 ) = middle_collection () items ( 2 ) = example_test_case_2 () test_collection = describe ( EXAMPLE_COLLECTION_DESCRIPTION , items ) end function end module","tags":"","loc":"sourcefile/example_collections_m.f90.html","title":"example_collections_m.f90 – miniFAVOR"},{"text":"Contents Modules assert_equals_within_relative_test Source Code assert_equals_within_relative_test.f90 Source Code module assert_equals_within_relative_test implicit none private public :: test_assert_equals_within_relative character ( len =* ), parameter :: BOTH_MESSAGE = \"Both Message\" character ( len =* ), parameter :: SUCCESS_MESSAGE = \"Success Message\" character ( len =* ), parameter :: FAILURE_MESSAGE = \"Failure Message\" contains function test_assert_equals_within_relative () result ( tests ) use double_precision_generator_m , only : DOUBLE_PRECISION_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"passes with the same number even with very small tolerance\" , & DOUBLE_PRECISION_GENERATOR , & check_pass_for_same_number ) individual_tests ( 2 ) = it ( & \"fails with sufficiently different numbers\" , & DOUBLE_PRECISION_GENERATOR , & check_fail_for_different_numbers ) individual_tests ( 3 ) = it ( & \"passes with sufficiently close numbers\" , & DOUBLE_PRECISION_GENERATOR , & check_pass_for_close_numbers ) tests = describe ( \"assert_equals_within_relative\" , individual_tests ) end function pure function check_pass_for_same_number ( the_example ) result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : & double_precision_input_t , & input_t , & result_t , & assert_equals_within_relative , & assert_that , & fail class ( input_t ), intent ( in ) :: the_example type ( result_t ) :: result_ double precision :: example type ( result_t ) :: example_result type ( result_t ) :: example_result_c type ( result_t ) :: example_result_s type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss select type ( the_example ) type is ( double_precision_input_t ) example = the_example % value_ example_result = assert_equals_within_relative ( & example , example , tiny ( 0.0d0 )) example_result_c = assert_equals_within_relative ( & example , example , tiny ( 0.0d0 ), BOTH_MESSAGE ) example_result_s = assert_equals_within_relative ( & example , example , tiny ( 0.0d0 ), var_str ( BOTH_MESSAGE )) example_result_cc = assert_equals_within_relative ( & example , & example , & tiny ( 0.0d0 ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cs = assert_equals_within_relative ( & example , & example , & tiny ( 0.0d0 ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_sc = assert_equals_within_relative ( & example , & example , & tiny ( 0.0d0 ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ss = assert_equals_within_relative ( & example , & example , & tiny ( 0.0d0 ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) result_ = & assert_that ( & example_result % passed (), & example_result % verbose_description (. false .)) & . and . assert_that ( & example_result_c % passed (), & example_result_c % verbose_description (. false .)) & . and . assert_that ( & example_result_s % passed (), & example_result_s % verbose_description (. false .)) & . and . assert_that ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_that ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_that ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_that ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a double precision value\" ) end select end function pure function check_fail_for_different_numbers ( the_example ) result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : & double_precision_input_t , & input_t , & result_t , & assert_equals_within_relative , & assert_not , & fail class ( input_t ), intent ( in ) :: the_example type ( result_t ) :: result_ double precision :: example type ( result_t ) :: example_result type ( result_t ) :: example_result_c type ( result_t ) :: example_result_s type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss select type ( the_example ) type is ( double_precision_input_t ) example = the_example % value_ example_result = assert_equals_within_relative ( & example , example * 1.11d0 , 0.1d0 ) example_result_c = assert_equals_within_relative ( & example , example * 1.11d0 , 0.1d0 , BOTH_MESSAGE ) example_result_s = assert_equals_within_relative ( & example , example * 1.11d0 , 0.1d0 , var_str ( BOTH_MESSAGE )) example_result_cc = assert_equals_within_relative ( & example , & example * 1.11d0 , & 0.1d0 , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cs = assert_equals_within_relative ( & example , & example * 1.11d0 , & 0.1d0 , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_sc = assert_equals_within_relative ( & example , & example * 1.11d0 , & 0.1d0 , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ss = assert_equals_within_relative ( & example , & example * 1.11d0 , & 0.1d0 , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) result_ = & assert_not ( & example_result % passed (), & example_result % verbose_description (. false .)) & . and . assert_not ( & example_result_c % passed (), & example_result_c % verbose_description (. false .)) & . and . assert_not ( & example_result_s % passed (), & example_result_s % verbose_description (. false .)) & . and . assert_not ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_not ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_not ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_not ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a double precision value\" ) end select end function pure function check_pass_for_close_numbers ( the_example ) result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : & double_precision_input_t , & input_t , & result_t , & assert_equals_within_relative , & assert_that , & fail class ( input_t ), intent ( in ) :: the_example type ( result_t ) :: result_ double precision :: example type ( result_t ) :: example_result type ( result_t ) :: example_result_c type ( result_t ) :: example_result_s type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss select type ( the_example ) type is ( double_precision_input_t ) example = the_example % value_ example_result = assert_equals_within_relative ( & example , example * 1.09d0 , 0.1d0 ) example_result_c = assert_equals_within_relative ( & example , example * 1.09d0 , 0.1d0 , BOTH_MESSAGE ) example_result_s = assert_equals_within_relative ( & example , example * 1.09d0 , 0.1d0 , var_str ( BOTH_MESSAGE )) example_result_cc = assert_equals_within_relative ( & example , & example * 1.09d0 , & 0.1d0 , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cs = assert_equals_within_relative ( & example , & example * 1.09d0 , & 0.1d0 , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_sc = assert_equals_within_relative ( & example , & example * 1.09d0 , & 0.1d0 , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ss = assert_equals_within_relative ( & example , & example * 1.09d0 , & 0.1d0 , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) result_ = & assert_that ( & example_result % passed (), & example_result % verbose_description (. false .)) & . and . assert_that ( & example_result_c % passed (), & example_result_c % verbose_description (. false .)) & . and . assert_that ( & example_result_s % passed (), & example_result_s % verbose_description (. false .)) & . and . assert_that ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_that ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_that ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_that ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a double precision value\" ) end select end function end module","tags":"","loc":"sourcefile/assert_equals_within_relative_test.f90.html","title":"assert_equals_within_relative_test.f90 – miniFAVOR"},{"text":"Contents Modules assert_equals_double_precision_test Source Code assert_equals_double_precision_test.f90 Source Code module assert_equals_double_precision_test implicit none private public :: test_assert_equals_integers character ( len =* ), parameter :: BOTH_MESSAGE = \"Both Message\" character ( len =* ), parameter :: SUCCESS_MESSAGE = \"Success Message\" character ( len =* ), parameter :: FAILURE_MESSAGE = \"Failure Message\" contains function test_assert_equals_integers () result ( tests ) use double_precision_generator_m , only : DOUBLE_PRECISION_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( \"passes with the same number\" , DOUBLE_PRECISION_GENERATOR , check_pass_for_same_number ) individual_tests ( 2 ) = it ( \"fails with different numbers\" , check_fail_for_different_numbers ) tests = describe ( \"assert_equals with double precision values\" , individual_tests ) end function pure function check_pass_for_same_number ( the_example ) result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : & double_precision_input_t , & input_t , & result_t , & assert_equals , & assert_that , & fail class ( input_t ), intent ( in ) :: the_example type ( result_t ) :: result_ double precision :: example type ( result_t ) :: example_result type ( result_t ) :: example_result_c type ( result_t ) :: example_result_s type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss select type ( the_example ) type is ( double_precision_input_t ) example = the_example % value_ example_result = assert_equals ( example , example ) example_result_c = assert_equals ( example , example , BOTH_MESSAGE ) example_result_s = assert_equals ( example , example , var_str ( BOTH_MESSAGE )) example_result_cc = assert_equals ( & example , example , SUCCESS_MESSAGE , FAILURE_MESSAGE ) example_result_cs = assert_equals ( & example , example , SUCCESS_MESSAGE , var_str ( FAILURE_MESSAGE )) example_result_sc = assert_equals ( & example , example , var_str ( SUCCESS_MESSAGE ), FAILURE_MESSAGE ) example_result_ss = assert_equals ( & example , example , var_str ( SUCCESS_MESSAGE ), var_str ( FAILURE_MESSAGE )) result_ = & assert_that ( & example_result % passed (), & example_result % verbose_description (. false .)) & . and . assert_that ( & example_result_c % passed (), & example_result_c % verbose_description (. false .)) & . and . assert_that ( & example_result_s % passed (), & example_result_s % verbose_description (. false .)) & . and . assert_that ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_that ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_that ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_that ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a double precision value\" ) end select end function pure function check_fail_for_different_numbers () result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( result_t ) :: example_result type ( result_t ) :: example_result_c type ( result_t ) :: example_result_s type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss example_result = assert_equals ( 1.0d0 , 2.0d0 ) example_result_c = assert_equals ( 1.0d0 , 2.0d0 , BOTH_MESSAGE ) example_result_s = assert_equals ( 1.0d0 , 2.0d0 , var_str ( BOTH_MESSAGE )) example_result_cc = assert_equals ( & 1.0d0 , 2.0d0 , SUCCESS_MESSAGE , FAILURE_MESSAGE ) example_result_cs = assert_equals ( & 1.0d0 , 2.0d0 , SUCCESS_MESSAGE , var_str ( FAILURE_MESSAGE )) example_result_sc = assert_equals ( & 1.0d0 , 2.0d0 , var_str ( SUCCESS_MESSAGE ), FAILURE_MESSAGE ) example_result_ss = assert_equals ( & 1.0d0 , 2.0d0 , var_str ( SUCCESS_MESSAGE ), var_str ( FAILURE_MESSAGE )) result_ = & assert_not ( & example_result % passed (), & example_result % verbose_description (. false .)) & . and . assert_not ( & example_result_c % passed (), & example_result_c % verbose_description (. false .)) & . and . assert_not ( & example_result_s % passed (), & example_result_s % verbose_description (. false .)) & . and . assert_not ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_not ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_not ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_not ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) end function end module","tags":"","loc":"sourcefile/assert_equals_double_precision_test.f90.html","title":"assert_equals_double_precision_test.f90 – miniFAVOR"},{"text":"Contents Programs main Source Code main.f90 Source Code ! Generated by make_vegetable_driver. DO NOT EDIT program main implicit none call run () contains subroutine run () use assert_doesnt_include_test , only : & assert_doesnt_include_assert_includes => test_assert_includes use assert_empty_test , only : & assert_empty_assert_empty => test_assert_empty use assert_equals_double_precision_test , only : & assert_equals_double_precision_assert_equals_integers => test_assert_equals_integers use assert_equals_integers_test , only : & assert_equals_integers_assert_equals_integers => test_assert_equals_integers use assert_equals_strings_test , only : & assert_equals_strings_assert_equals_strings => test_assert_equals_strings use assert_equals_within_absolute_test , only : & assert_equals_within_absolute_assert_equals_within_relative => test_assert_equals_within_relative use assert_equals_within_relative_test , only : & assert_equals_within_relative_assert_equals_within_relative => test_assert_equals_within_relative use assert_includes_test , only : & assert_includes_assert_includes => test_assert_includes use collection_properties_test , only : & collection_properties_collection_properties => test_collection_properties use failing_case_test , only : & failing_case_failing_case_behaviors => test_failing_case_behaviors use failing_collection_test , only : & failing_collection_failing_collection_behaviors => test_failing_collection_behaviors use filter_test , only : & filter_filter_case => test_filter_case , & filter_filter_collection => test_filter_collection use passing_case_test , only : & passing_case_passing_case_behaviors => test_passing_case_behaviors use passing_collection_test , only : & passing_collection_passing_collection_behaviors => test_passing_collection_behaviors use result_test , only : & result_result => test_result use single_case_properties_test , only : & single_case_properties_case_properties => test_case_properties use vegetables , only : test_item_t , test_that , run_tests type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 17 ) individual_tests ( 1 ) = assert_doesnt_include_assert_includes () individual_tests ( 2 ) = assert_empty_assert_empty () individual_tests ( 3 ) = assert_equals_double_precision_assert_equals_integers () individual_tests ( 4 ) = assert_equals_integers_assert_equals_integers () individual_tests ( 5 ) = assert_equals_strings_assert_equals_strings () individual_tests ( 6 ) = assert_equals_within_absolute_assert_equals_within_relative () individual_tests ( 7 ) = assert_equals_within_relative_assert_equals_within_relative () individual_tests ( 8 ) = assert_includes_assert_includes () individual_tests ( 9 ) = collection_properties_collection_properties () individual_tests ( 10 ) = failing_case_failing_case_behaviors () individual_tests ( 11 ) = failing_collection_failing_collection_behaviors () individual_tests ( 12 ) = filter_filter_case () individual_tests ( 13 ) = filter_filter_collection () individual_tests ( 14 ) = passing_case_passing_case_behaviors () individual_tests ( 15 ) = passing_collection_passing_collection_behaviors () individual_tests ( 16 ) = result_result () individual_tests ( 17 ) = single_case_properties_case_properties () tests = test_that ( individual_tests ) call run_tests ( tests ) end subroutine end program","tags":"","loc":"sourcefile/main.f90~13.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Modules passing_collection_test Source Code passing_collection_test.f90 Source Code module passing_collection_test implicit none private public :: test_passing_collection_behaviors contains function test_passing_collection_behaviors () result ( tests ) use example_collections_m , only : example_passing_collection use helpers_m , only : test_item_input_t , run_test use vegetables , only : test_item_t , given , then__ , when type ( test_item_t ) :: tests type ( test_item_t ) :: collection ( 1 ) type ( test_item_input_t ) :: the_collection type ( test_item_t ) :: individual_tests ( 9 ) the_collection % input = example_passing_collection () individual_tests ( 1 ) = then__ ( \"it knows it passed\" , check_collection_passes ) individual_tests ( 2 ) = then__ ( \"it knows how many cases there were\" , check_num_cases ) individual_tests ( 3 ) = then__ ( \"it has no failing cases\" , check_num_failing_cases ) individual_tests ( 4 ) = then__ ( \"it's verbose description includes the given description\" , check_werbose_top_description ) individual_tests ( 5 ) = then__ ( & \"it's verbose description includes the individual case descriptions\" , & check_verbose_case_descriptions ) individual_tests ( 6 ) = then__ ( \"it's verbose description includes the assertion message\" , check_verbose_description_assertion ) individual_tests ( 7 ) = then__ ( \"it's failure description is empty\" , check_failure_description_empty ) individual_tests ( 8 ) = then__ ( \"it knows how many asserts there were\" , check_num_asserts ) individual_tests ( 9 ) = then__ ( \"it has no failing asserts\" , check_num_failing_asserts ) collection ( 1 ) = when ( \"it is run\" , run_test , individual_tests ) tests = given ( \"a passing test collection\" , the_collection , collection ) end function pure function check_collection_passes ( example_results ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_that ( example_results % input % passed (), \"It passed\" , \"It didn't pass\" ) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_cases ( example_results ) result ( result_ ) use example_collections_m , only : NUM_CASES_IN_PASSING use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_equals ( NUM_CASES_IN_PASSING , example_results % input % num_cases ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_failing_cases ( example_results ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_equals ( 0 , example_results % input % num_failing_cases ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_werbose_top_description ( example_results ) result ( result_ ) use example_collections_m , only : EXAMPLE_COLLECTION_DESCRIPTION use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_includes ( & EXAMPLE_COLLECTION_DESCRIPTION , & example_results % input % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_verbose_case_descriptions ( example_results ) result ( result_ ) use example_collections_m , only : & EXAMPLE_CASE_DESCRIPTION_1 , EXAMPLE_CASE_DESCRIPTION_2 use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = & assert_includes ( & EXAMPLE_CASE_DESCRIPTION_1 , & example_results % input % verbose_description (. false .)) & . and . assert_includes ( & EXAMPLE_CASE_DESCRIPTION_2 , & example_results % input % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_verbose_description_assertion ( example_results ) result ( result_ ) use example_asserts_m , only : SUCCESS_MESSAGE use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_includes ( & SUCCESS_MESSAGE , & example_results % input % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_failure_description_empty ( example_results ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_empty , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_empty ( example_results % input % failure_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_asserts ( example_results ) result ( result_ ) use example_collections_m , only : NUM_ASSERTS_IN_PASSING use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_equals ( NUM_ASSERTS_IN_PASSING , example_results % input % num_asserts ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_failing_asserts ( example_results ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_results type ( result_t ) :: result_ select type ( example_results ) type is ( test_result_item_input_t ) result_ = assert_equals ( 0 , example_results % input % num_failing_asserts ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/passing_collection_test.f90.html","title":"passing_collection_test.f90 – miniFAVOR"},{"text":"Contents Modules assert_equals_strings_test Source Code assert_equals_strings_test.f90 Source Code module assert_equals_strings_test implicit none private public :: test_assert_equals_strings character ( len =* ), parameter :: BOTH_MESSAGE = \"Both Message\" character ( len =* ), parameter :: SUCCESS_MESSAGE = \"Success Message\" character ( len =* ), parameter :: FAILURE_MESSAGE = \"Failure Message\" contains function test_assert_equals_strings () result ( tests ) use vegetables , only : test_item_t , describe , it , ASCII_STRING_GENERATOR type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( \"passes with the same strings\" , ASCII_STRING_GENERATOR , check_pass_for_same_strings ) individual_tests ( 2 ) = it ( \"fails with different strings\" , check_fail_for_different_strings ) tests = describe ( \"assert_equals with strings\" , individual_tests ) end function pure function check_pass_for_same_strings ( the_example ) result ( result_ ) use iso_varying_string , only : varying_string , char , var_str use vegetables , only : & input_t , & result_t , & string_input_t , & assert_equals , & assert_that , & fail class ( input_t ), intent ( in ) :: the_example type ( result_t ) :: result_ type ( varying_string ) :: example type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss type ( result_t ) :: example_result_ccc type ( result_t ) :: example_result_ccs type ( result_t ) :: example_result_csc type ( result_t ) :: example_result_css type ( result_t ) :: example_result_scc type ( result_t ) :: example_result_scs type ( result_t ) :: example_result_ssc type ( result_t ) :: example_result_sss type ( result_t ) :: example_result_cccc type ( result_t ) :: example_result_cccs type ( result_t ) :: example_result_ccsc type ( result_t ) :: example_result_ccss type ( result_t ) :: example_result_cscc type ( result_t ) :: example_result_cscs type ( result_t ) :: example_result_cssc type ( result_t ) :: example_result_csss type ( result_t ) :: example_result_sccc type ( result_t ) :: example_result_sccs type ( result_t ) :: example_result_scsc type ( result_t ) :: example_result_scss type ( result_t ) :: example_result_sscc type ( result_t ) :: example_result_sscs type ( result_t ) :: example_result_sssc type ( result_t ) :: example_result_ssss select type ( the_example ) type is ( string_input_t ) example = the_example % value_ example_result_cc = assert_equals ( char ( example ), char ( example )) example_result_cs = assert_equals ( char ( example ), example ) example_result_sc = assert_equals ( example , char ( example )) example_result_ss = assert_equals ( example , example ) example_result_ccc = assert_equals ( & char ( example ), char ( example ), BOTH_MESSAGE ) example_result_ccs = assert_equals ( & char ( example ), char ( example ), var_str ( BOTH_MESSAGE )) example_result_csc = assert_equals ( & char ( example ), example , BOTH_MESSAGE ) example_result_css = assert_equals ( & char ( example ), example , var_str ( BOTH_MESSAGE )) example_result_scc = assert_equals ( & example , char ( example ), BOTH_MESSAGE ) example_result_scs = assert_equals ( & example , char ( example ), var_str ( BOTH_MESSAGE )) example_result_ssc = assert_equals ( & example , example , BOTH_MESSAGE ) example_result_sss = assert_equals ( & example , example , var_str ( BOTH_MESSAGE )) example_result_cccc = assert_equals ( & char ( example ), & char ( example ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cccs = assert_equals ( & char ( example ), & char ( example ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_ccsc = assert_equals ( & char ( example ), & char ( example ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ccss = assert_equals ( & char ( example ), & char ( example ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_cscc = assert_equals ( & char ( example ), & example , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cscs = assert_equals ( & char ( example ), & example , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_cssc = assert_equals ( & char ( example ), & example , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_csss = assert_equals ( & char ( example ), & example , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_sccc = assert_equals ( & example , & char ( example ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_sccs = assert_equals ( & example , & char ( example ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_scsc = assert_equals ( & example , & char ( example ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_scss = assert_equals ( & example , & char ( example ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_sscc = assert_equals ( & example , & example , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_sscs = assert_equals ( & example , & example , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_sssc = assert_equals ( & example , & example , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ssss = assert_equals ( & example , & example , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) result_ = & assert_that ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_that ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_that ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_that ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) & . and . assert_that ( & example_result_ccc % passed (), & example_result_ccc % verbose_description (. false .)) & . and . assert_that ( & example_result_ccs % passed (), & example_result_ccs % verbose_description (. false .)) & . and . assert_that ( & example_result_csc % passed (), & example_result_csc % verbose_description (. false .)) & . and . assert_that ( & example_result_css % passed (), & example_result_css % verbose_description (. false .)) & . and . assert_that ( & example_result_scc % passed (), & example_result_scc % verbose_description (. false .)) & . and . assert_that ( & example_result_scs % passed (), & example_result_scs % verbose_description (. false .)) & . and . assert_that ( & example_result_ssc % passed (), & example_result_ssc % verbose_description (. false .)) & . and . assert_that ( & example_result_sss % passed (), & example_result_sss % verbose_description (. false .)) & . and . assert_that ( & example_result_cccc % passed (), & example_result_cccc % verbose_description (. false .)) & . and . assert_that ( & example_result_cccs % passed (), & example_result_cccs % verbose_description (. false .)) & . and . assert_that ( & example_result_ccsc % passed (), & example_result_ccsc % verbose_description (. false .)) & . and . assert_that ( & example_result_ccss % passed (), & example_result_ccss % verbose_description (. false .)) & . and . assert_that ( & example_result_cscc % passed (), & example_result_cscc % verbose_description (. false .)) & . and . assert_that ( & example_result_cscs % passed (), & example_result_cscs % verbose_description (. false .)) & . and . assert_that ( & example_result_cssc % passed (), & example_result_cssc % verbose_description (. false .)) & . and . assert_that ( & example_result_csss % passed (), & example_result_csss % verbose_description (. false .)) & . and . assert_that ( & example_result_sccc % passed (), & example_result_sccc % verbose_description (. false .)) & . and . assert_that ( & example_result_sccs % passed (), & example_result_sccs % verbose_description (. false .)) & . and . assert_that ( & example_result_scsc % passed (), & example_result_scsc % verbose_description (. false .)) & . and . assert_that ( & example_result_scss % passed (), & example_result_scss % verbose_description (. false .)) & . and . assert_that ( & example_result_sscc % passed (), & example_result_sscc % verbose_description (. false .)) & . and . assert_that ( & example_result_sscs % passed (), & example_result_sscs % verbose_description (. false .)) & . and . assert_that ( & example_result_sssc % passed (), & example_result_sssc % verbose_description (. false .)) & . and . assert_that ( & example_result_ssss % passed (), & example_result_ssss % verbose_description (. false .)) class default result_ = fail ( \"Expected a character string\" ) end select end function pure function check_fail_for_different_strings () result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ character ( len =* ), parameter :: ONE_STRNIG = \"One String\" character ( len =* ), parameter :: OTHER_STRING = \"Other String\" type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss type ( result_t ) :: example_result_ccc type ( result_t ) :: example_result_ccs type ( result_t ) :: example_result_csc type ( result_t ) :: example_result_css type ( result_t ) :: example_result_scc type ( result_t ) :: example_result_scs type ( result_t ) :: example_result_ssc type ( result_t ) :: example_result_sss type ( result_t ) :: example_result_cccc type ( result_t ) :: example_result_cccs type ( result_t ) :: example_result_ccsc type ( result_t ) :: example_result_ccss type ( result_t ) :: example_result_cscc type ( result_t ) :: example_result_cscs type ( result_t ) :: example_result_cssc type ( result_t ) :: example_result_csss type ( result_t ) :: example_result_sccc type ( result_t ) :: example_result_sccs type ( result_t ) :: example_result_scsc type ( result_t ) :: example_result_scss type ( result_t ) :: example_result_sscc type ( result_t ) :: example_result_sscs type ( result_t ) :: example_result_sssc type ( result_t ) :: example_result_ssss example_result_cc = assert_equals ( ONE_STRNIG , OTHER_STRING ) example_result_cs = assert_equals ( ONE_STRNIG , var_str ( OTHER_STRING )) example_result_sc = assert_equals ( var_str ( ONE_STRNIG ), OTHER_STRING ) example_result_ss = assert_equals ( var_str ( ONE_STRNIG ), var_str ( OTHER_STRING )) example_result_ccc = assert_equals ( & ONE_STRNIG , OTHER_STRING , BOTH_MESSAGE ) example_result_ccs = assert_equals ( & ONE_STRNIG , OTHER_STRING , var_str ( BOTH_MESSAGE )) example_result_csc = assert_equals ( & ONE_STRNIG , var_str ( OTHER_STRING ), BOTH_MESSAGE ) example_result_css = assert_equals ( & ONE_STRNIG , var_str ( OTHER_STRING ), var_str ( BOTH_MESSAGE )) example_result_scc = assert_equals ( & var_str ( ONE_STRNIG ), OTHER_STRING , BOTH_MESSAGE ) example_result_scs = assert_equals ( & var_str ( ONE_STRNIG ), OTHER_STRING , var_str ( BOTH_MESSAGE )) example_result_ssc = assert_equals ( & var_str ( ONE_STRNIG ), var_str ( OTHER_STRING ), BOTH_MESSAGE ) example_result_sss = assert_equals ( & var_str ( ONE_STRNIG ), var_str ( OTHER_STRING ), var_str ( BOTH_MESSAGE )) example_result_cccc = assert_equals ( & ONE_STRNIG , & OTHER_STRING , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cccs = assert_equals ( & ONE_STRNIG , & OTHER_STRING , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_ccsc = assert_equals ( & ONE_STRNIG , & OTHER_STRING , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ccss = assert_equals ( & ONE_STRNIG , & OTHER_STRING , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_cscc = assert_equals ( & ONE_STRNIG , & var_str ( OTHER_STRING ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cscs = assert_equals ( & ONE_STRNIG , & var_str ( OTHER_STRING ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_cssc = assert_equals ( & ONE_STRNIG , & var_str ( OTHER_STRING ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_csss = assert_equals ( & ONE_STRNIG , & var_str ( OTHER_STRING ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_sccc = assert_equals ( & var_str ( ONE_STRNIG ), & OTHER_STRING , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_sccs = assert_equals ( & var_str ( ONE_STRNIG ), & OTHER_STRING , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_scsc = assert_equals ( & var_str ( ONE_STRNIG ), & OTHER_STRING , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_scss = assert_equals ( & var_str ( ONE_STRNIG ), & OTHER_STRING , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_sscc = assert_equals ( & var_str ( ONE_STRNIG ), & var_str ( OTHER_STRING ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_sscs = assert_equals ( & var_str ( ONE_STRNIG ), & var_str ( OTHER_STRING ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_sssc = assert_equals ( & var_str ( ONE_STRNIG ), & var_str ( OTHER_STRING ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ssss = assert_equals ( & var_str ( ONE_STRNIG ), & var_str ( OTHER_STRING ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) result_ = & assert_not ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_not ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_not ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_not ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) & . and . assert_not ( & example_result_ccc % passed (), & example_result_ccc % verbose_description (. false .)) & . and . assert_not ( & example_result_ccs % passed (), & example_result_ccs % verbose_description (. false .)) & . and . assert_not ( & example_result_csc % passed (), & example_result_csc % verbose_description (. false .)) & . and . assert_not ( & example_result_css % passed (), & example_result_css % verbose_description (. false .)) & . and . assert_not ( & example_result_scc % passed (), & example_result_scc % verbose_description (. false .)) & . and . assert_not ( & example_result_scs % passed (), & example_result_scs % verbose_description (. false .)) & . and . assert_not ( & example_result_ssc % passed (), & example_result_ssc % verbose_description (. false .)) & . and . assert_not ( & example_result_sss % passed (), & example_result_sss % verbose_description (. false .)) & . and . assert_not ( & example_result_cccc % passed (), & example_result_cccc % verbose_description (. false .)) & . and . assert_not ( & example_result_cccs % passed (), & example_result_cccs % verbose_description (. false .)) & . and . assert_not ( & example_result_ccsc % passed (), & example_result_ccsc % verbose_description (. false .)) & . and . assert_not ( & example_result_ccss % passed (), & example_result_ccss % verbose_description (. false .)) & . and . assert_not ( & example_result_cscc % passed (), & example_result_cscc % verbose_description (. false .)) & . and . assert_not ( & example_result_cscs % passed (), & example_result_cscs % verbose_description (. false .)) & . and . assert_not ( & example_result_cssc % passed (), & example_result_cssc % verbose_description (. false .)) & . and . assert_not ( & example_result_csss % passed (), & example_result_csss % verbose_description (. false .)) & . and . assert_not ( & example_result_sccc % passed (), & example_result_sccc % verbose_description (. false .)) & . and . assert_not ( & example_result_sccs % passed (), & example_result_sccs % verbose_description (. false .)) & . and . assert_not ( & example_result_scsc % passed (), & example_result_scsc % verbose_description (. false .)) & . and . assert_not ( & example_result_scss % passed (), & example_result_scss % verbose_description (. false .)) & . and . assert_not ( & example_result_sscc % passed (), & example_result_sscc % verbose_description (. false .)) & . and . assert_not ( & example_result_sscs % passed (), & example_result_sscs % verbose_description (. false .)) & . and . assert_not ( & example_result_sssc % passed (), & example_result_sssc % verbose_description (. false .)) & . and . assert_not ( & example_result_ssss % passed (), & example_result_ssss % verbose_description (. false .)) end function end module","tags":"","loc":"sourcefile/assert_equals_strings_test.f90.html","title":"assert_equals_strings_test.f90 – miniFAVOR"},{"text":"Contents Modules passing_case_test Source Code passing_case_test.f90 Source Code module passing_case_test implicit none private public :: test_passing_case_behaviors contains function test_passing_case_behaviors () result ( test ) use example_cases_m , only : example_passing_test_case use helpers_m , only : test_item_input_t , run_test use vegetables , only : test_item_t , given , then__ , when type ( test_item_t ) :: test type ( test_item_t ) :: collection ( 1 ) type ( test_item_input_t ) :: the_case type ( test_item_t ) :: individual_tests ( 8 ) the_case % input = example_passing_test_Case () individual_tests ( 1 ) = then__ ( \"it knows it passed\" , check_case_passes ) individual_tests ( 2 ) = then__ ( \"it has 1 test case\" , check_num_cases ) individual_tests ( 3 ) = then__ ( \"it has no failing case\" , check_num_failing_cases ) individual_tests ( 4 ) = then__ ( \"it's verbose description still includes the given description\" , check_verbose_description ) individual_tests ( 5 ) = then__ ( \"it's verbose description includes the assertion message\" , check_verbose_description_assertion ) individual_tests ( 6 ) = then__ ( \"it's failure description is empty\" , check_failure_description_empty ) individual_tests ( 7 ) = then__ ( \"it knows how many asserts there were\" , check_num_asserts ) individual_tests ( 8 ) = then__ ( \"it has no failing asserts\" , check_num_failing_asserts ) collection ( 1 ) = when ( \"it is run\" , run_test , individual_tests ) test = given ( \"a passing test case\" , the_case , collection ) end function pure function check_case_passes ( example_result ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_that , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_that ( example_result % input % passed ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_cases ( example_result ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_equals ( 1 , example_result % input % num_cases ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_failing_cases ( example_result ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_equals ( 0 , example_result % input % num_failing_cases ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_verbose_description ( example_result ) result ( result_ ) use example_cases_m , only : EXAMPLE_DESCRIPTION use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_includes ( EXAMPLE_DESCRIPTION , example_result % input % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_verbose_description_assertion ( example_result ) result ( result_ ) use example_asserts_m , only : SUCCESS_MESSAGE use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_includes ( SUCCESS_MESSAGE , example_result % input % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_failure_description_empty ( example_result ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_empty , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_empty ( example_result % input % failure_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_asserts ( example_result ) result ( result_ ) use example_asserts_m , only : NUM_ASSERTS_IN_PASSING use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_equals ( NUM_ASSERTS_IN_PASSING , example_result % input % num_asserts ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_failing_asserts ( example_result ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_equals ( 0 , example_result % input % num_failing_asserts ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/passing_case_test.f90.html","title":"passing_case_test.f90 – miniFAVOR"},{"text":"Contents Modules double_precision_generator_m Source Code double_precision_generator_m.f90 Source Code module double_precision_generator_m use vegetables , only : generator_t implicit none private public :: DOUBLE_PRECISION_GENERATOR type , extends ( generator_t ) :: double_precision_generator_t contains private procedure , public :: generate procedure , public , nopass :: shrink end type type ( double_precision_generator_t ) :: DOUBLE_PRECISION_GENERATOR = & double_precision_generator_t () contains function generate ( self ) result ( random_double ) use vegetables , only : & double_precision_input_t , & generated_t , & generated , & get_random_double_precision_with_magnitude class ( double_precision_generator_t ), intent ( in ) :: self type ( generated_t ) :: random_double type ( double_precision_input_t ) :: the_input associate ( a => self ) end associate the_input % value_ = get_random_double_precision_with_magnitude ( 1.0d12 ) random_double = generated ( the_input ) end function pure function shrink ( input ) result ( shrunk ) use vegetables , only : & double_precision_input_t , & input_t , & shrink_result_t , & shrunk_value , & simplest_value class ( input_t ), intent ( in ) :: input type ( shrink_result_t ) :: shrunk type ( double_precision_input_t ) :: new_input select type ( input ) type is ( double_precision_input_t ) if ( effectively_zero ( input % value_ )) then new_input % value_ = 0.0d0 shrunk = simplest_value ( new_input ) else new_input % value_ = input % value_ / 2.0d0 shrunk = shrunk_value ( new_input ) end if end select end function pure function effectively_zero ( value_ ) double precision , intent ( in ) :: value_ logical :: effectively_zero effectively_zero = abs ( value_ ) < epsilon ( value_ ) end function end module","tags":"","loc":"sourcefile/double_precision_generator_m.f90.html","title":"double_precision_generator_m.f90 – miniFAVOR"},{"text":"Contents Modules single_case_properties_test Source Code single_case_properties_test.f90 Source Code module single_case_properties_test implicit none private public :: test_case_properties contains function test_case_properties () result ( test ) use example_cases_m , only : example_passing_test_case use helpers_m , only : test_item_input_t use vegetables , only : test_item_t , describe , it_ type ( test_item_t ) :: test type ( test_item_t ) :: individual_tests ( 3 ) type ( test_item_input_t ) :: the_case the_case % input = example_passing_test_Case () individual_tests ( 1 ) = it_ ( \"includes the given description\" , check_case_description ) individual_tests ( 2 ) = it_ ( \"only has 1 test case\" , check_num_cases ) individual_tests ( 3 ) = it_ ( \"takes less than 3 times as long as the assertions to run\" , check_speed ) test = describe ( \"A test case\" , the_case , individual_tests ) end function pure function check_case_description ( example_case ) result ( result_ ) use example_cases_m , only : EXAMPLE_DESCRIPTION use helpers_m , only : test_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_case type ( result_t ) :: result_ select type ( example_case ) class is ( test_item_input_t ) result_ = assert_includes ( EXAMPLE_DESCRIPTION , example_case % input % description ()) class default result_ = fail ( \"Expected to get a test_item_input_t\" ) end select end function pure function check_num_cases ( example_case ) result ( result_ ) use helpers_m , only : test_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_case type ( result_t ) :: result_ select type ( example_case ) class is ( test_item_input_t ) result_ = assert_equals ( 1 , example_case % input % num_cases ()) class default result_ = fail ( \"Expected to get a test_item_input_t\" ) end select end function function check_speed ( example_case ) result ( result_ ) use helpers_m , only : test_item_input_t use vegetables , only : & input_t , result_t , test_item_t , assert_faster_than , fail class ( input_t ), intent ( in ) :: example_case type ( result_t ) :: result_ type ( test_item_t ) :: internal_case select type ( example_case ) type is ( test_item_input_t ) internal_case = example_case % input result_ = assert_faster_than ( run_assertions , run_case , 100 ) class default result_ = fail ( \"Expected to get a test_item_input_t\" ) end select contains subroutine run_case use vegetables , only : test_result_item_t integer :: i type ( test_result_item_t ) :: internal_result do i = 1 , 100 internal_result = internal_case % run () end do end subroutine subroutine run_assertions use example_asserts_m , only : example_multiple_asserts use vegetables , only : result_t integer :: i type ( result_t ) :: result__ do i = 1 , 300 result__ = example_multiple_asserts () end do end subroutine end function end module","tags":"","loc":"sourcefile/single_case_properties_test.f90.html","title":"single_case_properties_test.f90 – miniFAVOR"},{"text":"Contents Modules example_cases_m Source Code example_cases_m.f90 Source Code module example_cases_m implicit none private public :: & example_failing_test_case , & example_passing_test_case , & EXAMPLE_DESCRIPTION , & NOT_IN_DESCRIPTION character ( len =* ), parameter :: EXAMPLE_DESCRIPTION = \"Example Description\" character ( len =* ), parameter :: NOT_IN_DESCRIPTION = \"NOT\" contains function example_passing_test_case () result ( test_case ) use example_asserts_m , only : example_multiple_asserts use vegetables , only : test_item_t , it type ( test_item_t ) :: test_case test_case = it ( EXAMPLE_DESCRIPTION , example_multiple_asserts ) end function function example_failing_test_case () result ( test_case ) use example_asserts_m , only : example_multiple_asserts_with_fail use vegetables , only : test_item_t , it type ( test_item_t ) :: test_case test_case = it ( EXAMPLE_DESCRIPTION , example_multiple_asserts_with_fail ) end function end module","tags":"","loc":"sourcefile/example_cases_m.f90.html","title":"example_cases_m.f90 – miniFAVOR"},{"text":"Contents Modules collection_properties_test Source Code collection_properties_test.f90 Source Code module collection_properties_test implicit none private public :: test_collection_properties contains function test_collection_properties () result ( test ) use example_collections_m , only : example_passing_collection use helpers_m , only : test_item_input_t use vegetables , only : test_item_t , describe , it_ type ( test_item_t ) :: test type ( test_item_input_t ) :: the_collection type ( test_item_t ) :: individual_tests ( 4 ) the_collection % input = example_passing_collection () individual_tests ( 1 ) = it_ ( \"can tell how many tests it has\" , checkNumCases ) individual_tests ( 2 ) = it_ ( \"includes the given description\" , checkCollectionTopDescription ) individual_tests ( 3 ) = it_ ( \"includes the individual test descriptions\" , checkCollectionDescriptions ) individual_tests ( 4 ) = it_ ( \"Takes less than three times as long as the individual cases\" , checkSpeed ) test = describe ( \"A test collection\" , the_collection , individual_tests ) end function pure function checkNumCases ( example_collection ) result ( result_ ) use example_collections_m , only : NUM_CASES_IN_PASSING use helpers_m , only : test_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_collection type ( result_t ) :: result_ select type ( example_collection ) class is ( test_item_input_t ) result_ = assert_equals ( NUM_CASES_IN_PASSING , example_collection % input % num_cases ()) class default result_ = fail ( \"Expected to get a test_collection_t\" ) end select end function pure function checkCollectionTopDescription ( example_collection ) result ( result_ ) use example_collections_m , only : EXAMPLE_COLLECTION_DESCRIPTION use helpers_m , only : test_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_collection type ( result_t ) :: result_ select type ( example_collection ) class is ( test_item_input_t ) result_ = assert_includes ( & EXAMPLE_COLLECTION_DESCRIPTION , example_collection % input % description ()) class default result_ = fail ( \"Expected to get a test_collection_t\" ) end select end function pure function checkCollectionDescriptions ( example_collection ) result ( result_ ) use example_collections_m , only : & EXAMPLE_CASE_DESCRIPTION_1 , EXAMPLE_CASE_DESCRIPTION_2 use helpers_m , only : test_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_collection type ( result_t ) :: result_ select type ( example_collection ) class is ( test_item_input_t ) result_ = & assert_includes ( & EXAMPLE_CASE_DESCRIPTION_1 , example_collection % input % description ()) & . and . assert_includes ( & EXAMPLE_CASE_DESCRIPTION_2 , example_collection % input % description ()) class default result_ = fail ( \"Expected to get a test_collection_t\" ) end select end function function checkSpeed ( example_collection ) result ( result_ ) use example_collections_m , only : example_test_case_1 , example_test_case_2 use helpers_m , only : test_item_input_t use vegetables , only : & input_t , result_t , test_item_t , assert_faster_than , fail class ( input_t ), intent ( in ) :: example_collection type ( result_t ) :: result_ type ( test_item_t ) :: internal_collection type ( test_item_t ) :: the_cases ( 3 ) the_cases ( 1 ) = example_test_case_1 () the_cases ( 2 ) = example_test_case_2 () the_cases ( 3 ) = example_test_case_2 () select type ( example_collection ) type is ( test_item_input_t ) internal_collection = example_collection % input result_ = assert_faster_than ( runCases , runCollection , 100 ) class default result_ = fail ( \"Expected to get a test_collection_t\" ) end select contains subroutine runCollection use vegetables , only : test_result_item_t integer :: i type ( test_result_item_t ) :: internal_result do i = 1 , 100 internal_result = internal_collection % run () end do end subroutine subroutine runCases use vegetables , only : test_result_item_t integer :: i type ( test_result_item_t ) :: the_results ( 3 ) do i = 1 , 300 the_results ( 1 ) = the_cases ( 1 )% run () the_results ( 2 ) = the_cases ( 2 )% run () the_results ( 3 ) = the_cases ( 3 )% run () end do end subroutine end function end module","tags":"","loc":"sourcefile/collection_properties_test.f90.html","title":"collection_properties_test.f90 – miniFAVOR"},{"text":"Contents Modules filter_test Source Code filter_test.f90 Source Code module filter_test use vegetables , only : input_t , filter_item_result_t implicit none private public :: test_filter_case , test_filter_collection type , extends ( input_t ) :: filter_item_result_input_t type ( filter_item_result_t ) :: input end type contains function test_filter_case () result ( tests ) use example_cases_m , only : example_passing_test_case use helpers_m , only : test_item_input_t use vegetables , only : test_item_t , given , then__ , when type ( test_item_t ) :: tests type ( test_item_t ) :: collection ( 2 ) type ( test_item_input_t ) :: the_case type ( test_item_t ) :: first ( 1 ) type ( test_item_t ) :: second ( 1 ) the_case % input = example_passing_test_case () first ( 1 ) = then__ ( \"it doesn't match\" , check_case_not_matching ) second ( 1 ) = then__ ( \"it returns itself\" , check_case_is_same ) collection ( 1 ) = when ( & \"it is filtered with a string it doesn't contain\" , & filter_case_not_matching , & first ) collection ( 2 ) = when ( & \"it is filtered with a matching string\" , & filter_case_matching , & second ) tests = given ( \"a test case\" , the_case , collection ) end function function test_filter_collection () result ( tests ) use example_collections_m , only : example_passing_collection use helpers_m , only : test_item_input_t use vegetables , only : test_item_t , given , then__ , when type ( test_item_t ) :: tests type ( test_item_t ) :: collection ( 3 ) type ( test_item_input_t ) :: the_collection type ( test_item_t ) :: first ( 1 ) type ( test_item_t ) :: second ( 1 ) type ( test_item_t ) :: third ( 1 ) the_collection % input = example_passing_collection () first ( 1 ) = then__ ( \"it doesn't match\" , check_collection_not_matching ) second ( 1 ) = then__ ( \"it returns itself\" , check_collection_is_same ) third ( 1 ) = then__ ( \"it returns a collection with only that case\" , check_collection_single_case ) collection ( 1 ) = when ( & \"it is filtered with a string it doesn't contain\" , & filter_collection_not_matching , & first ) collection ( 2 ) = when ( & \"it is filtered with a string matching its description\" , & filter_collection_matching_description , & second ) collection ( 3 ) = when ( & \"it is filtered with a string matching only 1 of its cases\" , & filter_collection_matching_case , & third ) tests = given ( \"a test collection\" , the_collection , collection ) end function pure function filter_case_not_matching ( example_case ) result ( filtered ) use example_cases_m , only : NOT_IN_DESCRIPTION use helpers_m , only : test_item_input_t use iso_varying_string , only : var_str use vegetables , only : & input_t , & transformation_failure_t , & transformed_t , & transformed , & fail class ( input_t ), intent ( in ) :: example_case type ( transformed_t ) :: filtered type ( transformation_failure_t ) :: failure type ( filter_item_result_input_t ) :: the_result select type ( example_case ) type is ( test_item_input_t ) the_result % input = example_case % input % filter ( var_str ( NOT_IN_DESCRIPTION )) filtered = transformed ( the_result ) class default failure % result_ = fail ( \"Expected to get a test_item_input_t\" ) filtered = transformed ( failure ) end select end function pure function filter_case_matching ( example_case ) result ( filtered ) use example_cases_m , only : EXAMPLE_DESCRIPTION use helpers_m , only : test_item_input_t use iso_varying_string , only : var_str use vegetables , only : & input_t , & transformation_failure_t , & transformed_t , & transformed , & fail class ( input_t ), intent ( in ) :: example_case type ( transformed_t ) :: filtered type ( transformation_failure_t ) :: failure type ( filter_item_result_input_t ) :: the_result select type ( example_case ) type is ( test_item_input_t ) the_result % input = example_case % input % filter ( var_str ( EXAMPLE_DESCRIPTION )) filtered = transformed ( the_result ) class default failure % result_ = fail ( \"Expected to get a test_item_input_t\" ) filtered = transformed ( failure ) end select end function pure function filter_collection_not_matching ( example_collection ) result ( filtered ) use example_collections_m , only : NOT_IN_DESCRIPTIONS use helpers_m , only : test_item_input_t use iso_varying_string , only : var_str use vegetables , only : & input_t , & transformation_failure_t , & transformed_t , & transformed , & fail class ( input_t ), intent ( in ) :: example_collection type ( transformed_t ) :: filtered type ( transformation_failure_t ) :: failure type ( filter_item_result_input_t ) :: the_result select type ( example_collection ) type is ( test_item_input_t ) the_result % input = example_collection % input % filter ( var_str ( NOT_IN_DESCRIPTIONS )) filtered = transformed ( the_result ) class default failure % result_ = fail ( \"Expected to get a test_item_input_t\" ) filtered = transformed ( failure ) end select end function pure function filter_collection_matching_description ( example_collection ) result ( filtered ) use example_collections_m , only : EXAMPLE_COLLECTION_DESCRIPTION use helpers_m , only : test_item_input_t use iso_varying_string , only : var_str use vegetables , only : & input_t , & transformation_failure_t , & transformed_t , & transformed , & fail class ( input_t ), intent ( in ) :: example_collection type ( transformed_t ) :: filtered type ( transformation_failure_t ) :: failure type ( filter_item_result_input_t ) :: the_result select type ( example_collection ) type is ( test_item_input_t ) the_result % input = example_collection % input % filter ( var_str ( EXAMPLE_COLLECTION_DESCRIPTION )) filtered = transformed ( the_result ) class default failure % result_ = fail ( \"Expected to get a test_item_input_t\" ) filtered = transformed ( failure ) end select end function pure function filter_collection_matching_case ( example_collection ) result ( filtered ) use example_collections_m , only : EXAMPLE_CASE_DESCRIPTION_1 use helpers_m , only : test_item_input_t use iso_varying_string , only : var_str use vegetables , only : & input_t , & transformation_failure_t , & transformed_t , & transformed , & fail class ( input_t ), intent ( in ) :: example_collection type ( transformed_t ) :: filtered type ( transformation_failure_t ) :: failure type ( filter_item_result_input_t ) :: the_result select type ( example_collection ) type is ( test_item_input_t ) the_result % input = example_collection % input % filter ( var_str ( EXAMPLE_CASE_DESCRIPTION_1 )) filtered = transformed ( the_result ) class default failure % result_ = fail ( \"Expected to get a test_item_input_t\" ) filtered = transformed ( failure ) end select end function pure function check_case_not_matching ( filtered ) result ( result_ ) use vegetables , only : input_t , result_t , assert_not , fail class ( input_t ), intent ( in ) :: filtered type ( result_t ) :: result_ select type ( filtered ) type is ( filter_item_result_input_t ) result_ = assert_not ( filtered % input % matched ) class default result_ = fail ( \"Expected to get filter_item_result_input_t\" ) end select end function pure function check_case_is_same ( filtered ) result ( result_ ) use example_cases_m , only : EXAMPLE_DESCRIPTION use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: filtered type ( result_t ) :: result_ select type ( filtered ) type is ( filter_item_result_input_t ) result_ = assert_equals ( EXAMPLE_DESCRIPTION , filtered % input % test % description ()) class default result_ = fail ( \"Expected to get filter_item_result_input_t\" ) end select end function pure function check_collection_not_matching ( filtered ) result ( result_ ) use vegetables , only : input_t , result_t , assert_not , fail class ( input_t ), intent ( in ) :: filtered type ( result_t ) :: result_ select type ( filtered ) type is ( filter_item_result_input_t ) result_ = assert_not ( filtered % input % matched ) class default result_ = fail ( \"Expected to get filter_item_result_input_t\" ) end select end function function check_collection_is_same ( filtered ) result ( result_ ) use example_collections_m , only : example_passing_collection use vegetables , only : input_t , result_t , test_item_t , assert_equals , fail class ( input_t ), intent ( in ) :: filtered type ( result_t ) :: result_ type ( test_item_t ) :: example_collection select type ( filtered ) type is ( filter_item_result_input_t ) example_collection = example_passing_collection () result_ = assert_equals ( example_collection % description (), filtered % input % test % description ()) class default result_ = fail ( \"Expected to get filter_item_result_input_t\" ) end select end function pure function check_collection_single_case ( filtered ) result ( result_ ) use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: filtered type ( result_t ) :: result_ select type ( filtered ) type is ( filter_item_result_input_t ) result_ = assert_equals ( 1 , filtered % input % test % num_cases ()) class default result_ = fail ( \"Expected to get filter_item_result_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/filter_test.f90.html","title":"filter_test.f90 – miniFAVOR"},{"text":"Contents Modules assert_empty_test Source Code assert_empty_test.f90 Source Code module assert_empty_test implicit none private public :: test_assert_empty character ( len =* ), parameter :: BOTH_MESSAGE = \"Both Message\" character ( len =* ), parameter :: SUCCESS_MESSAGE = \"Success Message\" character ( len =* ), parameter :: FAILURE_MESSAGE = \"Failure Message\" contains function test_assert_empty () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( \"passes with an empty character\" , check_pass_for_empty_chars ) individual_tests ( 2 ) = it ( \"fails with a non empty character\" , check_fails_for_nonempty_chars ) tests = describe ( \"assert_empty\" , individual_tests ) end function pure function check_pass_for_empty_chars () result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : result_t , assert_empty , assert_that type ( result_t ) :: result_ character ( len =* ), parameter :: EMPTY = \"\" type ( result_t ) :: example_result_c type ( result_t ) :: example_result_s type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss type ( result_t ) :: example_result_ccc type ( result_t ) :: example_result_ccs type ( result_t ) :: example_result_csc type ( result_t ) :: example_result_css type ( result_t ) :: example_result_scc type ( result_t ) :: example_result_scs type ( result_t ) :: example_result_ssc type ( result_t ) :: example_result_sss example_result_c = assert_empty ( EMPTY ) example_result_s = assert_empty ( var_str ( EMPTY )) example_result_cc = assert_empty ( EMPTY , BOTH_MESSAGE ) example_result_cs = assert_empty ( EMPTY , var_str ( BOTH_MESSAGE )) example_result_sc = assert_empty ( var_str ( EMPTY ), BOTH_MESSAGE ) example_result_ss = assert_empty ( var_str ( EMPTY ), var_str ( BOTH_MESSAGE )) example_result_ccc = assert_empty ( & EMPTY , SUCCESS_MESSAGE , FAILURE_MESSAGE ) example_result_ccs = assert_empty ( & EMPTY , SUCCESS_MESSAGE , var_str ( FAILURE_MESSAGE )) example_result_csc = assert_empty ( & EMPTY , var_str ( SUCCESS_MESSAGE ), FAILURE_MESSAGE ) example_result_css = assert_empty ( & EMPTY , var_str ( SUCCESS_MESSAGE ), var_str ( FAILURE_MESSAGE )) example_result_scc = assert_empty ( & var_str ( EMPTY ), SUCCESS_MESSAGE , FAILURE_MESSAGE ) example_result_scs = assert_empty ( & var_str ( EMPTY ), SUCCESS_MESSAGE , var_str ( FAILURE_MESSAGE )) example_result_ssc = assert_empty ( & var_str ( EMPTY ), var_str ( SUCCESS_MESSAGE ), FAILURE_MESSAGE ) example_result_sss = assert_empty ( & var_str ( EMPTY ), var_str ( SUCCESS_MESSAGE ), var_str ( FAILURE_MESSAGE )) result_ = & assert_that ( & example_result_c % passed (), & example_result_c % verbose_description (. false .)) & . and . assert_that ( & example_result_s % passed (), & example_result_s % verbose_description (. false .)) & . and . assert_that ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_that ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_that ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_that ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) & . and . assert_that ( & example_result_ccc % passed (), & example_result_ccc % verbose_description (. false .)) & . and . assert_that ( & example_result_ccs % passed (), & example_result_ccs % verbose_description (. false .)) & . and . assert_that ( & example_result_csc % passed (), & example_result_csc % verbose_description (. false .)) & . and . assert_that ( & example_result_css % passed (), & example_result_css % verbose_description (. false .)) & . and . assert_that ( & example_result_scc % passed (), & example_result_scc % verbose_description (. false .)) & . and . assert_that ( & example_result_scs % passed (), & example_result_scs % verbose_description (. false .)) & . and . assert_that ( & example_result_ssc % passed (), & example_result_ssc % verbose_description (. false .)) & . and . assert_that ( & example_result_sss % passed (), & example_result_sss % verbose_description (. false .)) end function pure function check_fails_for_nonempty_chars () result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : result_t , assert_empty , assert_not type ( result_t ) :: result_ character ( len =* ), parameter :: NOT_EMPTY = \"Not Empty\" type ( result_t ) :: example_result_c type ( result_t ) :: example_result_s type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss type ( result_t ) :: example_result_ccc type ( result_t ) :: example_result_ccs type ( result_t ) :: example_result_csc type ( result_t ) :: example_result_css type ( result_t ) :: example_result_scc type ( result_t ) :: example_result_scs type ( result_t ) :: example_result_ssc type ( result_t ) :: example_result_sss example_result_c = assert_empty ( NOT_EMPTY ) example_result_s = assert_empty ( var_str ( NOT_EMPTY )) example_result_cc = assert_empty ( NOT_EMPTY , BOTH_MESSAGE ) example_result_cs = assert_empty ( NOT_EMPTY , var_str ( BOTH_MESSAGE )) example_result_sc = assert_empty ( var_str ( NOT_EMPTY ), BOTH_MESSAGE ) example_result_ss = assert_empty ( var_str ( NOT_EMPTY ), var_str ( BOTH_MESSAGE )) example_result_ccc = assert_empty ( & NOT_EMPTY , SUCCESS_MESSAGE , FAILURE_MESSAGE ) example_result_ccs = assert_empty ( & NOT_EMPTY , SUCCESS_MESSAGE , var_str ( FAILURE_MESSAGE )) example_result_csc = assert_empty ( & NOT_EMPTY , var_str ( SUCCESS_MESSAGE ), FAILURE_MESSAGE ) example_result_css = assert_empty ( & NOT_EMPTY , var_str ( SUCCESS_MESSAGE ), var_str ( FAILURE_MESSAGE )) example_result_scc = assert_empty ( & var_str ( NOT_EMPTY ), SUCCESS_MESSAGE , FAILURE_MESSAGE ) example_result_scs = assert_empty ( & var_str ( NOT_EMPTY ), SUCCESS_MESSAGE , var_str ( FAILURE_MESSAGE )) example_result_ssc = assert_empty ( & var_str ( NOT_EMPTY ), var_str ( SUCCESS_MESSAGE ), FAILURE_MESSAGE ) example_result_sss = assert_empty ( & var_str ( NOT_EMPTY ), var_str ( SUCCESS_MESSAGE ), var_str ( FAILURE_MESSAGE )) result_ = & assert_not ( & example_result_c % passed (), & example_result_c % verbose_description (. false .)) & . and . assert_not ( & example_result_s % passed (), & example_result_s % verbose_description (. false .)) & . and . assert_not ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_not ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_not ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_not ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) & . and . assert_not ( & example_result_ccc % passed (), & example_result_ccc % verbose_description (. false .)) & . and . assert_not ( & example_result_ccs % passed (), & example_result_ccs % verbose_description (. false .)) & . and . assert_not ( & example_result_csc % passed (), & example_result_csc % verbose_description (. false .)) & . and . assert_not ( & example_result_css % passed (), & example_result_css % verbose_description (. false .)) & . and . assert_not ( & example_result_scc % passed (), & example_result_scc % verbose_description (. false .)) & . and . assert_not ( & example_result_scs % passed (), & example_result_scs % verbose_description (. false .)) & . and . assert_not ( & example_result_ssc % passed (), & example_result_ssc % verbose_description (. false .)) & . and . assert_not ( & example_result_sss % passed (), & example_result_sss % verbose_description (. false .)) end function end module","tags":"","loc":"sourcefile/assert_empty_test.f90.html","title":"assert_empty_test.f90 – miniFAVOR"},{"text":"Contents Modules failing_case_test Source Code failing_case_test.f90 Source Code module failing_case_test implicit none private public :: test_failing_case_behaviors contains function test_failing_case_behaviors () result ( test ) use example_cases_m , only : example_failing_test_case use helpers_m , only : test_item_input_t , run_test use vegetables , only : test_item_t , given , then__ , when type ( test_item_t ) :: test type ( test_item_t ) :: collection ( 1 ) type ( test_item_input_t ) :: the_case type ( test_item_t ) :: individual_tests ( 11 ) the_case % input = example_failing_test_Case () individual_tests ( 1 ) = then__ ( \"it knows it failed\" , check_case_fails ) individual_tests ( 2 ) = then__ ( \"it has 1 test case\" , check_num_cases ) individual_tests ( 3 ) = then__ ( \"it has 1 failing case\" , check_num_failing_cases ) individual_tests ( 4 ) = then__ ( \"it's verbose description includes the given description\" , check_verbose_for_given_description ) individual_tests ( 5 ) = then__ ( \"it's verbose description includes the success message\" , check_verbose_for_success_message ) individual_tests ( 6 ) = then__ ( \"it's verbose description includes the failure message\" , check_verbose_for_failure_message ) individual_tests ( 7 ) = then__ ( \"it's failure description includes the given description\" , check_failure_for_given_description ) individual_tests ( 8 ) = then__ ( \"it's failure description includes the failure message\" , check_failure_for_failure_message ) individual_tests ( 9 ) = then__ ( & \"it's failure description doesn't include the success message\" , check_failure_no_success_message ) individual_tests ( 10 ) = then__ ( \"it knows how many asserts there were\" , check_num_asserts ) individual_tests ( 11 ) = then__ ( \"it knows how many asserts failed\" , check_num_failing_asserts ) collection ( 1 ) = when ( \"it is run\" , run_test , individual_tests ) test = given ( \"a failing test case\" , the_case , collection ) end function pure function check_case_fails ( example_result ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_not , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_not ( example_result % input % passed ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_cases ( example_result ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_equals ( 1 , example_result % input % num_cases ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_failing_cases ( example_result ) result ( result_ ) use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_equals ( 1 , example_result % input % num_failing_cases ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_verbose_for_given_description ( example_result ) result ( result_ ) use example_cases_m , only : EXAMPLE_DESCRIPTION use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_includes ( EXAMPLE_DESCRIPTION , example_result % input % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_verbose_for_success_message ( example_result ) result ( result_ ) use example_asserts_m , only : SUCCESS_MESSAGE use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_includes ( SUCCESS_MESSAGE , example_result % input % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_verbose_for_failure_message ( example_result ) result ( result_ ) use example_asserts_m , only : FAILURE_MESSAGE use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_includes ( FAILURE_MESSAGE , example_result % input % verbose_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_failure_for_given_description ( example_result ) result ( result_ ) use example_cases_m , only : EXAMPLE_DESCRIPTION use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_includes ( EXAMPLE_DESCRIPTION , example_result % input % failure_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_failure_for_failure_message ( example_result ) result ( result_ ) use example_asserts_m , only : FAILURE_MESSAGE use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_includes , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_includes ( FAILURE_MESSAGE , example_result % input % failure_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_failure_no_success_message ( example_result ) result ( result_ ) use example_asserts_m , only : SUCCESS_MESSAGE use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_doesnt_include , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_doesnt_include ( SUCCESS_MESSAGE , example_result % input % failure_description (. false .)) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_asserts ( example_result ) result ( result_ ) use example_asserts_m , only : NUM_ASSERTS_IN_FAILING use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_equals ( NUM_ASSERTS_IN_FAILING , example_result % input % num_asserts ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function pure function check_num_failing_asserts ( example_result ) result ( result_ ) use example_asserts_m , only : NUM_FAILING_ASSERTS_IN_FAILING use helpers_m , only : test_result_item_input_t use vegetables , only : input_t , result_t , assert_equals , fail class ( input_t ), intent ( in ) :: example_result type ( result_t ) :: result_ select type ( example_result ) type is ( test_result_item_input_t ) result_ = assert_equals ( & NUM_FAILING_ASSERTS_IN_FAILING , example_result % input % num_failing_asserts ()) class default result_ = fail ( \"Expected to get a test_result_item_input_t\" ) end select end function end module","tags":"","loc":"sourcefile/failing_case_test.f90.html","title":"failing_case_test.f90 – miniFAVOR"},{"text":"Contents Modules assert_includes_test Source Code assert_includes_test.f90 Source Code module assert_includes_test implicit none private public :: test_assert_includes character ( len =* ), parameter :: BOTH_MESSAGE = \"Both Message\" character ( len =* ), parameter :: SUCCESS_MESSAGE = \"Success Message\" character ( len =* ), parameter :: FAILURE_MESSAGE = \"Failure Message\" contains function test_assert_includes () result ( tests ) use vegetables , only : test_item_t , describe , it , ASCII_STRING_GENERATOR type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( \"passes with the same strings\" , ASCII_STRING_GENERATOR , check_pass_for_same_strings ) individual_tests ( 2 ) = it ( \"fails when the string isn't included\" , check_fail_for_different_strings ) tests = describe ( \"assert_includes\" , individual_tests ) end function pure function check_pass_for_same_strings ( the_example ) result ( result_ ) use iso_varying_string , only : varying_string , var_str , char use vegetables , only : & input_t , & result_t , & string_input_t , & assert_includes , & assert_that , & fail class ( input_t ), intent ( in ) :: the_example type ( result_t ) :: result_ type ( varying_string ) :: example type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss type ( result_t ) :: example_result_ccc type ( result_t ) :: example_result_ccs type ( result_t ) :: example_result_csc type ( result_t ) :: example_result_css type ( result_t ) :: example_result_scc type ( result_t ) :: example_result_scs type ( result_t ) :: example_result_ssc type ( result_t ) :: example_result_sss type ( result_t ) :: example_result_cccc type ( result_t ) :: example_result_cccs type ( result_t ) :: example_result_ccsc type ( result_t ) :: example_result_ccss type ( result_t ) :: example_result_cscc type ( result_t ) :: example_result_cscs type ( result_t ) :: example_result_cssc type ( result_t ) :: example_result_csss type ( result_t ) :: example_result_sccc type ( result_t ) :: example_result_sccs type ( result_t ) :: example_result_scsc type ( result_t ) :: example_result_scss type ( result_t ) :: example_result_sscc type ( result_t ) :: example_result_sscs type ( result_t ) :: example_result_sssc type ( result_t ) :: example_result_ssss select type ( the_example ) type is ( string_input_t ) example = the_example % value_ example_result_cc = assert_includes ( char ( example ), char ( example )) example_result_cs = assert_includes ( char ( example ), example ) example_result_sc = assert_includes ( example , char ( example )) example_result_ss = assert_includes ( example , example ) example_result_ccc = assert_includes ( & char ( example ), char ( example ), BOTH_MESSAGE ) example_result_ccs = assert_includes ( & char ( example ), char ( example ), var_str ( BOTH_MESSAGE )) example_result_csc = assert_includes ( & char ( example ), example , BOTH_MESSAGE ) example_result_css = assert_includes ( & char ( example ), example , var_str ( BOTH_MESSAGE )) example_result_scc = assert_includes ( & example , char ( example ), BOTH_MESSAGE ) example_result_scs = assert_includes ( & example , char ( example ), var_str ( BOTH_MESSAGE )) example_result_ssc = assert_includes ( & example , example , BOTH_MESSAGE ) example_result_sss = assert_includes ( & example , example , var_str ( BOTH_MESSAGE )) example_result_cccc = assert_includes ( & char ( example ), & char ( example ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cccs = assert_includes ( & char ( example ), & char ( example ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_ccsc = assert_includes ( & char ( example ), & char ( example ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ccss = assert_includes ( & char ( example ), & char ( example ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_cscc = assert_includes ( & char ( example ), & example , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cscs = assert_includes ( & char ( example ), & example , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_cssc = assert_includes ( & char ( example ), & example , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_csss = assert_includes ( & char ( example ), & example , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_sccc = assert_includes ( & example , & char ( example ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_sccs = assert_includes ( & example , & char ( example ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_scsc = assert_includes ( & example , & char ( example ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_scss = assert_includes ( & example , & char ( example ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_sscc = assert_includes ( & example , & example , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_sscs = assert_includes ( & example , & example , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_sssc = assert_includes ( & example , & example , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ssss = assert_includes ( & example , & example , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) result_ = & assert_that ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_that ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_that ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_that ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) & . and . assert_that ( & example_result_ccc % passed (), & example_result_ccc % verbose_description (. false .)) & . and . assert_that ( & example_result_ccs % passed (), & example_result_ccs % verbose_description (. false .)) & . and . assert_that ( & example_result_csc % passed (), & example_result_csc % verbose_description (. false .)) & . and . assert_that ( & example_result_css % passed (), & example_result_css % verbose_description (. false .)) & . and . assert_that ( & example_result_scc % passed (), & example_result_scc % verbose_description (. false .)) & . and . assert_that ( & example_result_scs % passed (), & example_result_scs % verbose_description (. false .)) & . and . assert_that ( & example_result_ssc % passed (), & example_result_ssc % verbose_description (. false .)) & . and . assert_that ( & example_result_sss % passed (), & example_result_sss % verbose_description (. false .)) & . and . assert_that ( & example_result_cccc % passed (), & example_result_cccc % verbose_description (. false .)) & . and . assert_that ( & example_result_cccs % passed (), & example_result_cccs % verbose_description (. false .)) & . and . assert_that ( & example_result_ccsc % passed (), & example_result_ccsc % verbose_description (. false .)) & . and . assert_that ( & example_result_ccss % passed (), & example_result_ccss % verbose_description (. false .)) & . and . assert_that ( & example_result_cscc % passed (), & example_result_cscc % verbose_description (. false .)) & . and . assert_that ( & example_result_cscs % passed (), & example_result_cscs % verbose_description (. false .)) & . and . assert_that ( & example_result_cssc % passed (), & example_result_cssc % verbose_description (. false .)) & . and . assert_that ( & example_result_csss % passed (), & example_result_csss % verbose_description (. false .)) & . and . assert_that ( & example_result_sccc % passed (), & example_result_sccc % verbose_description (. false .)) & . and . assert_that ( & example_result_sccs % passed (), & example_result_sccs % verbose_description (. false .)) & . and . assert_that ( & example_result_scsc % passed (), & example_result_scsc % verbose_description (. false .)) & . and . assert_that ( & example_result_scss % passed (), & example_result_scss % verbose_description (. false .)) & . and . assert_that ( & example_result_sscc % passed (), & example_result_sscc % verbose_description (. false .)) & . and . assert_that ( & example_result_sscs % passed (), & example_result_sscs % verbose_description (. false .)) & . and . assert_that ( & example_result_sssc % passed (), & example_result_sssc % verbose_description (. false .)) & . and . assert_that ( & example_result_ssss % passed (), & example_result_ssss % verbose_description (. false .)) class default result_ = fail ( \"Expected a character string\" ) end select end function pure function check_fail_for_different_strings () result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : result_t , assert_includes , assert_not type ( result_t ) :: result_ character ( len =* ), parameter :: ONE_STRNIG = \"One String\" character ( len =* ), parameter :: OTHER_STRING = \"Other String\" type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss type ( result_t ) :: example_result_ccc type ( result_t ) :: example_result_ccs type ( result_t ) :: example_result_csc type ( result_t ) :: example_result_css type ( result_t ) :: example_result_scc type ( result_t ) :: example_result_scs type ( result_t ) :: example_result_ssc type ( result_t ) :: example_result_sss type ( result_t ) :: example_result_cccc type ( result_t ) :: example_result_cccs type ( result_t ) :: example_result_ccsc type ( result_t ) :: example_result_ccss type ( result_t ) :: example_result_cscc type ( result_t ) :: example_result_cscs type ( result_t ) :: example_result_cssc type ( result_t ) :: example_result_csss type ( result_t ) :: example_result_sccc type ( result_t ) :: example_result_sccs type ( result_t ) :: example_result_scsc type ( result_t ) :: example_result_scss type ( result_t ) :: example_result_sscc type ( result_t ) :: example_result_sscs type ( result_t ) :: example_result_sssc type ( result_t ) :: example_result_ssss example_result_cc = assert_includes ( ONE_STRNIG , OTHER_STRING ) example_result_cs = assert_includes ( ONE_STRNIG , var_str ( OTHER_STRING )) example_result_sc = assert_includes ( var_str ( ONE_STRNIG ), OTHER_STRING ) example_result_ss = assert_includes ( var_str ( ONE_STRNIG ), var_str ( OTHER_STRING )) example_result_ccc = assert_includes ( & ONE_STRNIG , OTHER_STRING , BOTH_MESSAGE ) example_result_ccs = assert_includes ( & ONE_STRNIG , OTHER_STRING , var_str ( BOTH_MESSAGE )) example_result_csc = assert_includes ( & ONE_STRNIG , var_str ( OTHER_STRING ), BOTH_MESSAGE ) example_result_css = assert_includes ( & ONE_STRNIG , var_str ( OTHER_STRING ), var_str ( BOTH_MESSAGE )) example_result_scc = assert_includes ( & var_str ( ONE_STRNIG ), OTHER_STRING , BOTH_MESSAGE ) example_result_scs = assert_includes ( & var_str ( ONE_STRNIG ), OTHER_STRING , var_str ( BOTH_MESSAGE )) example_result_ssc = assert_includes ( & var_str ( ONE_STRNIG ), var_str ( OTHER_STRING ), BOTH_MESSAGE ) example_result_sss = assert_includes ( & var_str ( ONE_STRNIG ), var_str ( OTHER_STRING ), var_str ( BOTH_MESSAGE )) example_result_cccc = assert_includes ( & ONE_STRNIG , & OTHER_STRING , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cccs = assert_includes ( & ONE_STRNIG , & OTHER_STRING , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_ccsc = assert_includes ( & ONE_STRNIG , & OTHER_STRING , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ccss = assert_includes ( & ONE_STRNIG , & OTHER_STRING , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_cscc = assert_includes ( & ONE_STRNIG , & var_str ( OTHER_STRING ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_cscs = assert_includes ( & ONE_STRNIG , & var_str ( OTHER_STRING ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_cssc = assert_includes ( & ONE_STRNIG , & var_str ( OTHER_STRING ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_csss = assert_includes ( & ONE_STRNIG , & var_str ( OTHER_STRING ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_sccc = assert_includes ( & var_str ( ONE_STRNIG ), & OTHER_STRING , & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_sccs = assert_includes ( & var_str ( ONE_STRNIG ), & OTHER_STRING , & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_scsc = assert_includes ( & var_str ( ONE_STRNIG ), & OTHER_STRING , & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_scss = assert_includes ( & var_str ( ONE_STRNIG ), & OTHER_STRING , & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) example_result_sscc = assert_includes ( & var_str ( ONE_STRNIG ), & var_str ( OTHER_STRING ), & SUCCESS_MESSAGE , & FAILURE_MESSAGE ) example_result_sscs = assert_includes ( & var_str ( ONE_STRNIG ), & var_str ( OTHER_STRING ), & SUCCESS_MESSAGE , & var_str ( FAILURE_MESSAGE )) example_result_sssc = assert_includes ( & var_str ( ONE_STRNIG ), & var_str ( OTHER_STRING ), & var_str ( SUCCESS_MESSAGE ), & FAILURE_MESSAGE ) example_result_ssss = assert_includes ( & var_str ( ONE_STRNIG ), & var_str ( OTHER_STRING ), & var_str ( SUCCESS_MESSAGE ), & var_str ( FAILURE_MESSAGE )) result_ = & assert_not ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_not ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_not ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_not ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) & . and . assert_not ( & example_result_ccc % passed (), & example_result_ccc % verbose_description (. false .)) & . and . assert_not ( & example_result_ccs % passed (), & example_result_ccs % verbose_description (. false .)) & . and . assert_not ( & example_result_csc % passed (), & example_result_csc % verbose_description (. false .)) & . and . assert_not ( & example_result_css % passed (), & example_result_css % verbose_description (. false .)) & . and . assert_not ( & example_result_scc % passed (), & example_result_scc % verbose_description (. false .)) & . and . assert_not ( & example_result_scs % passed (), & example_result_scs % verbose_description (. false .)) & . and . assert_not ( & example_result_ssc % passed (), & example_result_ssc % verbose_description (. false .)) & . and . assert_not ( & example_result_sss % passed (), & example_result_sss % verbose_description (. false .)) & . and . assert_not ( & example_result_cccc % passed (), & example_result_cccc % verbose_description (. false .)) & . and . assert_not ( & example_result_cccs % passed (), & example_result_cccs % verbose_description (. false .)) & . and . assert_not ( & example_result_ccsc % passed (), & example_result_ccsc % verbose_description (. false .)) & . and . assert_not ( & example_result_ccss % passed (), & example_result_ccss % verbose_description (. false .)) & . and . assert_not ( & example_result_cscc % passed (), & example_result_cscc % verbose_description (. false .)) & . and . assert_not ( & example_result_cscs % passed (), & example_result_cscs % verbose_description (. false .)) & . and . assert_not ( & example_result_cssc % passed (), & example_result_cssc % verbose_description (. false .)) & . and . assert_not ( & example_result_csss % passed (), & example_result_csss % verbose_description (. false .)) & . and . assert_not ( & example_result_sccc % passed (), & example_result_sccc % verbose_description (. false .)) & . and . assert_not ( & example_result_sccs % passed (), & example_result_sccs % verbose_description (. false .)) & . and . assert_not ( & example_result_scsc % passed (), & example_result_scsc % verbose_description (. false .)) & . and . assert_not ( & example_result_scss % passed (), & example_result_scss % verbose_description (. false .)) & . and . assert_not ( & example_result_sscc % passed (), & example_result_sscc % verbose_description (. false .)) & . and . assert_not ( & example_result_sscs % passed (), & example_result_sscs % verbose_description (. false .)) & . and . assert_not ( & example_result_sssc % passed (), & example_result_sssc % verbose_description (. false .)) & . and . assert_not ( & example_result_ssss % passed (), & example_result_ssss % verbose_description (. false .)) end function end module","tags":"","loc":"sourcefile/assert_includes_test.f90.html","title":"assert_includes_test.f90 – miniFAVOR"},{"text":"Contents Modules example_asserts_m Source Code example_asserts_m.f90 Source Code module example_asserts_m implicit none private public :: & example_multiple_asserts , & example_multiple_asserts_with_fail , & FAILURE_MESSAGE , & NUM_ASSERTS_IN_FAILING , & NUM_ASSERTS_IN_PASSING , & NUM_FAILING_ASSERTS_IN_FAILING , & NUM_PASSING_ASSERTS_IN_FAILING , & SUCCESS_MESSAGE character ( len =* ), parameter :: FAILURE_MESSAGE = \"Failure Message\" integer , parameter :: NUM_FAILING_ASSERTS_IN_FAILING = 1 integer , parameter :: NUM_PASSING_ASSERTS_IN_FAILING = 1 integer , parameter :: NUM_ASSERTS_IN_FAILING = & NUM_FAILING_ASSERTS_IN_FAILING + NUM_PASSING_ASSERTS_IN_FAILING integer , parameter :: NUM_ASSERTS_IN_PASSING = 2 character ( len =* ), parameter :: SUCCESS_MESSAGE = \"Success Message\" contains pure function example_multiple_asserts () result ( result_ ) use vegetables , only : result_t , succeed type ( result_t ) :: result_ result_ = succeed ( SUCCESS_MESSAGE ). and . succeed ( SUCCESS_MESSAGE ) end function pure function example_multiple_asserts_with_fail () result ( result_ ) use vegetables , only : result_t , fail , succeed type ( result_t ) :: result_ result_ = succeed ( SUCCESS_MESSAGE ). and . fail ( FAILURE_MESSAGE ) end function end module","tags":"","loc":"sourcefile/example_asserts_m.f90.html","title":"example_asserts_m.f90 – miniFAVOR"},{"text":"Contents Modules assert_equals_integers_test Source Code assert_equals_integers_test.f90 Source Code module assert_equals_integers_test implicit none private public :: test_assert_equals_integers character ( len =* ), parameter :: BOTH_MESSAGE = \"Both Message\" character ( len =* ), parameter :: SUCCESS_MESSAGE = \"Success Message\" character ( len =* ), parameter :: FAILURE_MESSAGE = \"Failure Message\" contains function test_assert_equals_integers () result ( tests ) use vegetables , only : test_item_t , describe , it , INTEGER_GENERATOR type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( \"passes with the same integer\" , INTEGER_GENERATOR , check_pass_for_same_integer ) individual_tests ( 2 ) = it ( \"fails with different integers\" , check_fail_for_different_integers ) tests = describe ( \"assert_equals with integers\" , individual_tests ) end function pure function check_pass_for_same_integer ( the_input ) result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : & input_t , & integer_input_t , & result_t , & assert_equals , & assert_that , & fail class ( input_t ), intent ( in ) :: the_input type ( result_t ) :: result_ type ( result_t ) :: example_result type ( result_t ) :: example_result_c type ( result_t ) :: example_result_s type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss integer :: input select type ( the_input ) type is ( integer_input_t ) input = the_input % value_ example_result = assert_equals ( input , input ) example_result_c = assert_equals ( input , input , BOTH_MESSAGE ) example_result_s = assert_equals ( input , input , var_str ( BOTH_MESSAGE )) example_result_cc = assert_equals ( & input , input , SUCCESS_MESSAGE , FAILURE_MESSAGE ) example_result_cs = assert_equals ( & input , input , SUCCESS_MESSAGE , var_str ( FAILURE_MESSAGE )) example_result_sc = assert_equals ( & input , input , var_str ( SUCCESS_MESSAGE ), FAILURE_MESSAGE ) example_result_ss = assert_equals ( & input , input , var_str ( SUCCESS_MESSAGE ), var_str ( FAILURE_MESSAGE )) result_ = & assert_that ( & example_result % passed (), & example_result % verbose_description (. false .)) & . and . assert_that ( & example_result_c % passed (), & example_result_c % verbose_description (. false .)) & . and . assert_that ( & example_result_s % passed (), & example_result_s % verbose_description (. false .)) & . and . assert_that ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_that ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_that ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_that ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) class default result_ = fail ( \"Expected to get an integer\" ) end select end function pure function check_fail_for_different_integers () result ( result_ ) use iso_varying_string , only : var_str use vegetables , only : result_t , assert_equals , assert_not type ( result_t ) :: result_ type ( result_t ) :: example_result type ( result_t ) :: example_result_c type ( result_t ) :: example_result_s type ( result_t ) :: example_result_cc type ( result_t ) :: example_result_cs type ( result_t ) :: example_result_sc type ( result_t ) :: example_result_ss example_result = assert_equals ( 1 , 2 ) example_result_c = assert_equals ( 1 , 2 , BOTH_MESSAGE ) example_result_s = assert_equals ( 1 , 2 , var_str ( BOTH_MESSAGE )) example_result_cc = assert_equals ( & 1 , 2 , SUCCESS_MESSAGE , FAILURE_MESSAGE ) example_result_cs = assert_equals ( & 1 , 2 , SUCCESS_MESSAGE , var_str ( FAILURE_MESSAGE )) example_result_sc = assert_equals ( & 1 , 2 , var_str ( SUCCESS_MESSAGE ), FAILURE_MESSAGE ) example_result_ss = assert_equals ( & 1 , 2 , var_str ( SUCCESS_MESSAGE ), var_str ( FAILURE_MESSAGE )) result_ = & assert_not ( & example_result % passed (), & example_result % verbose_description (. false .)) & . and . assert_not ( & example_result_c % passed (), & example_result_c % verbose_description (. false .)) & . and . assert_not ( & example_result_s % passed (), & example_result_s % verbose_description (. false .)) & . and . assert_not ( & example_result_cc % passed (), & example_result_cc % verbose_description (. false .)) & . and . assert_not ( & example_result_cs % passed (), & example_result_cs % verbose_description (. false .)) & . and . assert_not ( & example_result_sc % passed (), & example_result_sc % verbose_description (. false .)) & . and . assert_not ( & example_result_ss % passed (), & example_result_ss % verbose_description (. false .)) end function end module","tags":"","loc":"sourcefile/assert_equals_integers_test.f90.html","title":"assert_equals_integers_test.f90 – miniFAVOR"},{"text":"Contents Modules helpers_m Source Code Helpers_m.f90 Source Code module helpers_m use vegetables , only : input_t , test_item_t , test_result_item_t implicit none private public :: test_item_input_t , test_result_item_input_t , run_test type , extends ( input_t ) :: test_item_input_t type ( test_item_t ) :: input end type type , extends ( input_t ) :: test_result_item_input_t type ( test_result_item_t ) :: input end type contains function run_test ( example_test ) result ( example_result ) use vegetables , only : & input_t , & transformed_t , & transformation_failure_t , & fail , & transformed class ( input_t ), intent ( in ) :: example_test type ( transformed_t ) :: example_result type ( transformation_failure_t ) :: failure type ( test_result_item_input_t ) :: the_result select type ( example_test ) type is ( test_item_input_t ) the_result % input = example_test % input % run () example_result = transformed ( the_result ) class default failure % result_ = fail ( \"Expected to get a test_item_input_t\" ) example_result = transformed ( failure ) end select end function end module","tags":"","loc":"sourcefile/helpers_m.f90.html","title":"Helpers_m.f90 – miniFAVOR"},{"text":"Contents Modules vegetables Source Code vegetables.f90 Source Code module vegetables use iso_varying_string , only : varying_string implicit none private public :: & ascii_string_generator_t , & double_precision_input_t , & example_t , & generated_t , & generator_t , & input_t , & input_test_case_t , & integer_generator_t , & integer_input_t , & result_t , & shrink_result_t , & simple_test_case_t , & simple_test_collection_t , & string_input_t , & test_case_t , & test_case_result_t , & test_case_with_examples_t , & test_case_with_generator_t , & test_collection_t , & test_collection_result_t , & test_collection_with_input_t , & test_item_t , & test_result_item_t , & transformed_t , & transforming_test_collection_t , & assert_doesnt_include , & assert_empty , & assert_equals , & assert_equals_within_absolute , & assert_equals_within_relative , & assert_faster_than , & assert_includes , & assert_not , & assert_that , & delimit , & describe , & example , & fail , & generated , & get_random_ascii_character , & get_random_ascii_string , & get_random_ascii_string_with_max_length , & get_random_double_precision_with_magnitude , & get_random_double_precision_with_range , & get_random_integer , & get_random_integer_with_range , & get_random_logical , & given , & it , & it_ , & make_doesnt_include_failure_message , & make_doesnt_include_success_message , & make_empty_failure_message , & make_equals_failure_message , & make_equals_success_message , & make_faster_than_failure_message , & make_faster_than_success_message , & make_includes_failure_message , & make_includes_success_message , & make_within_failure_message , & make_within_success_message , & run_tests , & shrunk_value , & simplest_value , & succeed , & test_that , & then_ , & then__ , & transformed , & when , & with_user_message type :: options_t private logical :: colorize logical :: quiet logical :: verbose logical :: filter_tests type ( varying_string ) :: filter_string end type type , abstract :: input_t end type type , extends ( input_t ) :: double_precision_input_t double precision :: value_ end type type , extends ( input_t ) :: integer_input_t integer :: value_ end type type , extends ( input_t ) :: string_input_t type ( varying_string ) :: value_ end type type :: transformed_t private class ( input_t ), allocatable :: input end type type :: example_t private class ( input_t ), allocatable :: input end type type :: generated_t private class ( input_t ), allocatable :: input end type type :: shrink_result_t private class ( input_t ), allocatable :: input logical :: simplest end type type , abstract :: generator_t contains private procedure ( generate_i ), public , deferred :: generate procedure ( shrink_i ), nopass , public , deferred :: shrink end type type , extends ( generator_t ) :: ascii_string_generator_t contains private procedure , public :: generate => generate_ascii_string procedure , nopass , public :: shrink => shrink_ascii_string end type type , extends ( generator_t ) :: integer_generator_t contains private procedure , public :: generate => generate_integer procedure , nopass , public :: shrink => shrink_integer end type type , abstract :: test_t private type ( varying_string ) :: description_ contains private procedure ( test_description_i ), public , deferred :: description procedure ( filter_i ), public , deferred :: filter procedure ( test_count_i ), public , deferred :: num_cases procedure ( run_with_input_i ), deferred :: run_with_input procedure ( run_without_input_i ), deferred :: run_without_input generic :: run => run_with_input , run_without_input end type type :: test_item_t private class ( test_t ), allocatable :: test contains private procedure , public :: description => test_item_description procedure , public :: filter => test_item_filter procedure , public :: num_cases => test_item_num_cases procedure :: run_with_input => test_item_run_with_input procedure :: run_without_input => test_item_run_without_input generic , public :: run => run_with_input , run_without_input end type type , abstract , extends ( test_t ) :: test_case_t contains private procedure , public :: description => test_case_description procedure , public :: filter => test_case_filter procedure , public :: num_cases => test_case_num_cases end type type , extends ( test_case_t ) :: simple_test_case_t private procedure ( simple_test_i ), nopass , pointer :: test contains private procedure :: run_with_input => simple_test_case_run_with_input procedure :: run_without_input => simple_test_case_run_without_input end type type , extends ( test_case_t ) :: input_test_case_t private procedure ( input_test_i ), nopass , pointer :: test contains private procedure :: run_with_input => input_test_case_run_with_input procedure :: run_without_input => input_test_case_run_without_input end type type , extends ( test_case_t ) :: test_case_with_examples_t private type ( example_t ), allocatable :: examples (:) procedure ( input_test_i ), nopass , pointer :: test contains private procedure :: run_with_input => test_case_with_examples_run_with_input procedure :: run_without_input => test_case_with_examples_run_without_input end type type , extends ( test_case_t ) :: test_case_with_generator_t private class ( generator_t ), allocatable :: generator procedure ( input_test_i ), nopass , pointer :: test contains private procedure :: run_with_input => test_case_with_generator_run_with_input procedure :: run_without_input => test_case_with_generator_run_without_input end type type , abstract , extends ( test_t ) :: test_collection_t private type ( test_item_t ), allocatable :: tests (:) contains private procedure , public :: description => test_collection_description procedure , public :: filter => test_collection_filter procedure , public :: num_cases => test_collection_num_cases end type type , extends ( test_collection_t ) :: simple_test_collection_t contains private procedure :: run_with_input => simple_test_collection_run_with_input procedure :: run_without_input => simple_test_collection_run_without_input end type type , extends ( test_collection_t ) :: test_collection_with_input_t private class ( input_t ), allocatable :: input contains private procedure :: run_with_input => test_collection_with_input_run_with_input procedure :: run_without_input => test_collection_with_input_run_without_input end type type , extends ( test_collection_t ) :: transforming_test_collection_t private procedure ( transformer_i ), nopass , pointer :: transformer contains private procedure :: run_with_input => transforming_test_collection_run_with_input procedure :: run_without_input => transforming_test_collection_run_without_input end type type :: individual_result_t private type ( varying_string ) :: message logical :: passed_ contains private procedure :: failure_description => individual_result_failure_description procedure :: verbose_description => individual_result_verbose_description end type type :: result_t private type ( individual_result_t ), allocatable :: results (:) contains private procedure :: combine_results generic , public :: operator (. and .) => combine_results procedure , public :: num_asserts => result_num_asserts procedure , public :: num_failing_asserts => result_num_failing_asserts procedure , public :: passed => result_passed procedure , public :: failure_description => result_failure_description procedure , public :: verbose_description => result_verbose_description end type type , abstract :: test_result_t private type ( varying_string ) :: description contains private procedure ( test_result_count_i ), public , deferred :: num_asserts procedure ( test_result_count_i ), public , deferred :: num_cases procedure ( test_result_count_i ), public , deferred :: num_failing_asserts procedure ( test_result_count_i ), public , deferred :: num_failing_cases procedure ( test_result_passed_i ), public , deferred :: passed procedure ( test_result_colorized_description_i ), public , deferred :: & failure_description procedure ( test_result_colorized_description_i ), public , deferred :: & verbose_description end type type :: test_result_item_t private class ( test_result_t ), allocatable :: result_ contains private procedure , public :: num_asserts => test_result_item_num_asserts procedure , public :: num_cases => test_result_item_num_cases procedure , public :: num_failing_asserts => test_result_item_num_failing_asserts procedure , public :: num_failing_cases => test_result_item_num_failing_cases procedure , public :: passed => test_result_item_passed procedure , public :: failure_description => test_result_item_failure_description procedure , public :: verbose_description => test_result_item_verbose_description end type type , extends ( test_result_t ) :: test_case_result_t private type ( result_t ) :: result_ contains private procedure , public :: num_asserts => test_case_result_num_asserts procedure , public :: num_cases => test_case_result_num_cases procedure , public :: num_failing_asserts => test_case_result_num_failing_asserts procedure , public :: num_failing_cases => test_case_result_num_failing_cases procedure , public :: passed => test_case_result_passed procedure , public :: failure_description => & test_case_result_failure_description procedure , public :: verbose_description => & test_case_result_verbose_description end type type , extends ( test_result_t ) :: test_collection_result_t private type ( test_result_item_t ), allocatable :: results (:) contains private procedure , public :: num_asserts => test_collection_result_num_asserts procedure , public :: num_cases => test_collection_result_num_cases procedure , public :: num_failing_asserts => & test_collection_result_num_failing_asserts procedure , public :: num_failing_cases => & test_collection_result_num_failing_cases procedure , public :: passed => test_collection_result_passed procedure , public :: failure_description => & test_collection_result_failure_description procedure , public :: verbose_description => & test_collection_result_verbose_description end type type :: filter_result_t class ( test_t ), allocatable :: test logical :: matched end type type , public :: filter_item_result_t type ( test_item_t ) :: test logical :: matched end type type , public , extends ( input_t ) :: transformation_failure_t type ( result_t ) :: result_ end type abstract interface subroutine computation_i end subroutine pure function filter_i ( self , filter_string ) result ( filter_result ) import test_t , filter_result_t , varying_string class ( test_t ), intent ( in ) :: self type ( varying_string ), intent ( in ) :: filter_string type ( filter_result_t ) :: filter_result end function function generate_i ( self ) result ( generated_value ) import :: generated_t , generator_t class ( generator_t ), intent ( in ) :: self type ( generated_t ) :: generated_value end function function input_test_i ( input ) result ( result_ ) import input_t , result_t class ( input_t ), intent ( in ) :: input type ( result_t ) :: result_ end function function run_with_input_i ( self , input ) result ( result_ ) import input_t , test_t , test_result_item_t class ( test_t ), intent ( in ) :: self class ( input_t ), intent ( in ) :: input type ( test_result_item_t ) :: result_ end function function run_without_input_i ( self ) result ( result_ ) import test_t , test_result_item_t class ( test_t ), intent ( in ) :: self type ( test_result_item_t ) :: result_ end function function shrink_i ( input ) result ( shrunk ) import input_t , shrink_result_t class ( input_t ), intent ( in ) :: input type ( shrink_result_t ) :: shrunk end function function simple_test_i () result ( result_ ) import result_t type ( result_t ) :: result_ end function pure function test_count_i ( self ) result ( num ) import test_t class ( test_t ), intent ( in ) :: self integer :: num end function pure function test_description_i ( self ) result ( description ) import test_t , varying_string class ( test_t ), intent ( in ) :: self type ( varying_string ) :: description end function pure function test_result_colorized_description_i ( & self , colorize ) result ( description ) import test_result_t , varying_string class ( test_result_t ), intent ( in ) :: self logical , intent ( in ) :: colorize type ( varying_string ) :: description end function pure function test_result_count_i ( self ) result ( num ) import test_result_t class ( test_result_t ), intent ( in ) :: self integer :: num end function pure function test_result_passed_i ( self ) result ( passed ) import test_result_t class ( test_result_t ), intent ( in ) :: self logical :: passed end function function transformer_i ( input ) result ( output ) import input_t , transformed_t class ( input_t ), intent ( in ) :: input type ( transformed_t ) :: output end function end interface interface assert_doesnt_include module procedure assert_doesnt_include_basic_cc module procedure assert_doesnt_include_basic_cs module procedure assert_doesnt_include_basic_sc module procedure assert_doesnt_include_basic_ss module procedure assert_doesnt_include_with_message_ccc module procedure assert_doesnt_include_with_message_ccs module procedure assert_doesnt_include_with_message_csc module procedure assert_doesnt_include_with_message_css module procedure assert_doesnt_include_with_message_scc module procedure assert_doesnt_include_with_message_scs module procedure assert_doesnt_include_with_message_ssc module procedure assert_doesnt_include_with_message_sss module procedure assert_doesnt_include_with_messages_cccc module procedure assert_doesnt_include_with_messages_cccs module procedure assert_doesnt_include_with_messages_ccsc module procedure assert_doesnt_include_with_messages_ccss module procedure assert_doesnt_include_with_messages_cscc module procedure assert_doesnt_include_with_messages_cscs module procedure assert_doesnt_include_with_messages_cssc module procedure assert_doesnt_include_with_messages_csss module procedure assert_doesnt_include_with_messages_sccc module procedure assert_doesnt_include_with_messages_sccs module procedure assert_doesnt_include_with_messages_scsc module procedure assert_doesnt_include_with_messages_scss module procedure assert_doesnt_include_with_messages_sscc module procedure assert_doesnt_include_with_messages_sscs module procedure assert_doesnt_include_with_messages_sssc module procedure assert_doesnt_include_with_messages_ssss end interface interface assert_empty module procedure assert_empty_basic_c module procedure assert_empty_basic_s module procedure assert_empty_with_message_cc module procedure assert_empty_with_message_cs module procedure assert_empty_with_message_sc module procedure assert_empty_with_message_ss module procedure assert_empty_with_messages_ccc module procedure assert_empty_with_messages_ccs module procedure assert_empty_with_messages_csc module procedure assert_empty_with_messages_css module procedure assert_empty_with_messages_scc module procedure assert_empty_with_messages_scs module procedure assert_empty_with_messages_ssc module procedure assert_empty_with_messages_sss end interface interface assert_equals module procedure assert_equals_double_precision module procedure assert_equals_double_precision_with_message_c module procedure assert_equals_double_precision_with_message_s module procedure assert_equals_double_precision_with_messages_cc module procedure assert_equals_double_precision_with_messages_cs module procedure assert_equals_double_precision_with_messages_sc module procedure assert_equals_double_precision_with_messages_ss module procedure assert_equals_integer_basic module procedure assert_equals_integer_with_message_c module procedure assert_equals_integer_with_message_s module procedure assert_equals_integer_with_messages_cc module procedure assert_equals_integer_with_messages_cs module procedure assert_equals_integer_with_messages_sc module procedure assert_equals_integer_with_messages_ss module procedure assert_equals_strings_cc module procedure assert_equals_strings_cs module procedure assert_equals_strings_sc module procedure assert_equals_strings_ss module procedure assert_equals_strings_with_message_ccc module procedure assert_equals_strings_with_message_ccs module procedure assert_equals_strings_with_message_csc module procedure assert_equals_strings_with_message_css module procedure assert_equals_strings_with_message_scc module procedure assert_equals_strings_with_message_scs module procedure assert_equals_strings_with_message_ssc module procedure assert_equals_strings_with_message_sss module procedure assert_equals_strings_with_messages_cccc module procedure assert_equals_strings_with_messages_cccs module procedure assert_equals_strings_with_messages_ccsc module procedure assert_equals_strings_with_messages_ccss module procedure assert_equals_strings_with_messages_cscc module procedure assert_equals_strings_with_messages_cscs module procedure assert_equals_strings_with_messages_cssc module procedure assert_equals_strings_with_messages_csss module procedure assert_equals_strings_with_messages_sccc module procedure assert_equals_strings_with_messages_sccs module procedure assert_equals_strings_with_messages_scsc module procedure assert_equals_strings_with_messages_scss module procedure assert_equals_strings_with_messages_sscc module procedure assert_equals_strings_with_messages_sscs module procedure assert_equals_strings_with_messages_sssc module procedure assert_equals_strings_with_messages_ssss end interface interface assert_equals_within_absolute module procedure assert_equals_within_absolute_basic module procedure assert_equals_within_absolute_with_message_c module procedure assert_equals_within_absolute_with_message_s module procedure assert_equals_within_absolute_with_messages_cc module procedure assert_equals_within_absolute_with_messages_cs module procedure assert_equals_within_absolute_with_messages_sc module procedure assert_equals_within_absolute_with_messages_ss end interface interface assert_equals_within_relative module procedure assert_equals_within_relative_basic module procedure assert_equals_within_relative_with_message_c module procedure assert_equals_within_relative_with_message_s module procedure assert_equals_within_relative_with_messages_cc module procedure assert_equals_within_relative_with_messages_cs module procedure assert_equals_within_relative_with_messages_sc module procedure assert_equals_within_relative_with_messages_ss end interface interface assert_faster_than module procedure assert_faster_than_absolute_bracketed module procedure assert_faster_than_absolute_bracketed_with_message_c module procedure assert_faster_than_absolute_bracketed_with_message_s module procedure assert_faster_than_absolute_bracketed_with_messages_cc module procedure assert_faster_than_absolute_bracketed_with_messages_cs module procedure assert_faster_than_absolute_bracketed_with_messages_sc module procedure assert_faster_than_absolute_bracketed_with_messages_ss module procedure assert_faster_than_absolute_simple module procedure assert_faster_than_absolute_simple_with_message_c module procedure assert_faster_than_absolute_simple_with_message_s module procedure assert_faster_than_absolute_simple_with_messages_cc module procedure assert_faster_than_absolute_simple_with_messages_cs module procedure assert_faster_than_absolute_simple_with_messages_sc module procedure assert_faster_than_absolute_simple_with_messages_ss module procedure assert_faster_than_relative_bracketed module procedure assert_faster_than_relative_bracketed_with_message_c module procedure assert_faster_than_relative_bracketed_with_message_s module procedure assert_faster_than_relative_bracketed_with_messages_cc module procedure assert_faster_than_relative_bracketed_with_messages_cs module procedure assert_faster_than_relative_bracketed_with_messages_sc module procedure assert_faster_than_relative_bracketed_with_messages_ss module procedure assert_faster_than_relative_simple module procedure assert_faster_than_relative_simple_with_message_c module procedure assert_faster_than_relative_simple_with_message_s module procedure assert_faster_than_relative_simple_with_messages_cc module procedure assert_faster_than_relative_simple_with_messages_cs module procedure assert_faster_than_relative_simple_with_messages_sc module procedure assert_faster_than_relative_simple_with_messages_ss end interface interface assert_includes module procedure assert_includes_cc module procedure assert_includes_cs module procedure assert_includes_sc module procedure assert_includes_ss module procedure assert_includes_with_message_ccc module procedure assert_includes_with_message_ccs module procedure assert_includes_with_message_csc module procedure assert_includes_with_message_css module procedure assert_includes_with_message_scc module procedure assert_includes_with_message_scs module procedure assert_includes_with_message_ssc module procedure assert_includes_with_message_sss module procedure assert_includes_with_messages_cccc module procedure assert_includes_with_messages_cccs module procedure assert_includes_with_messages_ccsc module procedure assert_includes_with_messages_ccss module procedure assert_includes_with_messages_cscc module procedure assert_includes_with_messages_cscs module procedure assert_includes_with_messages_cssc module procedure assert_includes_with_messages_csss module procedure assert_includes_with_messages_sccc module procedure assert_includes_with_messages_sccs module procedure assert_includes_with_messages_scsc module procedure assert_includes_with_messages_scss module procedure assert_includes_with_messages_sscc module procedure assert_includes_with_messages_sscs module procedure assert_includes_with_messages_sssc module procedure assert_includes_with_messages_ssss end interface interface assert_not module procedure assert_not_basic module procedure assert_not_with_message_c module procedure assert_not_with_message_s module procedure assert_not_with_messages_cc module procedure assert_not_with_messages_cs module procedure assert_not_with_messages_sc module procedure assert_not_with_messages_ss end interface interface assert_that module procedure assert_that_basic module procedure assert_that_with_message_c module procedure assert_that_with_message_s module procedure assert_that_with_messages_cc module procedure assert_that_with_messages_cs module procedure assert_that_with_messages_sc module procedure assert_that_with_messages_ss end interface interface delimit module procedure delimit_c module procedure delimit_s end interface interface describe module procedure describe_basic_c module procedure describe_basic_s module procedure describe_with_input_c module procedure describe_with_input_s end interface interface fail module procedure fail_c module procedure fail_s end interface interface given module procedure given_basic_c module procedure given_basic_s module procedure given_with_input_c module procedure given_with_input_s end interface interface it module procedure it_basic_c module procedure it_basic_s module procedure it_with_examples_c module procedure it_with_examples_s module procedure it_with_generator_c module procedure it_with_generator_s end interface interface it_ module procedure it_input_c module procedure it_input_s end interface interface make_doesnt_include_failure_message module procedure make_doesnt_include_failure_message_cc module procedure make_doesnt_include_failure_message_cs module procedure make_doesnt_include_failure_message_sc module procedure make_doesnt_include_failure_message_ss end interface interface make_doesnt_include_success_message module procedure make_doesnt_include_success_message_cc module procedure make_doesnt_include_success_message_cs module procedure make_doesnt_include_success_message_sc module procedure make_doesnt_include_success_message_ss end interface interface make_empty_failure_message module procedure make_empty_failure_message_c module procedure make_empty_failure_message_s end interface interface make_equals_failure_message module procedure make_equals_failure_message_cc module procedure make_equals_failure_message_cs module procedure make_equals_failure_message_sc module procedure make_equals_failure_message_ss end interface interface make_equals_success_message module procedure make_equals_success_message_c module procedure make_equals_success_message_s end interface interface make_faster_than_failure_message module procedure make_faster_than_failure_message_ccc module procedure make_faster_than_failure_message_ccs module procedure make_faster_than_failure_message_csc module procedure make_faster_than_failure_message_css module procedure make_faster_than_failure_message_scc module procedure make_faster_than_failure_message_scs module procedure make_faster_than_failure_message_ssc module procedure make_faster_than_failure_message_sss end interface interface make_faster_than_success_message module procedure make_faster_than_success_message_ccc module procedure make_faster_than_success_message_ccs module procedure make_faster_than_success_message_csc module procedure make_faster_than_success_message_css module procedure make_faster_than_success_message_scc module procedure make_faster_than_success_message_scs module procedure make_faster_than_success_message_ssc module procedure make_faster_than_success_message_sss end interface interface make_includes_failure_message module procedure make_includes_failure_message_cc module procedure make_includes_failure_message_cs module procedure make_includes_failure_message_sc module procedure make_includes_failure_message_ss end interface interface make_includes_success_message module procedure make_includes_success_message_cc module procedure make_includes_succes_message_cs module procedure make_includes_succes_message_sc module procedure make_includes_succes_message_ss end interface interface make_within_failure_message module procedure make_within_failure_message_ccc module procedure make_within_failure_message_ccs module procedure make_within_failure_message_csc module procedure make_within_failure_message_css module procedure make_within_failure_message_scc module procedure make_within_failure_message_scs module procedure make_within_failure_message_ssc module procedure make_within_failure_message_sss end interface interface make_within_success_message module procedure make_within_success_message_ccc module procedure make_within_success_message_ccs module procedure make_within_success_message_csc module procedure make_within_success_message_css module procedure make_within_success_message_scc module procedure make_within_success_message_scs module procedure make_within_success_message_ssc module procedure make_within_success_message_sss end interface interface succeed module procedure succeed_c module procedure succeed_s end interface interface then_ module procedure then_basic_c module procedure then_basic_s end interface interface then__ module procedure then_input_c module procedure then_input_s end interface interface when module procedure when_basic_c module procedure when_basic_s module procedure when_with_transformer_c module procedure when_with_transformer_s end interface interface with_user_message module procedure with_user_message_cc module procedure with_user_message_cs module procedure with_user_message_sc module procedure with_user_message_ss end interface type ( ascii_string_generator_t ), parameter , public :: & ASCII_STRING_GENERATOR = ascii_string_generator_t () type ( integer_generator_t ), parameter , public :: & INTEGER_GENERATOR = integer_generator_t () character ( len =* ), parameter , public :: EMPTY_SUCCESS_MESSAGE = \"String was empty\" integer , parameter :: INDENTATION = 4 double precision , parameter :: MACHINE_EPSILON = epsilon ( 0.0d0 ) double precision , parameter :: MACHINE_TINY = tiny ( 0.0d0 ) integer , parameter :: MAX_INT = HUGE ( 1 ) character ( len =* ), parameter , public :: NOT_FAILURE_MESSAGE = \"Expected to not be true\" character ( len =* ), parameter , public :: NOT_SUCCESS_MESSAGE = \"Was not true\" integer :: NUM_GENERATOR_TESTS = 100 character ( len =* ), parameter , public :: THAT_FAILURE_MESSAGE = \"Expected to be true\" character ( len =* ), parameter , public :: THAT_SUCCESS_MESSAGE = \"Was true\" contains pure function assert_doesnt_include_basic_cc ( search_for , string ) result ( result__ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & var_str ( string ), & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_doesnt_include_basic_cs ( search_for , string ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & string , & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_doesnt_include_basic_sc ( search_for , string ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & var_str ( string ), & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_doesnt_include_basic_ss ( search_for , string ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & string , & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_doesnt_include_with_message_ccc ( & search_for , string , message ) result ( result__ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & var_str ( string ), & var_str ( message ), & var_str ( message )) end function pure function assert_doesnt_include_with_message_ccs ( & search_for , string , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & var_str ( string ), & message , & message ) end function pure function assert_doesnt_include_with_message_csc ( & search_for , string , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & string , & var_str ( message ), & var_str ( message )) end function pure function assert_doesnt_include_with_message_css ( & search_for , string , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & string , & message , & message ) end function pure function assert_doesnt_include_with_message_scc ( & search_for , string , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & var_str ( string ), & var_str ( message ), & var_str ( message )) end function pure function assert_doesnt_include_with_message_scs ( & search_for , string , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & var_str ( string ), & message , & message ) end function pure function assert_doesnt_include_with_message_ssc ( & search_for , string , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & string , & var_str ( message ), & var_str ( message )) end function pure function assert_doesnt_include_with_message_sss ( & search_for , string , message ) result ( result__ ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & string , & message , & message ) end function pure function assert_doesnt_include_with_messages_cccc ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & var_str ( string ), & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_doesnt_include_with_messages_cccs ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & var_str ( string ), & var_str ( success_message ), & failure_message ) end function pure function assert_doesnt_include_with_messages_ccsc ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & var_str ( string ), & success_message , & var_str ( failure_message )) end function pure function assert_doesnt_include_with_messages_ccss ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & var_str ( string ), & success_message , & failure_message ) end function pure function assert_doesnt_include_with_messages_cscc ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & string , & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_doesnt_include_with_messages_cscs ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & string , & var_str ( success_message ), & failure_message ) end function pure function assert_doesnt_include_with_messages_cssc ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & string , & success_message , & var_str ( failure_message )) end function pure function assert_doesnt_include_with_messages_csss ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & var_str ( search_for ), & string , & success_message , & failure_message ) end function pure function assert_doesnt_include_with_messages_sccc ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & var_str ( string ), & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_doesnt_include_with_messages_sccs ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & var_str ( string ), & var_str ( success_message ), & failure_message ) end function pure function assert_doesnt_include_with_messages_scsc ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & var_str ( string ), & success_message , & var_str ( failure_message )) end function pure function assert_doesnt_include_with_messages_scss ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & var_str ( string ), & success_message , & failure_message ) end function pure function assert_doesnt_include_with_messages_sscc ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & string , & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_doesnt_include_with_messages_sscs ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & string , & var_str ( success_message ), & failure_message ) end function pure function assert_doesnt_include_with_messages_sssc ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_doesnt_include ( & search_for , & string , & success_message , & var_str ( failure_message )) end function pure function assert_doesnt_include_with_messages_ssss ( & search_for , string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string use strff , only : operator (. includes .) type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ if ( string . includes . search_for ) then result__ = fail ( with_user_message ( & make_doesnt_include_failure_message ( search_for , string ), & failure_message )) else result__ = succeed ( with_user_message ( & make_doesnt_include_success_message ( search_for , string ), & success_message )) end if end function pure function assert_empty_basic_c ( string ) result ( result__ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: string type ( result_t ) :: result__ result__ = assert_empty ( & var_str ( string ), & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_empty_basic_s ( string ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: string type ( result_t ) :: result__ result__ = assert_empty ( & string , & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_empty_with_message_cc ( string , message ) result ( result__ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_empty ( & var_str ( string ), & var_str ( message ), & var_str ( message )) end function pure function assert_empty_with_message_cs ( string , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_empty ( & var_str ( string ), & message , & message ) end function pure function assert_empty_with_message_sc ( string , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_empty ( & string , & var_str ( message ), & var_str ( message )) end function pure function assert_empty_with_message_ss ( string , message ) result ( result__ ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_empty ( & string , & message , & message ) end function pure function assert_empty_with_messages_ccc ( & string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_empty ( & var_str ( string ), & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_empty_with_messages_ccs ( & string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_empty ( & var_str ( string ), & var_str ( success_message ), & failure_message ) end function pure function assert_empty_with_messages_csc ( & string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_empty ( & var_str ( string ), & success_message , & var_str ( failure_message )) end function pure function assert_empty_with_messages_css ( & string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_empty ( & var_str ( string ), & success_message , & failure_message ) end function pure function assert_empty_with_messages_scc ( & string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_empty ( & string , & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_empty_with_messages_scs ( & string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_empty ( & string , & var_str ( success_message ), & failure_message ) end function pure function assert_empty_with_messages_ssc ( & string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_empty ( & string , & success_message , & var_str ( failure_message )) end function pure function assert_empty_with_messages_sss ( & string , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , operator ( == ) type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ if ( string == \"\" ) then result__ = succeed ( with_user_message ( & EMPTY_SUCCESS_MESSAGE , success_message )) else result__ = fail ( with_user_message ( & make_empty_failure_message ( string ), failure_message )) end if end function pure function assert_equals_double_precision ( & expected , & actual ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual type ( result_t ) :: result__ result__ = assert_equals ( & expected , & actual , & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_equals_double_precision_with_message_c ( & expected , & actual , & message ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals ( & expected , actual , var_str ( message ), var_str ( message )) end function pure function assert_equals_double_precision_with_message_s ( & expected , & actual , & message ) & result ( result__ ) use iso_varying_string , only : varying_string double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals ( expected , actual , message , message ) end function pure function assert_equals_double_precision_with_messages_cc ( & expected , & actual , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & actual , & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_equals_double_precision_with_messages_cs ( & expected , & actual , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , actual , var_str ( success_message ), failure_message ) end function pure function assert_equals_double_precision_with_messages_sc ( & expected , & actual , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , actual , success_message , var_str ( failure_message )) end function pure function assert_equals_double_precision_with_messages_ss ( & expected , & actual , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals_within_absolute ( & expected , & actual , & MACHINE_EPSILON , & success_message , & failure_message ) end function pure function assert_equals_integer_basic ( expected , actual ) result ( result__ ) use iso_varying_string , only : var_str integer , intent ( in ) :: expected integer , intent ( in ) :: actual type ( result_t ) :: result__ result__ = assert_equals ( & expected , & actual , & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_equals_integer_with_message_c ( & expected , actual , message ) result ( result__ ) use iso_varying_string , only : var_str integer , intent ( in ) :: expected integer , intent ( in ) :: actual character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & actual , & var_str ( message ), & var_str ( message )) end function pure function assert_equals_integer_with_message_s ( & expected , actual , message ) result ( result__ ) use iso_varying_string , only : varying_string integer , intent ( in ) :: expected integer , intent ( in ) :: actual type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & actual , & message , & message ) end function pure function assert_equals_integer_with_messages_cc ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : var_str integer , intent ( in ) :: expected integer , intent ( in ) :: actual character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & actual , & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_equals_integer_with_messages_cs ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str integer , intent ( in ) :: expected integer , intent ( in ) :: actual character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , actual , var_str ( success_message ), failure_message ) end function pure function assert_equals_integer_with_messages_sc ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str integer , intent ( in ) :: expected integer , intent ( in ) :: actual type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , actual , success_message , var_str ( failure_message )) end function pure function assert_equals_integer_with_messages_ss ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string use strff , only : to_string integer , intent ( in ) :: expected integer , intent ( in ) :: actual type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ if ( expected == actual ) then result__ = succeed ( with_user_message ( & make_equals_success_message ( to_string ( expected )), & success_message )) else result__ = fail ( with_user_message ( & make_equals_failure_message ( & to_string ( expected ), to_string ( actual )), & failure_message )) end if end function pure function assert_equals_strings_cc ( & expected , actual ) result ( result__ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & var_str ( actual ), & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_equals_strings_cs ( & expected , actual ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & actual , & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_equals_strings_sc ( & expected , actual ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( result_t ) :: result__ result__ = assert_equals ( & expected , & var_str ( actual ), & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_equals_strings_ss ( & expected , actual ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( result_t ) :: result__ result__ = assert_equals ( & expected , & actual , & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_equals_strings_with_message_ccc ( & expected , actual , message ) result ( result__ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & var_str ( actual ), & var_str ( message ), & var_str ( message )) end function pure function assert_equals_strings_with_message_ccs ( & expected , actual , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & var_str ( actual ), & message , & message ) end function pure function assert_equals_strings_with_message_csc ( & expected , actual , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & actual , & var_str ( message ), & var_str ( message )) end function pure function assert_equals_strings_with_message_css ( & expected , actual , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & actual , & message , & message ) end function pure function assert_equals_strings_with_message_scc ( & expected , actual , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & var_str ( actual ), & var_str ( message ), & var_str ( message )) end function pure function assert_equals_strings_with_message_scs ( & expected , actual , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & var_str ( actual ), & message , & message ) end function pure function assert_equals_strings_with_message_ssc ( & expected , actual , message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & actual , & var_str ( message ), & var_str ( message )) end function pure function assert_equals_strings_with_message_sss ( & expected , actual , message ) result ( result__ ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & actual , & message , & message ) end function pure function assert_equals_strings_with_messages_cccc ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & var_str ( actual ), & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_equals_strings_with_messages_cccs ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & var_str ( actual ), & var_str ( success_message ), & failure_message ) end function pure function assert_equals_strings_with_messages_ccsc ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & var_str ( actual ), & success_message , & var_str ( failure_message )) end function pure function assert_equals_strings_with_messages_ccss ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & var_str ( actual ), & success_message , & failure_message ) end function pure function assert_equals_strings_with_messages_cscc ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & actual , & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_equals_strings_with_messages_cscs ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & actual , & var_str ( success_message ), & failure_message ) end function pure function assert_equals_strings_with_messages_cssc ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & actual , & success_message , & var_str ( failure_message )) end function pure function assert_equals_strings_with_messages_csss ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & var_str ( expected ), & actual , & success_message , & failure_message ) end function pure function assert_equals_strings_with_messages_sccc ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & var_str ( actual ), & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_equals_strings_with_messages_sccs ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & var_str ( actual ), & var_str ( success_message ), & failure_message ) end function pure function assert_equals_strings_with_messages_scsc ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & var_str ( actual ), & success_message , & var_str ( failure_message )) end function pure function assert_equals_strings_with_messages_scss ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & var_str ( actual ), & success_message , & failure_message ) end function pure function assert_equals_strings_with_messages_sscc ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & actual , & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_equals_strings_with_messages_sscs ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & actual , & var_str ( success_message ), & failure_message ) end function pure function assert_equals_strings_with_messages_sssc ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals ( & expected , & actual , & success_message , & var_str ( failure_message )) end function pure function assert_equals_strings_with_messages_ssss ( & expected , actual , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , operator ( == ) type ( varying_string ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ if ( expected == actual ) then result__ = succeed ( with_user_message ( & make_equals_success_message ( expected ), & success_message )) else result__ = fail ( with_user_message ( & make_equals_failure_message ( expected , actual ), & failure_message )) end if end function pure function assert_equals_within_absolute_basic ( & expected , & actual , & tolerance ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance type ( result_t ) :: result__ result__ = assert_equals_within_absolute ( & expected , & actual , & tolerance , & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_equals_within_absolute_with_message_c ( & expected , & actual , & tolerance , & message ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals_within_absolute ( & expected , & actual , & tolerance , & var_str ( message ), & var_str ( message )) end function pure function assert_equals_within_absolute_with_message_s ( & expected , & actual , & tolerance , & message ) & result ( result__ ) use iso_varying_string , only : varying_string double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals_within_absolute ( & expected , & actual , & tolerance , & message , & message ) end function pure function assert_equals_within_absolute_with_messages_cc ( & expected , & actual , & tolerance , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals_within_absolute ( & expected , & actual , & tolerance , & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_equals_within_absolute_with_messages_cs ( & expected , & actual , & tolerance , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals_within_absolute ( & expected , & actual , & tolerance , & var_str ( success_message ), & failure_message ) end function pure function assert_equals_within_absolute_with_messages_sc ( & expected , & actual , & tolerance , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals_within_absolute ( & expected , & actual , & tolerance , & success_message , & var_str ( failure_message )) end function pure function assert_equals_within_absolute_with_messages_ss ( & expected , & actual , & tolerance , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string use strff , only : to_string double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ if ( equals_within_absolute ( expected , actual , tolerance )) then result__ = succeed ( with_user_message ( & make_within_success_message ( & to_string ( expected ), & to_string ( actual ), & to_string ( tolerance )), & success_message )) else result__ = fail ( with_user_message ( & make_within_failure_message ( & to_string ( expected ), & to_string ( actual ), & to_string ( tolerance )), & failure_message )) end if end function pure function assert_equals_within_relative_basic ( & expected , & actual , & tolerance ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance type ( result_t ) :: result__ result__ = assert_equals_within_relative ( & expected , & actual , & tolerance , & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_equals_within_relative_with_message_c ( & expected , & actual , & tolerance , & message ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals_within_relative ( & expected , & actual , & tolerance , & var_str ( message ), & var_str ( message )) end function pure function assert_equals_within_relative_with_message_s ( & expected , & actual , & tolerance , & message ) & result ( result__ ) use iso_varying_string , only : varying_string double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_equals_within_relative ( & expected , & actual , & tolerance , & message , & message ) end function pure function assert_equals_within_relative_with_messages_cc ( & expected , & actual , & tolerance , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals_within_relative ( & expected , & actual , & tolerance , & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_equals_within_relative_with_messages_cs ( & expected , & actual , & tolerance , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals_within_relative ( & expected , & actual , & tolerance , & var_str ( success_message ), & failure_message ) end function pure function assert_equals_within_relative_with_messages_sc ( & expected , & actual , & tolerance , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_equals_within_relative ( & expected , & actual , & tolerance , & success_message , & var_str ( failure_message )) end function pure function assert_equals_within_relative_with_messages_ss ( & expected , & actual , & tolerance , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , operator ( // ) use strff , only : to_string double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ if ( equals_within_relative ( expected , actual , tolerance )) then result__ = succeed ( with_user_message ( & make_within_success_message ( & to_string ( expected ), & to_string ( actual ), & to_string ( tolerance * 10 0.0d0 ) // \"%\" ), & success_message )) else result__ = fail ( with_user_message ( & make_within_failure_message ( & to_string ( expected ), & to_string ( actual ), & to_string ( tolerance * 10 0.0d0 ) // \"%\" ), & failure_message )) end if end function function assert_faster_than_absolute_bracketed ( & reference , & before , & computation , & after , & iterations ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: reference procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & before , & computation , & after , & iterations , & var_str ( \"\" ), & var_str ( \"\" )) end function function assert_faster_than_absolute_bracketed_with_message_c ( & reference , & before , & computation , & after , & iterations , & message ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: reference procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & before , & computation , & after , & iterations , & var_str ( message ), & var_str ( message )) end function function assert_faster_than_absolute_bracketed_with_message_s ( & reference , & before , & computation , & after , & iterations , & message ) & result ( result__ ) use iso_varying_string , only : varying_string double precision , intent ( in ) :: reference procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & before , & computation , & after , & iterations , & message , & message ) end function function assert_faster_than_absolute_bracketed_with_messages_cc ( & reference , & before , & computation , & after , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: reference procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & before , & computation , & after , & iterations , & var_str ( success_message ), & var_str ( failure_message )) end function function assert_faster_than_absolute_bracketed_with_messages_cs ( & reference , & before , & computation , & after , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str double precision , intent ( in ) :: reference procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & before , & computation , & after , & iterations , & var_str ( success_message ), & failure_message ) end function function assert_faster_than_absolute_bracketed_with_messages_sc ( & reference , & before , & computation , & after , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str double precision , intent ( in ) :: reference procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & before , & computation , & after , & iterations , & success_message , & var_str ( failure_message )) end function function assert_faster_than_absolute_bracketed_with_messages_ss ( & reference , & before , & computation , & after , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string use strff , only : to_string double precision , intent ( in ) :: reference procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ integer :: i double precision :: start_time double precision :: end_time double precision :: total_time double precision :: average_time total_time = 0.0d0 do i = 1 , iterations call before call cpu_time ( start_time ) call computation call cpu_time ( end_time ) call after total_time = total_time + ( end_time - start_time ) end do average_time = total_time / dble ( iterations ) if ( average_time < reference ) then result__ = succeed ( with_user_message ( & make_faster_than_success_message ( & to_string ( reference ), & to_string ( average_time ), & to_string ( iterations )), & success_message )) else result__ = fail ( with_user_message ( & make_faster_than_failure_message ( & to_string ( reference ), & to_string ( average_time ), & to_string ( iterations )), & failure_message )) end if end function function assert_faster_than_absolute_simple ( & reference , & computation , & iterations ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & computation , & iterations , & var_str ( \"\" ), & var_str ( \"\" )) end function function assert_faster_than_absolute_simple_with_message_c ( & reference , & computation , & iterations , & message ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & computation , & iterations , & var_str ( message ), & var_str ( message )) end function function assert_faster_than_absolute_simple_with_message_s ( & reference , & computation , & iterations , & message ) & result ( result__ ) use iso_varying_string , only : varying_string double precision , intent ( in ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & computation , & iterations , & message , & message ) end function function assert_faster_than_absolute_simple_with_messages_cc ( & reference , & computation , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : var_str double precision , intent ( in ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & computation , & iterations , & var_str ( success_message ), & var_str ( failure_message )) end function function assert_faster_than_absolute_simple_with_messages_cs ( & reference , & computation , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str double precision , intent ( in ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & computation , & iterations , & var_str ( success_message ), & failure_message ) end function function assert_faster_than_absolute_simple_with_messages_sc ( & reference , & computation , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str double precision , intent ( in ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & computation , & iterations , & success_message , & var_str ( failure_message )) end function function assert_faster_than_absolute_simple_with_messages_ss ( & reference , & computation , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string use strff , only : to_string double precision , intent ( in ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ integer :: i double precision :: start_time double precision :: end_time double precision :: total_time double precision :: average_time total_time = 0.0d0 do i = 1 , iterations call cpu_time ( start_time ) call computation call cpu_time ( end_time ) total_time = total_time + ( end_time - start_time ) end do average_time = total_time / dble ( iterations ) if ( average_time < reference ) then result__ = succeed ( with_user_message ( & make_faster_than_success_message ( & to_string ( reference ), & to_string ( average_time ), & to_string ( iterations )), & success_message )) else result__ = fail ( with_user_message ( & make_faster_than_failure_message ( & to_string ( reference ), & to_string ( average_time ), & to_string ( iterations )), & failure_message )) end if end function function assert_faster_than_relative_bracketed ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations ) & result ( result__ ) use iso_varying_string , only : var_str procedure ( computation_i ) :: reference_before procedure ( computation_i ) :: reference procedure ( computation_i ) :: reference_after procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations type ( result_t ) :: result__ result__ = assert_faster_than ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations , & var_str ( \"\" ), & var_str ( \"\" )) end function function assert_faster_than_relative_bracketed_with_message_c ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations , & message ) & result ( result__ ) use iso_varying_string , only : var_str procedure ( computation_i ) :: reference_before procedure ( computation_i ) :: reference procedure ( computation_i ) :: reference_after procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations , & var_str ( message ), & var_str ( message )) end function function assert_faster_than_relative_bracketed_with_message_s ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations , & message ) & result ( result__ ) use iso_varying_string , only : varying_string procedure ( computation_i ) :: reference_before procedure ( computation_i ) :: reference procedure ( computation_i ) :: reference_after procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations , & message , & message ) end function function assert_faster_than_relative_bracketed_with_messages_cc ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : var_str procedure ( computation_i ) :: reference_before procedure ( computation_i ) :: reference procedure ( computation_i ) :: reference_after procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations , & var_str ( success_message ), & var_str ( failure_message )) end function function assert_faster_than_relative_bracketed_with_messages_cs ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str procedure ( computation_i ) :: reference_before procedure ( computation_i ) :: reference procedure ( computation_i ) :: reference_after procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations , & var_str ( success_message ), & failure_message ) end function function assert_faster_than_relative_bracketed_with_messages_sc ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str procedure ( computation_i ) :: reference_before procedure ( computation_i ) :: reference procedure ( computation_i ) :: reference_after procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations , & success_message , & var_str ( failure_message )) end function function assert_faster_than_relative_bracketed_with_messages_ss ( & reference_before , & reference , & reference_after , & before , & computation , & after , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string use strff , only : to_string procedure ( computation_i ) :: reference_before procedure ( computation_i ) :: reference procedure ( computation_i ) :: reference_after procedure ( computation_i ) :: before procedure ( computation_i ) :: computation procedure ( computation_i ) :: after integer , intent ( in ) :: iterations type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ integer :: i double precision :: start_time double precision :: end_time double precision :: total_time double precision :: average_time double precision :: reference_start_time double precision :: reference_end_time double precision :: reference_total_time double precision :: reference_average_time total_time = 0.0d0 reference_total_time = 0.0d0 do i = 1 , iterations call reference_before call cpu_time ( reference_start_time ) call reference call cpu_time ( reference_end_time ) call reference_after reference_total_time = & reference_total_time & + ( reference_end_time - reference_start_time ) call before call cpu_time ( start_time ) call computation call cpu_time ( end_time ) call after total_time = total_time + ( end_time - start_time ) end do reference_average_time = reference_total_time / dble ( iterations ) average_time = total_time / dble ( iterations ) if ( average_time < reference_average_time ) then result__ = succeed ( with_user_message ( & make_faster_than_success_message ( & to_string ( reference_average_time ), & to_string ( average_time ), & to_string ( iterations )), & success_message )) else result__ = fail ( with_user_message ( & make_faster_than_failure_message ( & to_string ( reference_average_time ), & to_string ( average_time ), & to_string ( iterations )), & failure_message )) end if end function function assert_faster_than_relative_simple ( & reference , & computation , & iterations ) & result ( result__ ) use iso_varying_string , only : var_str procedure ( computation_i ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & computation , & iterations , & var_str ( \"\" ), & var_str ( \"\" )) end function function assert_faster_than_relative_simple_with_message_c ( & reference , & computation , & iterations , & message ) & result ( result__ ) use iso_varying_string , only : var_str procedure ( computation_i ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & computation , & iterations , & var_str ( message ), & var_str ( message )) end function function assert_faster_than_relative_simple_with_message_s ( & reference , & computation , & iterations , & message ) & result ( result__ ) use iso_varying_string , only : varying_string procedure ( computation_i ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & computation , & iterations , & message , & message ) end function function assert_faster_than_relative_simple_with_messages_cc ( & reference , & computation , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : var_str procedure ( computation_i ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & computation , & iterations , & var_str ( success_message ), & var_str ( failure_message )) end function function assert_faster_than_relative_simple_with_messages_cs ( & reference , & computation , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str procedure ( computation_i ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & computation , & iterations , & var_str ( success_message ), & failure_message ) end function function assert_faster_than_relative_simple_with_messages_sc ( & reference , & computation , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str procedure ( computation_i ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_faster_than ( & reference , & computation , & iterations , & success_message , & var_str ( failure_message )) end function function assert_faster_than_relative_simple_with_messages_ss ( & reference , & computation , & iterations , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string use strff , only : to_string procedure ( computation_i ) :: reference procedure ( computation_i ) :: computation integer , intent ( in ) :: iterations type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ integer :: i double precision :: start_time double precision :: end_time double precision :: total_time double precision :: average_time double precision :: reference_start_time double precision :: reference_end_time double precision :: reference_total_time double precision :: reference_average_time total_time = 0.0d0 reference_total_time = 0.0d0 do i = 1 , iterations call cpu_time ( reference_start_time ) call reference call cpu_time ( reference_end_time ) reference_total_time = & reference_total_time & + ( reference_end_time - reference_start_time ) call cpu_time ( start_time ) call computation call cpu_time ( end_time ) total_time = total_time + ( end_time - start_time ) end do reference_average_time = reference_total_time / dble ( iterations ) average_time = total_time / dble ( iterations ) if ( average_time < reference_average_time ) then result__ = succeed ( with_user_message ( & make_faster_than_success_message ( & to_string ( reference_average_time ), & to_string ( average_time ), & to_string ( iterations )), & success_message )) else result__ = fail ( with_user_message ( & make_faster_than_failure_message ( & to_string ( reference_average_time ), & to_string ( average_time ), & to_string ( iterations )), & failure_message )) end if end function pure function assert_includes_cc ( & search_for , & string ) & result ( result__ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & var_str ( string ), & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_includes_cs ( & search_for , & string ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & string , & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_includes_sc ( & search_for , & string ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & var_str ( string ), & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_includes_ss ( & search_for , & string ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & string , & var_str ( \"\" ), & var_str ( \"\" )) end function pure function assert_includes_with_message_ccc ( & search_for , & string , & message ) & result ( result__ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & var_str ( string ), & var_str ( message ), & var_str ( message )) end function pure function assert_includes_with_message_ccs ( & search_for , & string , & message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & var_str ( string ), & message , & message ) end function pure function assert_includes_with_message_csc ( & search_for , & string , & message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & string , & var_str ( message ), & var_str ( message )) end function pure function assert_includes_with_message_css ( & search_for , & string , & message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & string , & message , & message ) end function pure function assert_includes_with_message_scc ( & search_for , & string , & message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & var_str ( string ), & var_str ( message ), & var_str ( message )) end function pure function assert_includes_with_message_scs ( & search_for , & string , & message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & var_str ( string ), & message , & message ) end function pure function assert_includes_with_message_ssc ( & search_for , & string , & message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & string , & var_str ( message ), & var_str ( message )) end function pure function assert_includes_with_message_sss ( & search_for , & string , & message ) & result ( result__ ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & string , & message , & message ) end function pure function assert_includes_with_messages_cccc ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & var_str ( string ), & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_includes_with_messages_cccs ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & var_str ( string ), & var_str ( success_message ), & failure_message ) end function pure function assert_includes_with_messages_ccsc ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & var_str ( string ), & success_message , & var_str ( failure_message )) end function pure function assert_includes_with_messages_ccss ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & var_str ( string ), & success_message , & failure_message ) end function pure function assert_includes_with_messages_cscc ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & string , & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_includes_with_messages_cscs ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & string , & var_str ( success_message ), & failure_message ) end function pure function assert_includes_with_messages_cssc ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & string , & success_message , & var_str ( failure_message )) end function pure function assert_includes_with_messages_csss ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & var_str ( search_for ), & string , & success_message , & failure_message ) end function pure function assert_includes_with_messages_sccc ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & var_str ( string ), & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_includes_with_messages_sccs ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & var_str ( string ), & var_str ( success_message ), & failure_message ) end function pure function assert_includes_with_messages_scsc ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & var_str ( string ), & success_message , & var_str ( failure_message )) end function pure function assert_includes_with_messages_scss ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & var_str ( string ), & success_message , & failure_message ) end function pure function assert_includes_with_messages_sscc ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & string , & var_str ( success_message ), & var_str ( failure_message )) end function pure function assert_includes_with_messages_sscs ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & string , & var_str ( success_message ), & failure_message ) end function pure function assert_includes_with_messages_sssc ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_includes ( & search_for , & string , & success_message , & var_str ( failure_message )) end function pure function assert_includes_with_messages_ssss ( & search_for , & string , & success_message , & failure_message ) & result ( result__ ) use iso_varying_string , only : varying_string use strff , only : operator (. includes .) type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ if ( string . includes . search_for ) then result__ = succeed ( with_user_message ( & make_includes_success_message ( search_for , string ), & success_message )) else result__ = fail ( with_user_message ( & make_includes_failure_message ( search_for , string ), & failure_message )) end if end function pure function assert_not_basic ( condition ) result ( result__ ) use iso_varying_string , only : var_str logical , intent ( in ) :: condition type ( result_t ) :: result__ result__ = assert_not ( condition , var_str ( \"\" ), var_str ( \"\" )) end function pure function assert_not_with_message_c ( condition , message ) result ( result__ ) use iso_varying_string , only : var_str logical , intent ( in ) :: condition character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_not ( condition , var_str ( message ), var_str ( message )) end function pure function assert_not_with_message_s ( condition , message ) result ( result__ ) use iso_varying_string , only : varying_string logical , intent ( in ) :: condition type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_not ( condition , message , message ) end function pure function assert_not_with_messages_cc ( & condition , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : var_str logical , intent ( in ) :: condition character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_not ( & condition , var_str ( success_message ), var_str ( failure_message )) end function pure function assert_not_with_messages_cs ( & condition , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str logical , intent ( in ) :: condition character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_not ( & condition , var_str ( success_message ), failure_message ) end function pure function assert_not_with_messages_sc ( & condition , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str logical , intent ( in ) :: condition type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_not ( & condition , success_message , var_str ( failure_message )) end function pure function assert_not_with_messages_ss ( & condition , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string logical , intent ( in ) :: condition type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ if ( condition ) then result__ = fail ( with_user_message ( & NOT_FAILURE_MESSAGE , failure_message )) else result__ = succeed ( with_user_message ( & NOT_SUCCESS_MESSAGE , success_message )) end if end function pure function assert_that_basic ( condition ) result ( result__ ) use iso_varying_string , only : var_str logical , intent ( in ) :: condition type ( result_t ) :: result__ result__ = assert_that ( condition , var_str ( \"\" ), var_str ( \"\" )) end function pure function assert_that_with_message_c ( condition , message ) result ( result__ ) use iso_varying_string , only : var_str logical , intent ( in ) :: condition character ( len =* ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_that ( condition , var_str ( message ), var_str ( message )) end function pure function assert_that_with_message_s ( condition , message ) result ( result__ ) use iso_varying_string , only : varying_string logical , intent ( in ) :: condition type ( varying_string ), intent ( in ) :: message type ( result_t ) :: result__ result__ = assert_that ( condition , message , message ) end function pure function assert_that_with_messages_cc ( & condition , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : var_str logical , intent ( in ) :: condition character ( len =* ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_that ( & condition , var_str ( success_message ), var_str ( failure_message )) end function pure function assert_that_with_messages_cs ( & condition , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str logical , intent ( in ) :: condition character ( len =* ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_that ( & condition , var_str ( success_message ), failure_message ) end function pure function assert_that_with_messages_sc ( & condition , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string , var_str logical , intent ( in ) :: condition type ( varying_string ), intent ( in ) :: success_message character ( len =* ), intent ( in ) :: failure_message type ( result_t ) :: result__ result__ = assert_that ( & condition , success_message , var_str ( failure_message )) end function pure function assert_that_with_messages_ss ( & condition , success_message , failure_message ) result ( result__ ) use iso_varying_string , only : varying_string logical , intent ( in ) :: condition type ( varying_string ), intent ( in ) :: success_message type ( varying_string ), intent ( in ) :: failure_message type ( result_t ) :: result__ if ( condition ) then result__ = succeed ( with_user_message ( & THAT_SUCCESS_MESSAGE , success_message )) else result__ = fail ( with_user_message ( & THAT_FAILURE_MESSAGE , failure_message )) end if end function pure function combine_results ( lhs , rhs ) result ( combined ) class ( result_t ), intent ( in ) :: lhs type ( result_t ), intent ( in ) :: rhs type ( result_t ) :: combined integer :: num_lhs integer :: num_rhs if ( allocated ( lhs % results ) . and . allocated ( rhs % results )) then num_lhs = size ( lhs % results ) num_rhs = size ( rhs % results ) allocate ( combined % results ( num_lhs + num_rhs )) combined % results ( 1 : num_lhs ) = lhs % results (:) combined % results ( num_lhs + 1 :) = rhs % results (:) else if ( allocated ( lhs % results )) then combined = lhs else if ( allocated ( rhs % results )) then combined = rhs end if end function pure function delimit_c ( string ) result ( delimited ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: string type ( varying_string ) :: delimited delimited = delimit ( var_str ( string )) end function pure function delimit_s ( string ) result ( delimited ) use iso_varying_string , only : varying_string , operator ( // ) type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: delimited delimited = \"|\" // string // \"|\" end function function describe_basic_c ( description , tests ) result ( item ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: description type ( test_item_t ), intent ( in ) :: tests (:) type ( test_item_t ) :: item allocate ( item % test , source = simple_test_collection ( & var_str ( description ), tests )) end function function describe_basic_s ( description , tests ) result ( item ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description type ( test_item_t ), intent ( in ) :: tests (:) type ( test_item_t ) :: item allocate ( item % test , source = simple_test_collection ( & description , tests )) end function function describe_with_input_c ( description , input , tests ) result ( item ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: description class ( input_t ), intent ( in ) :: input type ( test_item_t ), intent ( in ) :: tests (:) type ( test_item_t ) :: item allocate ( item % test , source = test_collection_with_input ( & var_str ( description ), input , tests )) end function function describe_with_input_s ( description , input , tests ) result ( item ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description class ( input_t ), intent ( in ) :: input type ( test_item_t ), intent ( in ) :: tests (:) type ( test_item_t ) :: item allocate ( item % test , source = test_collection_with_input ( & description , input , tests )) end function pure function equals_within_absolute ( expected , actual , tolerance ) double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance logical :: equals_within_absolute equals_within_absolute = abs ( expected - actual ) <= tolerance end function pure function equals_within_relative ( expected , actual , tolerance ) double precision , intent ( in ) :: expected double precision , intent ( in ) :: actual double precision , intent ( in ) :: tolerance logical :: equals_within_relative equals_within_relative = & ( abs ( expected ) <= MACHINE_TINY . and . abs ( actual ) <= MACHINE_TINY ) & . or . ( abs ( expected - actual ) / abs ( expected ) <= tolerance ) end function pure function example ( input ) class ( input_t ), intent ( in ) :: input type ( example_t ) :: example allocate ( example % input , source = input ) end function pure function fail_c ( message ) result ( failure ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: message type ( result_t ) :: failure failure = fail ( var_str ( message )) end function pure function fail_s ( message ) result ( failure ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: message type ( result_t ) :: failure allocate ( failure % results ( 1 )) failure % results ( 1 ) = individual_result ( message , . false .) end function function generate_ascii_string ( self ) result ( generated_value ) class ( ascii_string_generator_t ), intent ( in ) :: self type ( generated_t ) :: generated_value type ( string_input_t ) :: the_input associate ( a => self ) end associate the_input % value_ = get_random_ascii_string () generated_value = generated ( the_input ) end function function generate_integer ( self ) result ( generated_value ) class ( integer_generator_t ), intent ( in ) :: self type ( generated_t ) :: generated_value type ( integer_input_t ) :: the_input associate ( a => self ) end associate the_input % value_ = get_random_integer () generated_value = generated ( the_input ) end function pure function generated ( value_ ) class ( input_t ), intent ( in ) :: value_ type ( generated_t ) :: generated allocate ( generated % input , source = value_ ) end function function get_options () result ( options ) use iso_fortran_env , only : error_unit , output_unit use iso_varying_string , only : assignment ( = ), put_line use strff , only : NEWLINE type ( options_t ) :: options character ( len = 100 ) :: argument character ( len = 100 ) :: program_name integer :: i integer :: iostat integer :: num_arguments options % colorize = . true . options % quiet = . false . options % verbose = . false . options % filter_tests = . false . options % filter_string = \"\" call get_command_argument ( 0 , program_name ) num_arguments = command_argument_count () i = 1 do while ( i <= num_arguments ) call get_command_argument ( i , argument ) select case ( trim ( argument )) case ( \"-c\" , \"--color-off\" ) options % colorize = . false . case ( \"-h\" , \"--help\" ) call put_line ( output_unit , usageMessage ( program_name )) stop case ( \"-f\" , \"--filter\" ) options % filter_tests = . true . i = i + 1 call get_command_argument ( i , argument ) options % filter_string = trim ( argument ) case ( \"-n\" , \"--numrand\" ) i = i + 1 call get_command_argument ( i , argument ) read ( argument , * , iostat = iostat ) NUM_GENERATOR_TESTS if ( iostat /= 0 ) then call put_line ( & error_unit , & 'Unable to read \"' // trim ( argument ) // '\" as an integer' // NEWLINE ) call put_line ( error_unit , usageMessage ( program_name )) error stop end if if ( NUM_GENERATOR_TESTS <= 0 ) then call put_line ( error_unit , \"Number of random values must be >0\" ) error stop end if case ( \"-q\" , \"--quiet\" ) options % quiet = . true . case ( \"-v\" , \"--verbose\" ) options % verbose = . true . case default call put_line ( & error_unit , & \"Unknown argument: '\" // trim ( argument ) // \"'\" // NEWLINE ) call put_line ( error_unit , usageMessage ( program_name )) error stop end select i = i + 1 end do contains pure function usageMessage ( program_name_ ) use iso_varying_string , only : varying_string character ( len =* ), intent ( in ) :: program_name_ type ( varying_string ) :: usageMessage usageMessage = & \"Usage: \" // trim ( program_name_ ) // \" [-h] [-q] [-v] [-f string] [-n num] [-c]\" // NEWLINE & // \"  options:\" // NEWLINE & // \"    -h, --help                    Output this message and exit\" // NEWLINE & // \"    -q, --quiet                   Don't print the test descriptions before\" // NEWLINE & // \"                                  running the tests\" // NEWLINE & // \"    -v, --verbose                 Print all of the assertion messages, not\" // NEWLINE & // \"                                  just the failing ones\" // NEWLINE & // \"    -f string, --filter string    Only run cases or collections whose\" // NEWLINE & // \"                                  description contains the given string\" // NEWLINE & // \"    -n num, --numrand num         Number of random values to use for each\" // NEWLINE & // \"                                  test with generated values (default = 100)\" // NEWLINE & // \"    -c, --color-off               Don't colorize the output\" end function end function function get_random_ascii_character () result ( random_character ) character ( len = 1 ) :: random_character character ( len =* ), parameter :: ASCII_CHARACTERS = & '  !\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[&#94;_`abcdefghijklmnopqrstuvwxyz{|}~' integer :: which_character which_character = get_random_integer_with_range ( 1 , len ( ASCII_CHARACTERS )) random_character = ASCII_CHARACTERS ( which_character : which_character ) end function function get_random_ascii_string () result ( random_string ) use iso_varying_string , only : varying_string type ( varying_string ) :: random_string random_string = get_random_ascii_string_with_max_length ( 1024 ) end function function get_random_ascii_string_with_max_length ( max_length ) result ( random_string ) use iso_varying_string , only : varying_string , assignment ( = ) integer , intent ( in ) :: max_length type ( varying_string ) :: random_string character ( len = max_length ) :: characters integer :: i integer :: num_characters num_characters = get_random_integer_with_range ( 0 , max_length ) do i = 1 , num_characters characters ( i : i ) = get_random_ascii_character () end do random_string = characters ( 1 : num_characters ) end function function get_random_double_precision_with_magnitude ( magnitude ) result ( random_double ) double precision , intent ( in ) :: magnitude double precision :: random_double call random_number ( random_double ) random_double = random_double * magnitude if ( get_random_logical ()) random_double = - random_double end function function get_random_double_precision_with_range ( start , end_ ) result ( random_double ) double precision , intent ( in ) :: start double precision , intent ( in ) :: end_ double precision :: random_double call random_number ( random_double ) random_double = start + ( end_ - start ) * random_double end function function get_random_integer () result ( random_integer ) integer :: random_integer double precision :: random_real call random_number ( random_real ) random_integer = floor ( random_real * MAX_INT ) if ( get_random_logical ()) random_integer = - random_integer end function function get_random_integer_with_range ( start , end_ ) result ( random_integer ) integer , intent ( in ) :: start integer , intent ( in ) :: end_ integer :: random_integer double precision :: random_real call random_number ( random_real ) random_integer = start + floor (( end_ + 1 - start ) * random_real ) end function function get_random_logical () result ( random_logical ) logical :: random_logical if ( get_random_integer_with_range ( 0 , 1 ) == 0 ) then random_logical = . TRUE . else random_logical = . FALSE . end if end function function given_basic_c ( description , tests ) result ( item ) character ( len =* ), intent ( in ) :: description type ( test_item_t ), intent ( in ) :: tests (:) type ( test_item_t ) :: item item = describe ( \"Given \" // description , tests ) end function function given_basic_s ( description , tests ) result ( item ) use iso_varying_string , only : varying_string , operator ( // ) type ( varying_string ), intent ( in ) :: description type ( test_item_t ), intent ( in ) :: tests (:) type ( test_item_t ) :: item item = describe ( \"Given \" // description , tests ) end function function given_with_input_c ( description , input , tests ) result ( item ) character ( len =* ), intent ( in ) :: description class ( input_t ), intent ( in ) :: input type ( test_item_t ), intent ( in ) :: tests (:) type ( test_item_t ) :: item item = describe ( \"Given \" // description , input , tests ) end function function given_with_input_s ( description , input , tests ) result ( item ) use iso_varying_string , only : varying_string , operator ( // ) type ( varying_string ), intent ( in ) :: description class ( input_t ), intent ( in ) :: input type ( test_item_t ), intent ( in ) :: tests (:) type ( test_item_t ) :: item item = describe ( \"Given \" // description , input , tests ) end function pure function individual_result ( message , passed ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: message logical , intent ( in ) :: passed type ( individual_result_t ) :: individual_result individual_result % message = message individual_result % passed_ = passed end function elemental function individual_result_failure_description ( & self , colorize ) result ( description ) use iso_varying_string , only : varying_string , assignment ( = ), operator ( // ) class ( individual_result_t ), intent ( in ) :: self logical , intent ( in ) :: colorize type ( varying_string ) :: description if ( self % passed_ ) then description = \"\" else if ( colorize ) then description = char ( 27 ) // \"[31m\" // self % message // char ( 27 ) // \"[0m\" else description = self % message end if end if end function elemental function individual_result_verbose_description ( & self , colorize ) result ( description ) use iso_varying_string , only : varying_string , operator ( // ) class ( individual_result_t ), intent ( in ) :: self logical , intent ( in ) :: colorize type ( varying_string ) :: description if ( colorize ) then if ( self % passed_ ) then description = char ( 27 ) // \"[32m\" // self % message // char ( 27 ) // \"[0m\" else description = char ( 27 ) // \"[31m\" // self % message // char ( 27 ) // \"[0m\" end if else description = self % message end if end function function input_test_case ( description , test ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description procedure ( input_test_i ) :: test type ( input_test_case_t ) :: input_test_case input_test_case % description_ = description input_test_case % test => test end function function input_test_case_run_with_input ( self , input ) result ( result_ ) class ( input_test_case_t ), intent ( in ) :: self class ( input_t ), intent ( in ) :: input type ( test_result_item_t ) :: result_ allocate ( result_ % result_ , source = test_case_result ( & self % description_ , self % test ( input ))) end function function input_test_case_run_without_input ( self ) result ( result_ ) class ( input_test_case_t ), intent ( in ) :: self type ( test_result_item_t ) :: result_ allocate ( result_ % result_ , source = test_case_result ( & self % description_ , fail ( \"No input provided\" ))) end function function it_basic_c ( description , test ) result ( item ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: description procedure ( simple_test_i ) :: test type ( test_item_t ) :: item allocate ( item % test , source = simple_test_case ( var_str ( description ), test )) end function function it_basic_s ( description , test ) result ( item ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description procedure ( simple_test_i ) :: test type ( test_item_t ) :: item allocate ( item % test , source = simple_test_case ( description , test )) end function function it_input_c ( description , test ) result ( item ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: description procedure ( input_test_i ) :: test type ( test_item_t ) :: item allocate ( item % test , source = input_test_case ( var_str ( description ), test )) end function function it_input_s ( description , test ) result ( item ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description procedure ( input_test_i ) :: test type ( test_item_t ) :: item allocate ( item % test , source = input_test_case ( description , test )) end function function it_with_examples_c ( description , examples , test ) result ( item ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: description type ( example_t ), intent ( in ) :: examples (:) procedure ( input_test_i ) :: test type ( test_item_t ) :: item allocate ( item % test , source = test_case_with_examples ( & var_str ( description ), examples , test )) end function function it_with_examples_s ( description , examples , test ) result ( item ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description type ( example_t ), intent ( in ) :: examples (:) procedure ( input_test_i ) :: test type ( test_item_t ) :: item allocate ( item % test , source = test_case_with_examples ( & description , examples , test )) end function function it_with_generator_c ( description , generator , test ) result ( item ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: description class ( generator_t ), intent ( in ) :: generator procedure ( input_test_i ) :: test type ( test_item_t ) :: item allocate ( item % test , source = test_case_with_generator ( & var_str ( description ), generator , test )) end function function it_with_generator_s ( description , generator , test ) result ( item ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description class ( generator_t ), intent ( in ) :: generator procedure ( input_test_i ) :: test type ( test_item_t ) :: item allocate ( item % test , source = test_case_with_generator ( & description , generator , test )) end function pure function make_doesnt_include_failure_message_cc ( & search_for , string ) result ( message ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ) :: message message = make_doesnt_include_failure_message ( & var_str ( search_for ), var_str ( string )) end function pure function make_doesnt_include_failure_message_cs ( & search_for , string ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: message message = make_doesnt_include_failure_message ( & var_str ( search_for ), string ) end function pure function make_doesnt_include_failure_message_sc ( & search_for , string ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ) :: message message = make_doesnt_include_failure_message ( & search_for , var_str ( string )) end function pure function make_doesnt_include_failure_message_ss ( & search_for , string ) result ( message ) use iso_varying_string , only : varying_string , operator ( // ) use strff , only : hanging_indent , indent , NEWLINE type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: message message = hanging_indent ( & \"Expected\" // NEWLINE & // indent ( & delimit ( hanging_indent ( string , 1 )), & INDENTATION ) // NEWLINE & // \"to not include\" // NEWLINE & // indent ( & delimit ( hanging_indent ( search_for , 1 )), & INDENTATION ), & INDENTATION ) end function pure function make_doesnt_include_success_message_cc ( & search_for , string ) result ( message ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ) :: message message = make_doesnt_include_success_message ( & var_str ( search_for ), var_str ( string )) end function pure function make_doesnt_include_success_message_cs ( & search_for , string ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: message message = make_doesnt_include_success_message ( & var_str ( search_for ), string ) end function pure function make_doesnt_include_success_message_sc ( & search_for , string ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ) :: message message = make_doesnt_include_success_message ( & search_for , var_str ( string )) end function pure function make_doesnt_include_success_message_ss ( & search_for , string ) result ( message ) use iso_varying_string , only : varying_string , operator ( // ) use strff , only : hanging_indent , indent , NEWLINE type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: message message = hanging_indent ( & \"The string\" // NEWLINE & // indent ( & delimit ( hanging_indent ( string , 1 )), & INDENTATION ) // NEWLINE & // \"did not include\" // NEWLINE & // indent ( & delimit ( hanging_indent ( search_for , 1 )), & INDENTATION ), & INDENTATION ) end function pure function make_empty_failure_message_c ( string ) result ( message ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: string type ( varying_string ) :: message message = make_empty_failure_message ( var_str ( string )) end function pure function make_empty_failure_message_s ( string ) result ( message ) use iso_varying_string , only : varying_string , operator ( // ) use strff , only : hanging_indent , indent , NEWLINE type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: message message = hanging_indent ( & \"The string\" // NEWLINE & // indent ( & delimit ( hanging_indent ( string , 1 )), & INDENTATION ) // NEWLINE & // \"wasn't empty\" , & INDENTATION ) end function pure function make_equals_failure_message_cc ( expected , actual ) result ( message ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( varying_string ) :: message message = make_equals_failure_message ( var_str ( expected ), var_str ( actual )) end function pure function make_equals_failure_message_cs ( expected , actual ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( varying_string ) :: message message = make_equals_failure_message ( var_str ( expected ), actual ) end function pure function make_equals_failure_message_sc ( expected , actual ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( varying_string ) :: message message = make_equals_failure_message ( expected , var_str ( actual )) end function pure function make_equals_failure_message_ss ( expected , actual ) result ( message ) use iso_varying_string , only : varying_string , operator ( // ) use strff , only : hanging_indent , indent , NEWLINE type ( varying_string ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( varying_string ) :: message message = hanging_indent ( & \"Expected\" // NEWLINE & // indent ( & delimit ( hanging_indent ( expected , 1 )), & INDENTATION ) // NEWLINE & // \"but got\" // NEWLINE & // indent ( & delimit ( hanging_indent ( actual , 1 )), & INDENTATION ), & INDENTATION ) end function pure function make_equals_success_message_c ( expected ) result ( message ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ) :: message message = make_equals_success_message ( var_str ( expected )) end function pure function make_equals_success_message_s ( expected ) result ( message ) use iso_varying_string , only : varying_string , operator ( // ) use strff , only : hanging_indent , indent , NEWLINE type ( varying_string ), intent ( in ) :: expected type ( varying_string ) :: message message = hanging_indent ( & \"Expected and got\" // NEWLINE & // indent ( & delimit ( hanging_indent ( expected , 1 )), & INDENTATION ), & INDENTATION ) end function pure function make_faster_than_failure_message_ccc ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: reference character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_failure_message ( & var_str ( reference ), var_str ( actual ), var_str ( iterations )) end function pure function make_faster_than_failure_message_ccs ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: reference character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_failure_message ( & var_str ( reference ), var_str ( actual ), iterations ) end function pure function make_faster_than_failure_message_csc ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: reference type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_failure_message ( & var_str ( reference ), actual , var_str ( iterations )) end function pure function make_faster_than_failure_message_css ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: reference type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_failure_message ( & var_str ( reference ), actual , iterations ) end function pure function make_faster_than_failure_message_scc ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: reference character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_failure_message ( & reference , var_str ( actual ), var_str ( iterations )) end function pure function make_faster_than_failure_message_scs ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: reference character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_failure_message ( & reference , var_str ( actual ), iterations ) end function pure function make_faster_than_failure_message_ssc ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: reference type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_failure_message ( & reference , actual , var_str ( iterations )) end function pure function make_faster_than_failure_message_sss ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , operator ( // ) type ( varying_string ), intent ( in ) :: reference type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: iterations type ( varying_string ) :: message message = & \"Computation took \" // actual & // \", which was slower than the reference time of \" & // reference // \", averaged over \" // iterations // \" iterations.\" end function pure function make_faster_than_success_message_ccc ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: reference character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_success_message ( & var_str ( reference ), var_str ( actual ), var_str ( iterations )) end function pure function make_faster_than_success_message_ccs ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: reference character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_success_message ( & var_str ( reference ), var_str ( actual ), iterations ) end function pure function make_faster_than_success_message_csc ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: reference type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_success_message ( & var_str ( reference ), actual , var_str ( iterations )) end function pure function make_faster_than_success_message_css ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: reference type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_success_message ( & var_str ( reference ), actual , iterations ) end function pure function make_faster_than_success_message_scc ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: reference character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_success_message ( & reference , var_str ( actual ), var_str ( iterations )) end function pure function make_faster_than_success_message_scs ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: reference character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_success_message ( & reference , var_str ( actual ), iterations ) end function pure function make_faster_than_success_message_ssc ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: reference type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: iterations type ( varying_string ) :: message message = make_faster_than_success_message ( & reference , actual , var_str ( iterations )) end function pure function make_faster_than_success_message_sss ( & reference , actual , iterations ) result ( message ) use iso_varying_string , only : varying_string , operator ( // ) type ( varying_string ), intent ( in ) :: reference type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: iterations type ( varying_string ) :: message message = & \"Computation took \" // actual & // \", which was faster than the reference time of \" & // reference // \", averaged over \" // iterations // \" iterations.\" end function pure function make_includes_failure_message_cc ( search_for , string ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ) :: message message = make_includes_failure_message ( & var_str ( search_for ), var_str ( string )) end function pure function make_includes_failure_message_cs ( search_for , string ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: message message = make_includes_failure_message ( var_str ( search_for ), string ) end function pure function make_includes_failure_message_sc ( search_for , string ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ) :: message message = make_includes_failure_message ( search_for , var_str ( string )) end function pure function make_includes_failure_message_ss ( search_for , string ) result ( message ) use iso_varying_string , only : varying_string , operator ( // ) use strff , only : hanging_indent , indent , NEWLINE type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: message message = hanging_indent ( & \"Expected\" // NEWLINE & // indent ( & delimit ( hanging_indent ( string , 1 )), & INDENTATION ) // NEWLINE & // \"to include\" // NEWLINE & // indent ( & delimit ( hanging_indent ( search_for , 1 )), & INDENTATION ), & INDENTATION ) end function pure function make_includes_success_message_cc ( search_for , string ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ) :: message message = make_includes_success_message ( & var_str ( search_for ), var_str ( string )) end function pure function make_includes_succes_message_cs ( search_for , string ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: message message = make_includes_success_message ( var_str ( search_for ), string ) end function pure function make_includes_succes_message_sc ( search_for , string ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: search_for character ( len =* ), intent ( in ) :: string type ( varying_string ) :: message message = make_includes_success_message ( search_for , var_str ( string )) end function pure function make_includes_succes_message_ss ( search_for , string ) result ( message ) use iso_varying_string , only : varying_string , operator ( // ) use strff , only : hanging_indent , indent , NEWLINE type ( varying_string ), intent ( in ) :: search_for type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: message message = hanging_indent ( & \"The string\" // NEWLINE & // indent ( & delimit ( hanging_indent ( string , 1 )), & INDENTATION ) // NEWLINE & // \"included\" // NEWLINE & // indent ( & delimit ( hanging_indent ( search_for , 1 )), & INDENTATION ), & INDENTATION ) end function pure function make_within_failure_message_ccc ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_failure_message ( & var_str ( expected ), var_str ( actual ), var_str ( tolerance )) end function pure function make_within_failure_message_ccs ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_failure_message ( & var_str ( expected ), var_str ( actual ), tolerance ) end function pure function make_within_failure_message_csc ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_failure_message ( & var_str ( expected ), actual , var_str ( tolerance )) end function pure function make_within_failure_message_css ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_failure_message ( & var_str ( expected ), actual , tolerance ) end function pure function make_within_failure_message_scc ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_failure_message ( & expected , var_str ( actual ), var_str ( tolerance )) end function pure function make_within_failure_message_scs ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_failure_message ( & expected , var_str ( actual ), tolerance ) end function pure function make_within_failure_message_ssc ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_failure_message ( & expected , actual , var_str ( tolerance )) end function pure function make_within_failure_message_sss ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , operator ( // ) type ( varying_string ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: tolerance type ( varying_string ) :: message message = & \"Expected \" // delimit ( actual ) // \" to be within \" & // delimit ( \"±\" // tolerance ) // \" of \" // delimit ( expected ) end function pure function make_within_success_message_ccc ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_success_message ( & var_str ( expected ), var_str ( actual ), var_str ( tolerance )) end function pure function make_within_success_message_ccs ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_success_message ( & var_str ( expected ), var_str ( actual ), tolerance ) end function pure function make_within_success_message_csc ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_success_message ( & var_str ( expected ), actual , var_str ( tolerance )) end function pure function make_within_success_message_css ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_success_message ( & var_str ( expected ), actual , tolerance ) end function pure function make_within_success_message_scc ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_success_message ( & expected , var_str ( actual ), var_str ( tolerance )) end function pure function make_within_success_message_scs ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected character ( len =* ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_success_message ( & expected , var_str ( actual ), tolerance ) end function pure function make_within_success_message_ssc ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual character ( len =* ), intent ( in ) :: tolerance type ( varying_string ) :: message message = make_within_success_message ( & expected , actual , var_str ( tolerance )) end function pure function make_within_success_message_sss ( & expected , actual , tolerance ) result ( message ) use iso_varying_string , only : varying_string , operator ( // ) type ( varying_string ), intent ( in ) :: expected type ( varying_string ), intent ( in ) :: actual type ( varying_string ), intent ( in ) :: tolerance type ( varying_string ) :: message message = & delimit ( actual ) // \" was within \" // delimit ( \"±\" // tolerance ) & // \" of \" // delimit ( expected ) end function pure function result_failure_description ( self , colorize ) result ( description ) use iso_varying_string , only : varying_string use strff , only : join , NEWLINE class ( result_t ), intent ( in ) :: self logical , intent ( in ) :: colorize type ( varying_string ) :: description type ( varying_string ) :: individual_descriptions ( size ( self % results )) individual_descriptions = self % results % failure_description ( colorize ) description = join ( individual_descriptions , NEWLINE ) end function pure function result_num_asserts ( self ) result ( num_asserts ) class ( result_t ), intent ( in ) :: self integer :: num_asserts num_asserts = size ( self % results ) end function pure function result_num_failing_asserts ( self ) result ( num_asserts ) class ( result_t ), intent ( in ) :: self integer :: num_asserts num_asserts = count (. not . self % results % passed_ ) end function pure function result_passed ( self ) result ( passed ) class ( result_t ), intent ( in ) :: self logical :: passed passed = all ( self % results % passed_ ) end function pure function result_verbose_description ( self , colorize ) result ( description ) use iso_varying_string , only : varying_string use strff , only : join , NEWLINE class ( result_t ), intent ( in ) :: self logical , intent ( in ) :: colorize type ( varying_string ) :: description type ( varying_string ) :: individual_descriptions ( size ( self % results )) individual_descriptions = self % results % verbose_description ( colorize ) description = join ( individual_descriptions , NEWLINE ) end function subroutine run_tests ( tests ) use iso_fortran_env , only : error_unit , output_unit use iso_varying_string , only : operator ( // ), put_line use strff , only : to_string type ( test_item_t ), intent ( in ) :: tests double precision :: end_time type ( filter_item_result_t ) :: filtered_tests integer :: i type ( options_t ) :: options type ( test_result_item_t ) :: results double precision :: start_time logical , allocatable :: suite_failed [:] type ( test_item_t ) :: tests_to_run allocate ( suite_failed [ * ]) suite_failed = . false . options = get_options () if ( options % filter_tests ) then filtered_tests = tests % filter ( options % filter_string ) if ( filtered_tests % matched ) then tests_to_run = filtered_tests % test else error stop \"No matching tests found\" end if else tests_to_run = tests end if if ( this_image () == 1 ) then call put_line ( output_unit , \"Running Tests\" ) call put_line ( output_unit , \"\" ) if (. not . options % quiet ) then call put_line ( output_unit , tests_to_run % description ()) call put_line ( output_unit , \"\" ) end if call put_line ( & output_unit , & \"A total of \" // to_string ( tests_to_run % num_cases ()) // \" test cases\" ) call put_line ( output_unit , \"\" ) end if call cpu_time ( start_time ) results = tests_to_run % run () call cpu_time ( end_time ) critical ! report results one image at a time if ( num_images () > 1 ) then call put_line ( output_unit , \"On image \" // to_string ( this_image ())) end if if ( results % passed ()) then call put_line ( output_unit , \"All Passed\" ) call put_line ( & output_unit , & \"Took \" // to_string ( end_time - start_time , 6 ) // \" seconds\" ) call put_line ( output_unit , \"\" ) if ( options % verbose ) then call put_line ( & output_unit , & results % verbose_description ( options % colorize )) call put_line ( output_unit , \"\" ) end if call put_line ( & output_unit , & \"A total of \" // to_string ( results % num_cases ()) & // \" test cases containing a total of \" & // to_string ( results % num_asserts ()) // \" assertions\" ) call put_line ( output_unit , \"\" ) else call put_line ( error_unit , \"Failed\" ) call put_line ( & error_unit , & \"Took \" // to_string ( end_time - start_time , 6 ) // \" seconds\" ) call put_line ( error_unit , \"\" ) if ( options % verbose ) then call put_line ( & error_unit , & results % verbose_description ( options % colorize )) else call put_line ( & error_unit , & results % failure_description ( options % colorize )) end if call put_line ( error_unit , \"\" ) call put_line ( & error_unit , & to_string ( results % num_failing_cases ()) // \" of \" & // to_string ( results % num_cases ()) // \" cases failed\" ) call put_line ( & error_unit , & to_string ( results % num_failing_asserts ()) // \" of \" & // to_string ( results % num_asserts ()) // \" assertions failed\" ) call put_line ( error_unit , \"\" ) suite_failed = . true . end if end critical sync all ! make sure all images have had a chance to record failure before checking for any if ( this_image () == 1 ) then do i = 1 , num_images () if ( suite_failed [ i ]) error stop end do end if end subroutine pure function shrink_ascii_string ( input ) result ( shrunk ) use iso_varying_string , only : assignment ( = ), extract , len class ( input_t ), intent ( in ) :: input type ( shrink_result_t ) :: shrunk type ( string_input_t ) :: new_input select type ( input ) type is ( string_input_t ) if ( len ( input % value_ ) <= 1 ) then new_input % value_ = \"\" shrunk = simplest_value ( new_input ) else new_input % value_ = extract ( & input % value_ , 1 , len ( input % value_ ) - 1 ) shrunk = shrunk_value ( new_input ) end if end select end function pure function shrink_integer ( input ) result ( shrunk ) class ( input_t ), intent ( in ) :: input type ( shrink_result_t ) :: shrunk type ( integer_input_t ) :: new_input select type ( input ) type is ( integer_input_t ) if ( input % value_ == 0 ) then new_input % value_ = 0 shrunk = simplest_value ( new_input ) else new_input % value_ = input % value_ / 2 shrunk = shrunk_value ( new_input ) end if end select end function pure function shrink_result ( value_ , simplest ) class ( input_t ), intent ( in ) :: value_ logical , intent ( in ) :: simplest type ( shrink_result_t ) :: shrink_result allocate ( shrink_result % input , source = value_ ) shrink_result % simplest = simplest end function pure function shrunk_value ( value_ ) class ( input_t ), intent ( in ) :: value_ type ( shrink_result_t ) :: shrunk_value shrunk_value = shrink_result ( value_ , . false .) end function pure function simplest_value ( value_ ) class ( input_t ), intent ( in ) :: value_ type ( shrink_result_t ) :: simplest_value simplest_value = shrink_result ( value_ , . true .) end function function simple_test_case ( description , test ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description procedure ( simple_test_i ) :: test type ( simple_test_case_t ) :: simple_test_case simple_test_case % description_ = description simple_test_case % test => test end function function simple_test_case_run_with_input ( self , input ) result ( result_ ) class ( simple_test_case_t ), intent ( in ) :: self class ( input_t ), intent ( in ) :: input type ( test_result_item_t ) :: result_ associate ( a => input ) end associate result_ = self % run () end function function simple_test_case_run_without_input ( self ) result ( result_ ) class ( simple_test_case_t ), intent ( in ) :: self type ( test_result_item_t ) :: result_ allocate ( result_ % result_ , source = test_case_result ( & self % description_ , self % test ())) end function function simple_test_collection ( description , tests ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description type ( test_item_t ), intent ( in ) :: tests (:) type ( simple_test_collection_t ) :: simple_test_collection simple_test_collection % description_ = description allocate ( simple_test_collection % tests , source = tests ) end function recursive function simple_test_collection_run_with_input ( self , input ) result ( result_ ) class ( simple_test_collection_t ), intent ( in ) :: self class ( input_t ), intent ( in ) :: input type ( test_result_item_t ) :: result_ associate ( a => input ) end associate result_ = self % run () end function recursive function simple_test_collection_run_without_input ( self ) result ( result_ ) class ( simple_test_collection_t ), intent ( in ) :: self type ( test_result_item_t ) :: result_ integer :: i type ( test_result_item_t ) :: results ( size ( self % tests )) do i = 1 , size ( self % tests ) results ( i ) = self % tests ( i )% run () end do allocate ( result_ % result_ , source = test_collection_result ( & self % description_ , results )) end function pure function succeed_c ( message ) result ( success ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: message type ( result_t ) :: success success = succeed ( var_str ( message )) end function pure function succeed_s ( message ) result ( success ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: message type ( result_t ) :: success allocate ( success % results ( 1 )) success % results ( 1 ) = individual_result ( message , . true .) end function pure function test_case_description ( self ) result ( description ) use iso_varying_string , only : varying_string class ( test_case_t ), intent ( in ) :: self type ( varying_string ) :: description description = self % description_ end function pure function test_case_filter ( self , filter_string ) result ( filter_result ) use iso_varying_string , only : varying_string use strff , only : operator (. includes .) class ( test_case_t ), intent ( in ) :: self type ( varying_string ), intent ( in ) :: filter_string type ( filter_result_t ) :: filter_result if ( self % description_ . includes . filter_string ) then filter_result % matched = . true . allocate ( filter_result % test , source = self ) else filter_result % matched = . false . end if end function pure function test_case_num_cases ( self ) result ( num_cases ) class ( test_case_t ), intent ( in ) :: self integer :: num_cases associate ( a => self ) end associate num_cases = 1 end function pure function test_case_result ( description , result_ ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description type ( result_t ), intent ( in ) :: result_ type ( test_case_result_t ) :: test_case_result test_case_result % description = description test_case_result % result_ = result_ end function pure function test_case_result_failure_description ( & self , colorize ) result ( description ) use iso_varying_string , only : varying_string , assignment ( = ), operator ( // ) use strff , only : hanging_indent , NEWLINE class ( test_case_result_t ), intent ( in ) :: self logical , intent ( in ) :: colorize type ( varying_string ) :: description if ( self % passed ()) then description = \"\" else description = hanging_indent ( & self % description // NEWLINE & // self % result_ % failure_description ( colorize ), & INDENTATION ) end if end function pure function test_case_result_num_asserts ( self ) result ( num_asserts ) class ( test_case_result_t ), intent ( in ) :: self integer :: num_asserts num_asserts = self % result_ % num_asserts () end function pure function test_case_result_num_cases ( self ) result ( num_cases ) class ( test_case_result_t ), intent ( in ) :: self integer :: num_cases associate ( a => self ) end associate num_cases = 1 end function pure function test_case_result_num_failing_asserts ( self ) result ( num_asserts ) class ( test_case_result_t ), intent ( in ) :: self integer :: num_asserts num_asserts = self % result_ % num_failing_asserts () end function pure function test_case_result_num_failing_cases ( self ) result ( num_cases ) class ( test_case_result_t ), intent ( in ) :: self integer :: num_cases if ( self % passed ()) then num_cases = 0 else num_cases = 1 end if end function pure function test_case_result_passed ( self ) result ( passed ) class ( test_case_result_t ), intent ( in ) :: self logical :: passed passed = self % result_ % passed () end function pure function test_case_result_verbose_description ( & self , colorize ) result ( description ) use iso_varying_string , only : varying_string , operator ( // ) use strff , only : hanging_indent , NEWLINE class ( test_case_result_t ), intent ( in ) :: self logical , intent ( in ) :: colorize type ( varying_string ) :: description description = hanging_indent ( & self % description // NEWLINE & // self % result_ % verbose_description ( colorize ), & INDENTATION ) end function function test_case_with_examples ( description , examples , test ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description type ( example_t ), intent ( in ) :: examples (:) procedure ( input_test_i ) :: test type ( test_case_with_examples_t ) :: test_case_with_examples test_case_with_examples % description_ = description allocate ( test_case_with_examples % examples , source = examples ) test_case_with_examples % test => test end function function test_case_with_examples_run_with_input ( self , input ) result ( result_ ) class ( test_case_with_examples_t ), intent ( in ) :: self class ( input_t ), intent ( in ) :: input type ( test_result_item_t ) :: result_ associate ( a => input ) end associate result_ = self % run () end function function test_case_with_examples_run_without_input ( self ) result ( result_ ) class ( test_case_with_examples_t ), intent ( in ) :: self type ( test_result_item_t ) :: result_ integer :: i type ( result_t ) :: results do i = 1 , size ( self % examples ) results = results . and . self % test ( self % examples ( i )% input ) end do allocate ( result_ % result_ , source = test_case_result ( & self % description_ , results )) end function function test_case_with_generator ( description , generator , test ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description class ( generator_t ), intent ( in ) :: generator procedure ( input_test_i ) :: test type ( test_case_with_generator_t ) :: test_case_with_generator test_case_with_generator % description_ = description allocate ( test_case_with_generator % generator , source = generator ) test_case_with_generator % test => test end function function test_case_with_generator_run_with_input ( self , input ) result ( result_ ) class ( test_case_with_generator_t ), intent ( in ) :: self class ( input_t ), intent ( in ) :: input type ( test_result_item_t ) :: result_ associate ( a => input ) end associate result_ = self % run () end function function test_case_with_generator_run_without_input ( self ) result ( result_ ) use iso_varying_string , only : operator ( // ) use strff , only : to_string class ( test_case_with_generator_t ), intent ( in ) :: self type ( test_result_item_t ) :: result_ type ( generated_t ) :: generated_value integer :: i type ( result_t ) :: new_result type ( result_t ) :: previous_result type ( shrink_result_t ) :: simpler_value do i = 1 , NUM_GENERATOR_TESTS generated_value = self % generator % generate () previous_result = self % test ( generated_value % input ) if (. not . previous_result % passed ()) exit end do if ( i > NUM_GENERATOR_TESTS ) then allocate ( result_ % result_ , source = test_case_result ( & self % description_ , & succeed ( \"Passed after \" // to_string ( NUM_GENERATOR_TESTS ) // \" examples\" ))) else do simpler_value = self % generator % shrink ( generated_value % input ) if ( simpler_value % simplest ) then new_result = self % test ( simpler_value % input ) if ( new_result % passed ()) then allocate ( result_ % result_ , source = test_case_result ( & self % description_ , & fail ( 'Found simplest example causing failure' ). and . previous_result )) return else allocate ( result_ % result_ , source = test_case_result ( & self % description_ , & fail ( 'Fails with the simplest possible example' ). and . new_result )) return end if else new_result = self % test ( simpler_value % input ) if ( new_result % passed ()) then allocate ( result_ % result_ , source = test_case_result ( & self % description_ , & fail ( 'Found simplest example causing failure' ). and . previous_result )) return else previous_result = new_result generated_value = generated ( simpler_value % input ) end if end if end do end if end function pure recursive function test_collection_description ( self ) result ( description ) use iso_varying_string , only : varying_string , operator ( // ) use strff , only : hanging_indent , join , NEWLINE class ( test_collection_t ), intent ( in ) :: self type ( varying_string ) :: description integer :: i description = hanging_indent ( & self % description_ // NEWLINE // join ( & [( self % tests ( i )% description (), i = 1 , size ( self % tests ))], & NEWLINE ), & INDENTATION ) end function pure recursive function test_collection_filter ( self , filter_string ) result ( filter_result ) use iso_varying_string , only : varying_string use strff , only : operator (. includes .) class ( test_collection_t ), intent ( in ) :: self type ( varying_string ), intent ( in ) :: filter_string type ( filter_result_t ) :: filter_result class ( test_collection_t ), allocatable :: new_collection type ( filter_item_result_t ) :: filter_results ( size ( self % tests )) integer :: i logical :: matches ( size ( self % tests )) type ( test_item_t ) :: maybe_tests ( size ( self % tests )) if ( self % description_ . includes . filter_string ) then filter_result % matched = . true . allocate ( filter_result % test , source = self ) else filter_results = [( self % tests ( i )% filter ( filter_string ), i = 1 , size ( self % tests ))] if ( any ( filter_results % matched )) then matches = filter_results % matched maybe_tests = filter_results % test allocate ( new_collection , source = self ) deallocate ( new_collection % tests ) allocate ( new_collection % tests , source = & pack ( maybe_tests , mask = matches )) filter_result % matched = . true . allocate ( filter_result % test , source = new_collection ) else filter_result % matched = . false . end if end if end function pure recursive function test_collection_num_cases ( self ) result ( num_cases ) class ( test_collection_t ), intent ( in ) :: self integer :: num_cases integer :: i num_cases = sum ([( self % tests ( i )% num_cases (), i = 1 , size ( self % tests ))]) end function pure function test_collection_result ( description , results ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description type ( test_result_item_t ), intent ( in ) :: results (:) type ( test_collection_result_t ) :: test_collection_result test_collection_result % description = description allocate ( test_collection_result % results , source = results ) end function pure recursive function test_collection_result_failure_description ( & self , colorize ) result ( description ) use iso_varying_string , only : varying_string , assignment ( = ), operator ( // ) use strff , only : hanging_indent , join , NEWLINE class ( test_collection_result_t ), intent ( in ) :: self logical , intent ( in ) :: colorize type ( varying_string ) :: description integer :: i if ( self % passed ()) then description = \"\" else description = hanging_indent ( & self % description // NEWLINE // join ( & [( self % results ( i )% failure_description ( colorize ), i = 1 , size ( self % results ))], & NEWLINE ), & INDENTATION ) end if end function pure recursive function test_collection_result_num_asserts ( self ) result ( num_asserts ) class ( test_collection_result_t ), intent ( in ) :: self integer :: num_asserts integer :: i num_asserts = sum ([( self % results ( i )% num_asserts (), i = 1 , size ( self % results ))]) end function pure recursive function test_collection_result_num_cases ( self ) result ( num_cases ) class ( test_collection_result_t ), intent ( in ) :: self integer :: num_cases integer :: i num_cases = sum ([( self % results ( i )% num_cases (), i = 1 , size ( self % results ))]) end function pure recursive function test_collection_result_num_failing_asserts ( self ) result ( num_asserts ) class ( test_collection_result_t ), intent ( in ) :: self integer :: num_asserts integer :: i num_asserts = sum ([( self % results ( i )% num_failing_asserts (), i = 1 , size ( self % results ))]) end function pure recursive function test_collection_result_num_failing_cases ( self ) result ( num_cases ) class ( test_collection_result_t ), intent ( in ) :: self integer :: num_cases integer :: i num_cases = sum ([( self % results ( i )% num_failing_cases (), i = 1 , size ( self % results ))]) end function pure recursive function test_collection_result_passed ( self ) result ( passed ) class ( test_collection_result_t ), intent ( in ) :: self logical :: passed integer :: i passed = all ([( self % results ( i )% passed (), i = 1 , size ( self % results ))]) end function pure recursive function test_collection_result_verbose_description ( & self , colorize ) result ( description ) use iso_varying_string , only : varying_string , operator ( // ) use strff , only : hanging_indent , join , NEWLINE class ( test_collection_result_t ), intent ( in ) :: self logical , intent ( in ) :: colorize type ( varying_string ) :: description integer :: i description = hanging_indent ( & self % description // NEWLINE // join ( & [( self % results ( i )% verbose_description ( colorize ), i = 1 , size ( self % results ))], & NEWLINE ), & INDENTATION ) end function function test_collection_with_input ( description , input , tests ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description class ( input_t ), intent ( in ) :: input type ( test_item_t ), intent ( in ) :: tests (:) type ( test_collection_with_input_t ) :: test_collection_with_input test_collection_with_input % description_ = description allocate ( test_collection_with_input % input , source = input ) allocate ( test_collection_with_input % tests , source = tests ) end function recursive function test_collection_with_input_run_with_input ( self , input ) result ( result_ ) class ( test_collection_with_input_t ), intent ( in ) :: self class ( input_t ), intent ( in ) :: input type ( test_result_item_t ) :: result_ associate ( a => input ) end associate result_ = self % run () end function recursive function test_collection_with_input_run_without_input ( self ) result ( result_ ) class ( test_collection_with_input_t ), intent ( in ) :: self type ( test_result_item_t ) :: result_ integer :: i type ( test_result_item_t ) :: results ( size ( self % tests )) do i = 1 , size ( self % tests ) results ( i ) = self % tests ( i )% run ( self % input ) end do allocate ( result_ % result_ , source = test_collection_result ( & self % description_ , results )) end function pure recursive function test_item_description ( self ) result ( description ) use iso_varying_string , only : varying_string class ( test_item_t ), intent ( in ) :: self type ( varying_string ) :: description description = self % test % description () end function pure recursive function test_item_filter ( self , filter_string ) result ( filter_result ) use iso_varying_string , only : varying_string class ( test_item_t ), intent ( in ) :: self type ( varying_string ), intent ( in ) :: filter_string type ( filter_item_result_t ) :: filter_result type ( filter_result_t ) :: test_filter_result test_filter_result = self % test % filter ( filter_string ) if ( test_filter_result % matched ) then filter_result % matched = . true . allocate ( filter_result % test % test , source = test_filter_result % test ) else filter_result % matched = . false . end if end function pure recursive function test_item_num_cases ( self ) result ( num_cases ) class ( test_item_t ), intent ( in ) :: self integer :: num_cases num_cases = self % test % num_cases () end function recursive function test_item_run_with_input ( self , input ) result ( result_ ) class ( test_item_t ), intent ( in ) :: self class ( input_t ), intent ( in ) :: input type ( test_result_item_t ) :: result_ result_ = self % test % run ( input ) end function recursive function test_item_run_without_input ( self ) result ( result_ ) class ( test_item_t ), intent ( in ) :: self type ( test_result_item_t ) :: result_ result_ = self % test % run () end function pure recursive function test_result_item_failure_description ( & self , colorize ) result ( description ) use iso_varying_string , only : varying_string class ( test_result_item_t ), intent ( in ) :: self logical , intent ( in ) :: colorize type ( varying_string ) :: description description = self % result_ % failure_description ( colorize ) end function pure recursive function test_result_item_num_asserts ( self ) result ( num_asserts ) class ( test_result_item_t ), intent ( in ) :: self integer :: num_asserts num_asserts = self % result_ % num_asserts () end function pure recursive function test_result_item_num_cases ( self ) result ( num_cases ) class ( test_result_item_t ), intent ( in ) :: self integer :: num_cases num_cases = self % result_ % num_cases () end function pure recursive function test_result_item_num_failing_asserts ( self ) result ( num_asserts ) class ( test_result_item_t ), intent ( in ) :: self integer :: num_asserts num_asserts = self % result_ % num_failing_asserts () end function pure recursive function test_result_item_num_failing_cases ( self ) result ( num_cases ) class ( test_result_item_t ), intent ( in ) :: self integer :: num_cases num_cases = self % result_ % num_failing_cases () end function pure recursive function test_result_item_passed ( self ) result ( passed ) class ( test_result_item_t ), intent ( in ) :: self logical :: passed passed = self % result_ % passed () end function pure recursive function test_result_item_verbose_description ( & self , colorize ) result ( description ) use iso_varying_string , only : varying_string class ( test_result_item_t ), intent ( in ) :: self logical , intent ( in ) :: colorize type ( varying_string ) :: description description = self % result_ % verbose_description ( colorize ) end function function test_that ( tests ) result ( item ) type ( test_item_t ) :: tests (:) type ( test_item_t ) :: item item = describe ( \"Test that\" , tests ) end function function then_basic_c ( description , test ) result ( item ) character ( len =* ), intent ( in ) :: description procedure ( simple_test_i ) :: test type ( test_item_t ) :: item item = it ( \"Then \" // description , test ) end function function then_basic_s ( description , test ) result ( item ) use iso_varying_string , only : varying_string , operator ( // ) type ( varying_string ), intent ( in ) :: description procedure ( simple_test_i ) :: test type ( test_item_t ) :: item item = it ( \"Then \" // description , test ) end function function then_input_c ( description , test ) result ( item ) character ( len =* ), intent ( in ) :: description procedure ( input_test_i ) :: test type ( test_item_t ) :: item item = it_ ( \"Then \" // description , test ) end function function then_input_s ( description , test ) result ( item ) use iso_varying_string , only : varying_string , operator ( // ) type ( varying_string ), intent ( in ) :: description procedure ( input_test_i ) :: test type ( test_item_t ) :: item item = it_ ( \"Then \" // description , test ) end function pure function transformed ( input ) class ( input_t ), intent ( in ) :: input type ( transformed_t ) :: transformed allocate ( transformed % input , source = input ) end function function transforming_test_collection ( description , transformer , tests ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: description procedure ( transformer_i ) :: transformer type ( test_item_t ), intent ( in ) :: tests (:) type ( transforming_test_collection_t ) :: transforming_test_collection transforming_test_collection % description_ = description transforming_test_collection % transformer => transformer allocate ( transforming_test_collection % tests , source = tests ) end function recursive function transforming_test_collection_run_with_input ( self , input ) result ( result_ ) class ( transforming_test_collection_t ), intent ( in ) :: self class ( input_t ), intent ( in ) :: input type ( test_result_item_t ) :: result_ integer :: i type ( test_result_item_t ) :: results ( size ( self % tests )) type ( transformed_t ) :: transformed_ transformed_ = self % transformer ( input ) select type ( transformed_input => transformed_ % input ) type is ( transformation_failure_t ) allocate ( result_ % result_ , source = test_case_result ( & self % description_ , transformed_input % result_ )) class default do i = 1 , size ( self % tests ) results ( i ) = self % tests ( i )% run ( transformed_input ) end do allocate ( result_ % result_ , source = test_collection_result ( & self % description_ , results )) end select end function function transforming_test_collection_run_without_input ( self ) result ( result_ ) class ( transforming_test_collection_t ), intent ( in ) :: self type ( test_result_item_t ) :: result_ allocate ( result_ % result_ , source = test_case_result ( & self % description_ , fail ( \"No input provided\" ))) end function function when_basic_c ( description , tests ) result ( item ) character ( len =* ), intent ( in ) :: description type ( test_item_t ), intent ( in ) :: tests (:) type ( test_item_t ) :: item item = describe ( \"When \" // description , tests ) end function function when_basic_s ( description , tests ) result ( item ) use iso_varying_string , only : varying_string , operator ( // ) type ( varying_string ), intent ( in ) :: description type ( test_item_t ), intent ( in ) :: tests (:) type ( test_item_t ) :: item item = describe ( \"When \" // description , tests ) end function function when_with_transformer_c ( description , transformer , tests ) result ( item ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: description procedure ( transformer_i ) :: transformer type ( test_item_t ), intent ( in ) :: tests (:) type ( test_item_t ) :: item allocate ( item % test , source = transforming_test_collection ( & var_str ( \"When \" // description ), transformer , tests )) end function function when_with_transformer_s ( description , transformer , tests ) result ( item ) use iso_varying_string , only : varying_string , operator ( // ) type ( varying_string ), intent ( in ) :: description procedure ( transformer_i ) :: transformer type ( test_item_t ), intent ( in ) :: tests (:) type ( test_item_t ) :: item allocate ( item % test , source = transforming_test_collection ( & \"When \" // description , transformer , tests )) end function pure function with_user_message_cc ( message , user_message ) result ( whole_message ) use iso_varying_string , only : var_str character ( len =* ), intent ( in ) :: message character ( len =* ), intent ( in ) :: user_message type ( varying_string ) :: whole_message whole_message = with_user_message ( & var_str ( message ), var_str ( user_message )) end function pure function with_user_message_cs ( message , user_message ) result ( whole_message ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: message type ( varying_string ), intent ( in ) :: user_message type ( varying_string ) :: whole_message whole_message = with_user_message ( var_str ( message ), user_message ) end function pure function with_user_message_sc ( message , user_message ) result ( whole_message ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: message character ( len =* ), intent ( in ) :: user_message type ( varying_string ) :: whole_message whole_message = with_user_message ( & message , var_str ( user_message )) end function pure function with_user_message_ss ( message , user_message ) result ( whole_message ) use iso_varying_string , only : varying_string , operator ( // ), operator ( == ) use strff , only : hanging_indent , indent , NEWLINE type ( varying_string ), intent ( in ) :: message type ( varying_string ), intent ( in ) :: user_message type ( varying_string ) :: whole_message if ( user_message == \"\" ) then whole_message = message else whole_message = & message // NEWLINE & // indent ( & hanging_indent ( & \"User Message:\" // NEWLINE & // delimit ( hanging_indent ( & user_message , 1 )), & INDENTATION ), & INDENTATION ) end if end function end module","tags":"","loc":"sourcefile/vegetables.f90.html","title":"vegetables.f90 – miniFAVOR"},{"text":"Contents Programs main Source Code main.f90 Source Code ! Generated by make_vegetable_driver. DO NOT EDIT program main implicit none call run () contains subroutine run () use collective_subroutines_test , only : & collective_subroutines_co_all => test_co_all , & collective_subroutines_co_sum => test_co_sum use data_partition_test , only : & data_partition_data_partition => test_data_partition use object_interface_test , only : & object_interface_object => test_object use single_image_intrinsics_test , only : & single_image_intrinsics_findloc => test_findloc use vegetables , only : test_item_t , test_that , run_tests type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 5 ) individual_tests ( 1 ) = collective_subroutines_co_all () individual_tests ( 2 ) = collective_subroutines_co_sum () individual_tests ( 3 ) = data_partition_data_partition () individual_tests ( 4 ) = object_interface_object () individual_tests ( 5 ) = single_image_intrinsics_findloc () tests = test_that ( individual_tests ) call run_tests ( tests ) end subroutine end program","tags":"","loc":"sourcefile/main.f90~14.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Modules single_image_intrinsics_test Source Code single_image_intrinsics_test.F90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! module single_image_intrinsics_test use Vegetables , only : Result_t , Test_Item_t , describe , it , assert_equals #ifdef COMPILER_LACKS_FINDLOC use emulated_intrinsics_interface , only : findloc #endif implicit none private public :: test_findloc contains function test_findloc () result ( tests ) type ( Test_Item_t ) :: tests tests = describe ( & \"findloc\" , & [ it ( & \"handles zero-sized argument\" , & check_zero_sized_argument ), & it ( & \"handles absent back argument\" , & check_absent_back ), & it ( & \"handles .false. back argument\" , & check_false_back ), & it ( & \"handles .true. back argument\" , & check_true_back ), & it ( & \"handles absent back argument\" , & check_logical_argument ), & it ( & \"handles character array argument\" , & check_character_array ), & it ( & \"handles empty character array argument\" , & check_empty_character_array ), & it ( & \"handles failed search\" , & check_nonexistent_character_value )]) end function function check_zero_sized_argument () result ( result_ ) type ( Result_t ) :: result_ integer , parameter :: zero_sized_array ( * ) = [ integer :: ] result_ = assert_equals ( 0 , findloc ( zero_sized_array , value = 99 , dim = 1 , back = . true .), \"findloc handles zero-sized array\" ) end function function check_absent_back () result ( result_ ) type ( Result_t ) :: result_ result_ = assert_equals ( 3 , findloc ([ 1 , 2 , 3 , 4 ], value = 3 , dim = 1 ), \"findloc handles absent 'back' argument\" ) end function function check_false_back () result ( result_ ) type ( Result_t ) :: result_ result_ = assert_equals ( 2 , findloc ([ 1 , 2 , 3 , 4 ], value = 2 , dim = 1 , back = . false .), \"findloc handles .false. 'back' argument\" ) end function function check_true_back () result ( result_ ) type ( Result_t ) :: result_ result_ = assert_equals ( 1 , findloc ([ 1 , 2 , 3 , 4 ], value = 1 , dim = 1 , back = . true .), \"findloc handles .true. 'back' argument\" ) end function function check_logical_argument () result ( result_ ) type ( Result_t ) :: result_ logical , parameter :: first_true ( * ) = [. true ., . false ., . false .] result_ = assert_equals ( 1 , findloc ( first_true , value = . true ., dim = 1 , back = . true .), \"findloc handles logical argument\" ) end function function check_character_array () result ( result_ ) type ( Result_t ) :: result_ character ( len =* ), parameter , dimension ( * ) :: rgb = [ \"roy\" , \"gee\" , \"biv\" ] result_ = assert_equals ( 2 , findloc ( rgb , value = \"gee\" , dim = 1 ), \"findloc finds string location\" ) end function function check_empty_character_array () result ( result_ ) type ( Result_t ) :: result_ character ( len =* ), parameter , dimension ( * ) :: empty = [ character ( len = len ( \"hello\" )) :: ] result_ = & assert_equals ( 0 , findloc ( empty , value = \"hello\" , dim = 1 , back = . false .), \"findloc handles empty character array from front\" ) end function function check_nonexistent_character_value () result ( result_ ) type ( Result_t ) :: result_ character ( len =* ), parameter , dimension ( * ) :: unsuccessful = [ \"foo\" , \"bar\" , \"too\" ] result_ = assert_equals ( 0 , & findloc ( unsuccessful , value = \"foobar\" , dim = 1 , back = . false .), \"findloc handles character array without search target\" ) end function end module","tags":"","loc":"sourcefile/single_image_intrinsics_test.f90.html","title":"single_image_intrinsics_test.F90 – miniFAVOR"},{"text":"Contents Modules object_interface_test Source Code object_interface_test.f90 Source Code module object_interface_test !! author: Damian Rouson !! !! summary: verify object pattern asbtract parent use vegetables , only : & result_t , input_t , integer_input_t , test_item_t , & ! types describe , it , assert_equals , assert_that , assert_not ! functions use object_interface , only : object implicit none private public :: test_object type , extends ( object ) :: subject contains procedure write_formatted end type contains function test_object () result ( tests ) type ( test_item_t ) tests tests = describe ( & \"object class\" , & [ it ( & \".not. user_defined() if only default-initialized\" , & check_default_initialization ), & it ( & \"user_defined() after call mark_as_defined\" , & check_mark_as_defined )]) end function function check_default_initialization () result ( result_ ) !! Verify that user_defined() is .false. for a default-initialied object class ( object ), allocatable :: object_ type ( result_t ) result_ allocate ( subject :: object_ ) result_ = assert_not ( object_ % user_defined ()) end function function check_mark_as_defined () result ( result_ ) !! Verify that mark_as_defined results in user_defined() being .true. class ( object ), allocatable :: object_ type ( result_t ) result_ allocate ( subject :: object_ ) call object_ % mark_as_defined result_ = assert_that ( object_ % user_defined ()) end function subroutine write_formatted ( self , unit , iotype , v_list , iostat , iomsg ) class ( subject ), intent ( in ) :: self integer , intent ( in ) :: unit character ( * ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg select case ( iotype ) case ( 'LISTDIRECTED' ) write ( unit , * ) self % user_defined () iostat = 0 iomsg = \"\" case default iostat = - 1 iomsg = \"object_interface_test: subject%write_formatted iotype received unsupported iotype \" // iotype end select associate ( unused => v_list ) end associate end subroutine end module object_interface_test","tags":"","loc":"sourcefile/object_interface_test.f90.html","title":"object_interface_test.f90 – miniFAVOR"},{"text":"Contents Modules data_partition_test Source Code data_partition_test.f90 Source Code module data_partition_test !! author: Damian Rouson !! !! summary: verify data partitioning across images and data gathering use vegetables , only : & result_t , input_t , integer_input_t , test_item_t , & ! types describe , it , assert_equals , assert_that , example ! functions use data_partition_interface , only : data_partition use iso_fortran_env , only : real64 implicit none private public :: test_data_partition type ( data_partition ) partition integer , parameter :: num_particles = 31 , gatherer = 1 , num_steps = 9 , dummy = 0 contains function test_data_partition () result ( tests ) type ( test_item_t ) tests integer iteration call partition % define_partitions ( cardinality = num_particles ) associate ( me => this_image () ) associate ( my_first => partition % first ( me ), my_last => partition % last ( me ) ) tests = describe ( & \"data_partition class\" , & [ it ( & \"partitions data in nearly even blocks\" , & verify_block_partitioning ), & it ( & \"all data partitioned across all images without data loss\" , & verify_all_particles_partitioned ), & it ( & \"1D real array gathered on all images\" , & [ example ( integer_input_t ( dummy )), example ( integer_input_t ( dummy ))], & verify_all_gather_1D_real_array ), & it ( & \"dimension 1 of 2D real array gathered on all images witout dim argument\" , & [ example ( integer_input_t ( dummy )), example ( integer_input_t ( dummy ))], & verify_all_gather_2D_real_array ), & it ( & \"dimension 1 of 2D real array gathered on all images with dim argument\" , & [ example ( integer_input_t ( dummy )), example ( integer_input_t ( dummy ))], & verify_all_gather_2D_real_array_dim1 ), & it ( & \"dimension 1 of 2D real array gathered onto result_image with dim argument\" , & [ example ( integer_input_t ( dummy )), example ( integer_input_t ( dummy ))], & verify_gather_2D_real_array_dim1 )]) end associate end associate end function function verify_block_partitioning () result ( result_ ) !! Verify that the data is partitioned across images evenly to !! within a difference of one datum between any two images. type ( data_partition ) partition type ( result_t ) result_ integer my_particles associate ( me => this_image () ) associate ( my_first => partition % first ( me ), my_last => partition % last ( me ) ) my_particles = my_last - my_first + 1 associate ( ni => num_images () ) associate ( quotient => num_particles / ni , remainder => mod ( num_particles , ni ) ) result_ = assert_equals ( quotient + merge ( 1 , 0 , me <= remainder ), my_particles , \"block distribution\" ) end associate end associate end associate end associate end function function verify_all_particles_partitioned () result ( result_ ) !! Verify that the number of particles on each image sums to the !! total number of particles distributed. type ( data_partition ) partition type ( result_t ) result_ integer particles associate ( me => this_image ()) associate ( my_first => partition % first ( me ), my_last => partition % last ( me ) ) particles = my_last - my_first + 1 call co_sum ( particles ) result_ = assert_equals ( num_particles , particles , \"all particles distributed\" ) end associate end associate end function function verify_all_gather_1D_real_array ( unused ) result ( result_ ) type ( data_partition ) partition class ( input_t ), intent ( in ) :: unused type ( result_t ) result_ real ( real64 ) :: particle_scalar ( num_particles ) real ( real64 ), parameter :: junk =- 1234 5._real64 , expected = 1._real64 associate ( no_op => unused ) ! eliminate unused-variable warning end associate associate ( me => this_image ()) associate ( first => partition % first ( me ), last => partition % last ( me ) ) particle_scalar ( first : last ) = expected !! values to be gathered particle_scalar ( 1 : first - 1 ) = junk !! values to be overwritten by the gather particle_scalar ( last + 1 :) = junk !! values to be overwritten by the gather call partition % gather ( particle_scalar ) result_ = assert_that ( all ( particle_scalar == expected ), \"real 1D array all-gathered\" ) end associate end associate end function function verify_all_gather_2D_real_array ( unused ) result ( result_ ) class ( input_t ), intent ( in ) :: unused type ( data_partition ) partition type ( result_t ) result_ integer , parameter :: vec_space_dim = 3 real ( real64 ) particle_vector ( vec_space_dim , num_particles ) real ( real64 ), parameter :: junk =- 1234 5._real64 , expected = 1._real64 associate ( no_op => unused ) ! eliminate unused-variable warning end associate associate ( me => this_image ()) associate ( first => partition % first ( me ), last => partition % last ( me ) ) particle_vector (:, first : last ) = expected !! values to be gathered particle_vector (:, 1 : first - 1 ) = junk !! values to be overwritten by the gather particle_vector (:, last + 1 :) = junk !! values to be overwritten by the gather call partition % gather ( particle_vector ) result_ = assert_that ( all ( particle_vector == expected ), \"real 2D array all-gathered implicitly along dimension 1\" ) end associate end associate end function function verify_all_gather_2D_real_array_dim1 ( unused ) result ( result_ ) class ( input_t ), intent ( in ) :: unused type ( data_partition ) partition type ( result_t ) result_ integer , parameter :: vec_space_dim = 3 real ( real64 ) :: vector_transpose ( num_particles , vec_space_dim ) real ( real64 ), parameter :: junk =- 1234 5._real64 , expected = 1._real64 associate ( no_op => unused ) ! eliminate unused-variable warning end associate associate ( me => this_image ()) associate ( first => partition % first ( me ), last => partition % last ( me ) ) vector_transpose ( first : last , :) = expected !! values to be gathered vector_transpose ( 1 : first - 1 , :) = junk !! values to be overwritten by the gather vector_transpose ( last + 1 :, :) = junk !! values to be overwritten by the gather call partition % gather ( vector_transpose , dim = 1 ) result_ = assert_that ( all ( vector_transpose == expected ), \"vector_transpose gathered explicitly along dimension 1\" ) end associate end associate end function function verify_gather_2D_real_array_dim1 ( unused ) result ( result_ ) class ( input_t ), intent ( in ) :: unused type ( data_partition ) partition type ( result_t ) result_ integer , parameter :: vec_space_dim = 3 real ( real64 ) :: vector_transpose ( num_particles , vec_space_dim ) real ( real64 ), parameter :: junk =- 1234 5._real64 , expected = 1._real64 associate ( no_op => unused ) ! eliminate unused-variable warning end associate associate ( me => this_image ()) associate ( first => partition % first ( me ), last => partition % last ( me ) ) vector_transpose ( first : last , :) = expected !! values to be gathered vector_transpose ( 1 : first - 1 , :) = junk !! values to be overwritten by the gather vector_transpose ( last + 1 :, :) = junk !! values to be overwritten by the gather call partition % gather ( vector_transpose , result_image = gatherer , dim = 1 ) if ( me == gatherer ) then result_ = assert_that ( all ( vector_transpose == expected ), \"all( particle_vector==expected)\" ) else result_ = & assert_that ( all ( vector_transpose ( 1 : first - 1 ,:) == junk ), \"lower transpose data unchanged)\" ) . and . & assert_that ( all ( vector_transpose ( first : last ,:) == expected ), \"expected transpose data gathered\" ) . and . & assert_that ( all ( vector_transpose ( last + 1 :,:) == junk ), \"upper transpose data unchanged)\" ) end if end associate end associate end function end module data_partition_test","tags":"","loc":"sourcefile/data_partition_test.f90.html","title":"data_partition_test.f90 – miniFAVOR"},{"text":"Contents Modules collective_subroutines_test Source Code collective_subroutines_test.F90 Source Code module collective_subroutines_test use Vegetables , only : Result_t , Test_Item_t , describe , it , assert_equals , assert_that , assert_not use emulated_intrinsics_interface , only : & #ifdef COMPILER_LACKS_COLLECTIVE_SUBROUTINES co_all , co_sum #else co_all #endif implicit none private public :: test_co_all public :: test_co_sum contains function test_co_all () result ( tests ) type ( Test_Item_t ) :: tests tests = describe ( & \"co_all\" , & [ it ( & \"sets all arguments to .true. when previously .true. on all images\" , & check_co_all_with_all_true ), & it ( & \"sets all arguments to .false. when previously .false. on image 1\" , & check_co_all_with_one_false )]) end function function check_co_all_with_all_true () result ( result_ ) type ( Result_t ) :: result_ logical all_true all_true = . true . call co_all ( all_true ) result_ = assert_that ( all_true , \"co_all argument remains .true. after call with all arguments .true.\" ) end function function check_co_all_with_one_false () result ( result_ ) type ( Result_t ) :: result_ logical all_true all_true = merge (. false ., . true ., this_image () == 1 ) call co_all ( all_true ) result_ = assert_not ( all_true , \"co_all argument is .false. after call with one argument .false.\" ) end function function test_co_sum () result ( tests ) type ( Test_Item_t ) :: tests tests = describe ( & \"co_sum\" , & [ it ( & \"gives sums with result_image present\" , & check_co_sum_with_result_image ), & it ( & \"gives sums without result_image present\" , & check_co_sum_without_result_image )]) end function function check_co_sum_with_result_image () result ( result_ ) type ( Result_t ) :: result_ integer i , j integer , parameter :: result_image = 2 associate ( me => this_image ()) i = me call co_sum ( i , result_image ) if ( me == result_image ) then result_ = assert_equals ( sum ([( j , j = 1 , num_images ())]), i , \"collective sum on result_image\" ) else result_ = assert_equals ( me , i , \"co_sum argument unchanged on non-result_image\" ) end if end associate end function function check_co_sum_without_result_image () result ( result_ ) type ( Result_t ) :: result_ integer i , j integer , parameter :: result_image = 2 associate ( me => this_image ()) i = me call co_sum ( i ) result_ = assert_equals ( sum ([( j , j = 1 , num_images ())]), i , \"co_sum without result_image present\" ) end associate end function end module","tags":"","loc":"sourcefile/collective_subroutines_test.f90.html","title":"collective_subroutines_test.F90 – miniFAVOR"},{"text":"Contents Modules emulated_intrinsics_interface Source Code emulated_intrinsics_interface.F90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! module emulated_intrinsics_interface !! author: Damian Rouson !! !! This module contains two categories of procedures: !! 1. Emulations of some Fortran 2008 and 2018 instrinsic procedures for use with !!    compilers that lack support for the corresponding procedures. !! 2. User-defined collective procedures not defined in the Fortran standard. implicit none interface module subroutine co_all ( boolean ) implicit none logical , intent ( inout ) :: boolean end subroutine end interface !! Fortran 2003 emulation of Fortran 2008 intrinsic procedures (e.g, findloc) #ifdef COMPILER_LACKS_FINDLOC interface findloc !! result is the last occurrence of a value in an array or zero if not found module procedure findloc_integer_dim1 , findloc_logical_dim1 , findloc_character_dim1 end interface #endif !! Fortran 2008 coarray emulations of Fortran 2018 intrinsic collective subroutines #ifdef COMPILER_LACKS_COLLECTIVE_SUBROUTINES interface co_sum !! parallel computation of the sum of the first argument module procedure co_sum_integer end interface interface co_broadcast !! parallel one-to-all communication of the value of first argument module procedure co_broadcast_integer end interface #endif interface #ifdef COMPILER_LACKS_COLLECTIVE_SUBROUTINES module subroutine co_sum_integer ( a , result_image , stat , errmsg ) implicit none integer , intent ( inout ) :: a integer , intent ( in ), optional :: result_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine module subroutine co_broadcast_integer ( a , source_image , stat , errmsg ) implicit none integer , intent ( inout ) :: a integer , intent ( in ) :: source_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine #endif #ifdef COMPILER_LACKS_FINDLOC pure module function findloc_integer_dim1 ( array , value , dim , back ) result ( location ) implicit none integer , intent ( in ) :: array (:), value , dim logical , intent ( in ), optional :: back integer location end function pure module function findloc_logical_dim1 ( array , value , dim , back ) result ( location ) implicit none logical , intent ( in ) :: array (:), value , back integer , intent ( in ) :: dim integer location end function pure module function findloc_character_dim1 ( array , value , dim , back ) result ( location ) implicit none character ( len =* ), intent ( in ) :: array (:), value integer , intent ( in ) :: dim logical , intent ( in ) :: back integer location end function #endif end interface end module emulated_intrinsics_interface","tags":"","loc":"sourcefile/emulated_intrinsics_interface.f90.html","title":"emulated_intrinsics_interface.F90 – miniFAVOR"},{"text":"Contents Submodules object_implementation Source Code object_implementation.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( object_interface ) object_implementation implicit none contains module procedure mark_as_defined this % defined = . true . end procedure module procedure user_defined is_defined = this % defined end procedure end submodule","tags":"","loc":"sourcefile/object_implementation.f90.html","title":"object_implementation.f90 – miniFAVOR"},{"text":"Contents Modules string_functions_interface Source Code string_functions_interface.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! module string_functions_interface !! author: Damian Rouson !! date: August 23, 2019 !! summary: utilities for manipulating or producing character variables implicit none private public :: file_extension , csv_format , base_name , string character ( len =* ), parameter :: csv_format = '(*(G0,:,\",\"))' interface string module procedure integer_to_string end interface interface pure module function file_extension ( file_name ) result ( extension ) !! result contains all characters in file_name after the first dot (.) character ( len =* ), intent ( in ) :: file_name character ( len = :), allocatable :: extension end function pure module function base_name ( file_name ) result ( base ) !! result contains all characters in file_name before the first dot (.) character ( len =* ), intent ( in ) :: file_name character ( len = :), allocatable :: base end function pure module function integer_to_string ( integer_value ) result ( characters ) integer , intent ( in ) :: integer_value character ( len = :), allocatable :: characters end function end interface end module","tags":"","loc":"sourcefile/string_functions_interface.f90.html","title":"string_functions_interface.f90 – miniFAVOR"},{"text":"Contents Submodules array_functions_implementation Source Code array_functions_implementation.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( array_functions_interface ) array_functions_implementation use assertions_interface , only : assert , assertions implicit none contains module procedure column_vectors integer i , j , k associate ( n => shape ( vector_field ) ) if ( assertions ) call assert ( size ( n ) == 4 , \"3D vector field input\" ) allocate ( array_of_3D_column_vectors ( n ( 4 ), product ( n ( 1 : 3 )) ) ) do concurrent ( i = 1 : n ( 1 ), j = 1 : n ( 2 ), k = 1 : n ( 3 ) ) associate ( id => ( k - 1 ) * PRODUCT ( n ( 1 : 2 )) + ( j - 1 ) * n ( 1 ) + i ) array_of_3D_column_vectors (:, id ) = vector_field ( i , j , k ,:) end associate end do end associate end procedure module procedure concatenate_columns !! Using reshape rather than manipulating array elements directly frees the compiler to decide the particular order of array !! element references that best exploits the given platform.  Alternatively, do concurrent could instead free the compiler !! to order element accesses however is best. Trade-off: reshape requires the creation of temporary array results but reshape !! is likely to have more mature compiler support than do concurrent.  If this code turns out to be a critical performance !! bottleneck, try replacing this implementation with element-by-element copying using do concurrent. associate ( rows => size ( a , 1 )) associate ( cols => size ( a , 2 ) + size ( b , 2 )) associate ( a_unrolled => reshape ( a ,[ size ( a )])) associate ( b_unrolled => reshape ( b ,[ size ( b )])) if ( assertions ) call assert ( rows == size ( b , 1 ), \"array_functions: compatible shapes\" ) concatenated = reshape ( [ a_unrolled , b_unrolled ],[ rows , cols ] ) end associate ; end associate ; end associate ; end associate end procedure module procedure concatenate_rows !! For simplicity, this implementation invokes concatenate_columns at the cost of transpose creating additional temporaries. !! If this code turns out to be a critical performance bottleneck, try replacing this implementation with element-by-element !! copying using do concurrent. concatenated = transpose ( concatenate_columns ( transpose ( a ), transpose ( b )) ) end procedure end submodule","tags":"","loc":"sourcefile/array_functions_implementation.f90.html","title":"array_functions_implementation.f90 – miniFAVOR"},{"text":"Contents Submodules emulated_intrinsics_implementation Source Code emulated_intrinsics_implementation.F90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( emulated_intrinsics_interface ) emulated_intrinsics_implementation use assertions_interface , only : assert implicit none contains module procedure co_all call co_reduce ( boolean , both ) #ifdef FORD end procedure #else contains #endif pure function both ( lhs , rhs ) result ( lhs_and_rhs ) logical , intent ( in ) :: lhs , rhs logical lhs_and_rhs lhs_and_rhs = lhs . and . rhs end function #ifndef FORD end procedure #endif #ifdef COMPILER_LACKS_COLLECTIVE_SUBROUTINES module procedure co_sum_integer !! Binary tree collective sum reduction integer , save :: total [ * ] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) my_image = this_image () if (. not . present ( result_image )) then my_node = my_image else if ( my_image == result_image ) then my_node = root_node else my_node = merge ( result_image , my_image , my_image == default_root_image ) end if end if parent_node = my_node / 2 default_parent_image = my_image / 2 if (. not . present ( result_image )) then parent_image = parent_node else if ( parent_node == root_node ) then parent_image = result_image else if ( default_parent_image == result_image ) then parent_image = default_root_image else parent_image = parent_node end if end if total = a even_child_node = 2 * my_node if (. not . present ( result_image )) then even_child_image = even_child_node else even_child_image = merge ( even_child_node , default_root_image , even_child_node /= result_image ) end if if ( exists ( even_child_node ) ) then sync images ( even_child_image ) total = total + total [ even_child_image ] end if odd_child_node = 2 * my_node + 1 if (. not . present ( result_image )) then odd_child_image = odd_child_node else odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= result_image ) end if if ( exists ( odd_child_node ) ) then sync images ( odd_child_image ) total = total + total [ odd_child_image ] end if if ( exists ( parent_image )) sync images ( parent_image ) if ( present ( result_image )) then if ( my_image == result_image ) a = total else call co_broadcast ( total , source_image = default_root_image ) a = total end if if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) end procedure module procedure co_broadcast_integer !! Binary tree collective broadcast integer , save :: message [ * ] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) my_image = this_image () if ( my_image == source_image ) then my_node = root_node else my_node = merge ( source_image , my_image , my_image == default_root_image ) end if parent_node = my_node / 2 default_parent_image = my_image / 2 if ( parent_node == root_node ) then parent_image = source_image else if ( default_parent_image == source_image ) then parent_image = default_root_image else parent_image = parent_node end if if ( exists ( parent_image )) then sync images ( parent_image ) message = message [ parent_image ] else message = a !! define the message for broadcasting down the tree when the orphaned root image falls through this branch end if even_child_node = 2 * my_node even_child_image = merge ( even_child_node , default_root_image , even_child_node /= source_image ) if ( exists ( even_child_node ) ) sync images ( even_child_image ) odd_child_node = 2 * my_node + 1 odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= source_image ) if ( exists ( odd_child_node ) ) sync images ( odd_child_image ) a = message relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 end procedure elemental function exists ( image ) result ( image_exists ) !! Result true if image number is within the closed range [1,num_images()] integer , intent ( in ) :: image logical image_exists image_exists = ( image > 0 . and . image <= num_images ()) end function #endif #ifdef COMPILER_LACKS_FINDLOC module procedure findloc_integer_dim1 if ( . not . present ( back )) then location = minloc ( array , dim , array == value ) else if ( back . eqv . . false .) then location = minloc ( array , dim , array == value ) else ! back is present and .true. so work around GCC 8 lack of support for the \"back\" argument block integer , parameter :: loop_increment =- 1 , base_index = 1 integer index_ call assert ( dim == 1 , \"findloc_integer_dim1: unsupported use case\" ) associate ( lower_bound => lbound ( array , dim ) ) do index_ = ubound ( array , dim ), lower_bound , loop_increment if ( array ( index_ ) == value ) then location = index_ - lower_bound + base_index return end if end do end associate location = 0 end block end if end procedure module procedure findloc_logical_dim1 integer , parameter :: loop_increment =- 1 , base_index = 1 integer index_ call assert ( back . and . dim == 1 , \"findloc_logical_dim1_backtrue: unsupported use case\" ) associate ( lower_bound => lbound ( array , dim ) ) do index_ = ubound ( array , dim ), lower_bound , loop_increment if ( array ( index_ ) . eqv . value ) then location = index_ - lower_bound + base_index return end if end do end associate location = 0 end procedure module procedure findloc_character_dim1 integer , parameter :: base_index = 1 integer index_ , loop_increment , start , finish call assert ( dim == 1 , \"findloc_character_dim1: unsupported use case\" ) associate ( lower_bound => lbound ( array , dim ) ) select case ( back ) case (. true .) start = ubound ( array , dim ) finish = lower_bound loop_increment =- 1 case (. false .) start = lower_bound finish = ubound ( array , dim ) loop_increment = 1 end select do index_ = start , finish , loop_increment if ( array ( index_ ) == value ) then location = index_ - lower_bound + base_index return end if end do end associate location = 0 end procedure #endif end submodule emulated_intrinsics_implementation","tags":"","loc":"sourcefile/emulated_intrinsics_implementation.f90.html","title":"emulated_intrinsics_implementation.F90 – miniFAVOR"},{"text":"Contents Submodules string_functions_implementation Source Code string_functions_implementation.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( string_functions_interface ) string_functions_implementation implicit none contains module procedure file_extension character ( len = :), allocatable :: name_ name_ = trim ( file_name ) associate ( dot_location => index ( name_ , '.' , back = . true .) ) if ( dot_location < len ( name_ )) then extension = name_ ( dot_location + 1 :) else extension = \"\" end if end associate end procedure module procedure base_name character ( len = :), allocatable :: name_ name_ = trim ( file_name ) associate ( dot_location => index ( name_ , '.' , back = . true .) ) if ( dot_location < len ( name_ )) then base = name_ ( 1 : dot_location - 1 ) else base = \"\" end if end associate end procedure module procedure integer_to_string integer , parameter :: max_characters = 16 character ( len = max_characters ) string write ( string , * ) integer_value characters = trim ( adjustl ( string )) end procedure end submodule","tags":"","loc":"sourcefile/string_functions_implementation.f90.html","title":"string_functions_implementation.f90 – miniFAVOR"},{"text":"Contents Modules assertions_interface Source Code assertions_interface.F90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! #ifndef USE_ASSERTIONS # define USE_ASSERTIONS .true. #endif module assertions_interface !! summary: Utility for runtime checking of logical assertions. !! usage: error-terminate if the assertion fails: !! !!    use assertions_interface, only : assert !!    call assert( 2 > 1, \"2 > 1\") !! !! Turn off assertions in production code by setting USE_ASSERTIONS to .false. via the preprocessor: !! !!    caf -cpp -DUSE_ASSERTIONS=.false. -c assertions_interface.f90 !! !! Doing so may eliminate any associated runtime overhead by enabling optimizing compilers to ignore !! the assertion procedure body during a dead-code-removal phase of optimization. implicit none private public :: assert , assertions , max_errmsg_len logical , parameter :: assertions = USE_ASSERTIONS integer , parameter :: max_errmsg_len = len ( & \"warning (183): FASTMEM allocation is requested but the libmemkind library is not linked in, so using the default allocator.\" ) !! longest Intel compiler error message (see https://intel.ly/35x84yr). interface elemental module subroutine assert ( assertion , description , diagnostic_data ) !! If assertion is .false., error-terminate with optional, variable stop code containing diagnostic_data implicit none logical , intent ( in ) :: assertion !! Most assertions will be expressions, e.g., call assert( i>0, \"positive i\") character ( len =* ), intent ( in ) :: description !! Brief statement of what is being asserted class ( * ), intent ( in ), optional :: diagnostic_data !! Optional error stop code, which may be of intrinsic type or object class end subroutine end interface end module","tags":"","loc":"sourcefile/assertions_interface.f90.html","title":"assertions_interface.F90 – miniFAVOR"},{"text":"Contents Modules co_object_interface Source Code co_object_interface.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! module co_object_interface implicit none private public :: co_object ! Define an abstract parent type to ensure basic functionality expected to be provided by all non-abstract types. ! Each non-abstract type provides the functionality by extending this type and implementing its deferred binding(s).  This ! type resembles java's Object class in the sense that it is intended to be the ultimate ancester of every other type. type , abstract :: co_object private logical :: defined = . false . !! Default initialization indicates not yet user-defined logical , allocatable :: facilitate_type_extension [:] contains procedure :: mark_as_defined procedure :: user_defined end type interface pure module subroutine mark_as_defined ( this ) !! Mark the co_object as user-defined implicit none class ( co_object ), intent ( inout ) :: this end subroutine pure module function user_defined ( this ) result ( is_defined ) !! Return a boolean result indicating whether this co_object has been initialized since its declaration implicit none class ( co_object ), intent ( in ) :: this logical :: is_defined end function end interface end module co_object_interface","tags":"","loc":"sourcefile/co_object_interface.f90.html","title":"co_object_interface.f90 – miniFAVOR"},{"text":"Contents Submodules co_object_implementation Source Code co_object_implementation.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( co_object_interface ) co_object_implementation implicit none contains module procedure mark_as_defined this % defined = . true . end procedure module procedure user_defined is_defined = this % defined end procedure end submodule","tags":"","loc":"sourcefile/co_object_implementation.f90.html","title":"co_object_implementation.f90 – miniFAVOR"},{"text":"Contents Modules data_partition_interface Source Code data-partition-interface.f90 Source Code module data_partition_interface !! distribute data identification numbers across images such that the number of !! items differs by at most 1 between any two images. use iso_fortran_env , only : real64 implicit none private public :: data_partition type data_partition !! encapsulate a description of the data subset the executing image owns private contains procedure , nopass :: define_partitions procedure , nopass :: first procedure , nopass :: last procedure , nopass , private :: gather_real_2D_array , gather_real_1D_array generic :: gather => gather_real_2D_array , gather_real_1D_array end type integer , allocatable :: first_datum (:), last_datum (:) interface module subroutine define_partitions ( cardinality ) !! define the range of data identification numbers owned by the executing image integer , intent ( in ) :: cardinality end subroutine pure module function first ( image_number ) result ( first_index ) !! the result is the first identification number owned by the executing image implicit none integer , intent ( in ) :: image_number integer first_index end function pure module function last ( image_number ) result ( last_index ) !! the result is the last identification number owned by the executing image implicit none integer , intent ( in ) :: image_number integer last_index end function !! Gathers are inherently expensive and are best used either !! 1. Near the beginning/end of execution to amortize costs across an entire run or !! 2. Temporarily while developing/debugging code. module subroutine gather_real_1D_array ( a , result_image , dim ) !! Gather the elements of an 1D array distributed along dimension dim onto result_image real ( real64 ), intent ( inout ) :: a (:) integer , intent ( in ), optional :: result_image integer , intent ( in ), optional :: dim end subroutine module subroutine gather_real_2D_array ( a , result_image , dim ) !! Gather the elements of an 2D array distributed along dimension dim onto result_image real ( real64 ), intent ( inout ) :: a (:,:) integer , intent ( in ), optional :: result_image integer , intent ( in ), optional :: dim end subroutine end interface end module data_partition_interface","tags":"","loc":"sourcefile/data-partition-interface.f90.html","title":"data-partition-interface.f90 – miniFAVOR"},{"text":"Contents Modules array_functions_interface Source Code array_functions_interface.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! module array_functions_interface !! author: Damian Rouson !! date: 04/25/2019 !! !! Functionally pure array utilities implicit none private public :: operator (. catColumns .) public :: operator (. catRows .) public :: operator (. columnVectors .) !! Because the Fortran standard requires that operator dummy arguments have the intent(in) attribute !! exposing only the operator and not the function names communicates more information in the !! public interface and in code using this interface. interface operator (. columnVectors .) module procedure column_vectors end interface interface operator (. catColumns .) module procedure concatenate_columns end interface interface operator (. catRows .) module procedure concatenate_rows end interface interface pure module function column_vectors ( vector_field ) result ( array_of_3D_column_vectors ) !! Result is array of 3D column vectors of dimension (space_dim,nx*ny*nz) reshaped from vector-field argument !! of dimension (nx,ny,nz,space_dim) implicit none real , dimension (:,:,:,:), intent ( in ) :: vector_field real , dimension (:,:), allocatable :: array_of_3D_column_vectors end function pure module function concatenate_columns ( a , b ) result ( concatenated ) !! Result contains the concatenation of the columns of argument a with the columns of argument b implicit none real , dimension (:,:), intent ( in ) :: a , b real , dimension (:,:), allocatable :: concatenated end function pure module function concatenate_rows ( a , b ) result ( concatenated ) !! Result contains the concatenation of the rows of argument a with the rows of argument b implicit none real , dimension (:,:), intent ( in ) :: a , b real , dimension (:,:), allocatable :: concatenated end function end interface end module","tags":"","loc":"sourcefile/array_functions_interface.f90.html","title":"array_functions_interface.f90 – miniFAVOR"},{"text":"Contents Modules object_interface Source Code object_interface.f90 Source Code ! ### Copyright notice ! !     ``` !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 !     ``` module object_interface implicit none private public :: object type , abstract :: object !! author: Damian Rouson, GSE LLC !! category: Morfeus-FD !! summary: Abstract type to ensure all objects extending it implement the required methods !! !! Define an abstract parent type to ensure basic functionality expected to be provided by all non-abstract types. !! Each non-abstract type provides the functionality by extending this type and implementing its deferred binding(s).  This !! type resembles java's Object class in the sense that it is intended to be the ultimate ancestor of every other type. private logical :: defined = . false . !! Default initialization indicates not yet user-defined contains procedure :: mark_as_defined procedure :: user_defined procedure ( write_interface ), deferred :: write_formatted generic :: write ( formatted ) => write_formatted end type interface pure module subroutine mark_as_defined ( this ) !! Mark the object as user-defined implicit none class ( object ), intent ( inout ) :: this end subroutine pure module function user_defined ( this ) result ( is_defined ) !! Return a boolean result indicating whether this object has been initialized since its declaration implicit none class ( object ), intent ( in ) :: this logical :: is_defined end function end interface abstract interface subroutine write_interface ( self , unit , iotype , v_list , iostat , iomsg ) import object class ( object ), intent ( in ) :: self integer , intent ( in ) :: unit character ( * ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg end subroutine end interface end module object_interface","tags":"","loc":"sourcefile/object_interface.f90.html","title":"object_interface.f90 – miniFAVOR"},{"text":"Contents Submodules assertions_implementation Source Code assertions_implementation.F90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( assertions_interface ) assertions_implementation implicit none contains module procedure assert use iso_fortran_env , only : error_unit use string_functions_interface , only : string use object_interface , only : object character ( len = :), allocatable :: header , trailer integer , parameter :: max_this_image_digits = 9 if ( assertions ) then if (. not . assertion ) then associate ( assertion_failed_on => 'Assertion \"' // description // '\" failed on image' ) header = repeat ( \" \" , ncopies = len ( assertion_failed_on ) + max_this_image_digits ) write ( header , * ) assertion_failed_on , this_image () end associate if (. not . present ( diagnostic_data )) then trailer = \"\" else block character ( len =* ), parameter :: prefix = \"with diagnostic data\" integer , parameter :: max_data_length = 1024 select type ( diagnostic_data ) type is ( character ( len =* )) trailer = prefix // diagnostic_data type is ( integer ) trailer = prefix // string ( diagnostic_data ) class is ( object ) trailer = repeat ( \" \" , ncopies = max_data_length ) write ( trailer , * ) diagnostic_data class default trailer = prefix // 'of unsupported type' end select end block end if error stop header // trim ( trailer ) end if end if end procedure end submodule","tags":"","loc":"sourcefile/assertions_implementation.f90.html","title":"assertions_implementation.F90 – miniFAVOR"},{"text":"Contents Submodules data_partition_implementation Source Code data-partition-implementation.F90 Source Code submodule ( data_partition_interface ) data_partition_implementation use assertions_interface , only : assert , assertions implicit none logical , parameter :: verbose = . false . contains module procedure define_partitions if ( allocated ( first_datum )) deallocate ( first_datum ) if ( allocated ( last_datum )) deallocate ( last_datum ) associate ( ni => num_images () ) call assert ( ni <= cardinality , \"sufficient data for distribution across images\" ) allocate ( first_datum ( ni ), last_datum ( ni )) block integer i , image do image = 1 , ni associate ( remainder => mod ( cardinality , ni ), quotient => cardinality / ni ) first_datum ( image ) = sum ([( quotient + overflow ( i , remainder ), i = 1 , image - 1 )]) + 1 last_datum ( image ) = first_datum ( image ) + quotient + overflow ( image , remainder ) - 1 end associate end do end block end associate #ifdef FORD end procedure #else contains #endif pure function overflow ( im , excess ) result ( extra_datum ) integer , intent ( in ) :: im , excess integer extra_datum extra_datum = merge ( 1 , 0 , im <= excess ) end function #ifndef FORD end procedure #endif module procedure first if ( assertions ) call assert ( allocated ( first_datum ), \"allocated(first_datum)\" ) first_index = first_datum ( image_number ) end procedure module procedure last if ( assertions ) call assert ( allocated ( last_datum ), \"allocated(last_datum)\" ) last_index = last_datum ( image_number ) end procedure module procedure gather_real_1D_array if ( present ( dim )) call assert ( dim == 1 , \"dimensioned partitioned == 1\" ) associate ( me => this_image () ) if ( verbose ) then write ( 6 , * ) 'gather_real_1D_array(): executing on image' , me flush ( 6 ) end if associate ( first => first ( me ), last => last ( me ) ) if (. not . present ( result_image )) then a ( 1 : first - 1 ) = 0. a ( last + 1 :) = 0. call co_sum ( a ) else block real ( real64 ), allocatable , dimension (:) :: a_lower , a_upper a_lower = a ( 1 : first - 1 ) a_upper = a ( last + 1 :) a ( 1 : first - 1 ) = 0. a ( last + 1 :) = 0. call co_sum ( a , result_image = result_image ) if ( result_image /= me ) then a ( 1 : first - 1 ) = a_lower a ( last + 1 :) = a_upper end if end block end if end associate end associate end procedure module procedure gather_real_2D_array integer dim_ if ( present ( dim )) then dim_ = dim else dim_ = 2 end if associate ( me => this_image () ) if ( verbose ) then write ( 6 , * ) 'gather_real_2D_array(): executing on image' , me flush ( 6 ) end if associate ( first => first ( me ), last => last ( me ) ) if (. not . present ( result_image )) then select case ( dim_ ) case ( 1 ) a ( 1 : first - 1 , :) = 0. a ( last + 1 :, :) = 0. case ( 2 ) a (:, 1 : first - 1 ) = 0. a (:, last + 1 :) = 0. case default error stop \"gather_real_2D_array: invalid dim argument\" end select call co_sum ( a ) else block real ( real64 ), allocatable , dimension (:,:) :: a_lower , a_upper select case ( dim_ ) case ( 1 ) a_lower = a ( 1 : first - 1 , :) a_upper = a ( last + 1 :, :) a ( 1 : first - 1 , :) = 0. a ( last + 1 :, :) = 0. case ( 2 ) a_lower = a (:, 1 : first - 1 ) a_upper = a (:, last + 1 :) a (:, 1 : first - 1 ) = 0. a (:, last + 1 :) = 0. case default error stop \"gather_real_2D_array: invalid dim argument\" end select call co_sum ( a , result_image = result_image ) if ( result_image /= me ) then select case ( dim_ ) case ( 1 ) a ( 1 : first - 1 , :) = a_lower a ( last + 1 :, :) = a_upper case ( 2 ) a (:, 1 : first - 1 ) = a_lower a (:, last + 1 :) = a_upper case default error stop \"gather_real_2D_array: invalid dim argument\" end select end if end block end if end associate end associate end procedure end submodule data_partition_implementation","tags":"","loc":"sourcefile/data-partition-implementation.f90.html","title":"data-partition-implementation.F90 – miniFAVOR"},{"text":"Contents Programs main Source Code main.f90 Source Code ! Generated by make_vegetable_driver. DO NOT EDIT program main implicit none call run () contains subroutine run () use hanging_indent_test , only : & hanging_indent_hanging_indent => test_hanging_indent use indent_test , only : & indent_indent => test_indent use join_test , only : & join_join => test_join use read_file_lines_test , only : & read_file_lines_read_file_lines => test_read_file_lines use read_file_test , only : & read_file_read_file => test_read_file use split_at_test , only : & split_at_split_at => test_split_at use starts_with_test , only : & starts_with_starts_with => test_starts_with use to_string_test , only : & to_string_to_string_for_doubles => test_to_string_for_doubles , & to_string_to_string_for_integers => test_to_string_for_integers use vegetables , only : test_item_t , test_that , run_tests type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 9 ) individual_tests ( 1 ) = hanging_indent_hanging_indent () individual_tests ( 2 ) = indent_indent () individual_tests ( 3 ) = join_join () individual_tests ( 4 ) = read_file_lines_read_file_lines () individual_tests ( 5 ) = read_file_read_file () individual_tests ( 6 ) = split_at_split_at () individual_tests ( 7 ) = starts_with_starts_with () individual_tests ( 8 ) = to_string_to_string_for_doubles () individual_tests ( 9 ) = to_string_to_string_for_integers () tests = test_that ( individual_tests ) call run_tests ( tests ) end subroutine end program","tags":"","loc":"sourcefile/main.f90~15.html","title":"main.f90 – miniFAVOR"},{"text":"Contents Modules join_test Source Code join_test.f90 Source Code module join_test implicit none private public :: test_join contains function test_join () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( & \"for only one string returns that string\" , check_join_one ) individual_tests ( 2 ) = it ( & \"puts multiple strings together separated by the given string\" , & check_join_multiple ) tests = describe ( \"join\" , individual_tests ) end function test_join pure function check_join_one () result ( result_ ) use iso_varying_string , only : var_str use strff , only : join use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: EXAMPLE = \"Example\" result_ = assert_equals ( EXAMPLE , join ([ var_str ( EXAMPLE )], \"anything\" )) end function pure function check_join_multiple () result ( result_ ) use iso_varying_string , only : var_str use strff , only : join use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( & \"Hello, again, world\" , & join ([ var_str ( \"Hello\" ), var_str ( \"again\" ), var_str ( \"world\" )], \", \" )) end function end module","tags":"","loc":"sourcefile/join_test.f90.html","title":"join_test.f90 – miniFAVOR"},{"text":"Contents Modules read_file_lines_test Source Code read_file_lines_test.f90 Source Code module read_file_lines_test implicit none private public :: test_read_file_lines contains function test_read_file_lines () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( & \"gets the contents from the file\" , check_read_file_lines ) individual_tests ( 2 ) = it ( & \"is faster than an alternative implementation\" , check_speed ) tests = describe ( \"read_file_lines\" , individual_tests ) end function function check_read_file_lines () result ( result_ ) use iso_varying_string , only : varying_string , put use strff , only : read_file_lines , NEWLINE use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: FIRST_LINE = \"First Line\" character ( len =* ), parameter :: SECOND_LINE = \"2nd Line\" character ( len =* ), parameter :: THIRD_LINE = \"Third Line\" character ( len =* ), parameter :: FILE_CONTENTS = & FIRST_LINE // NEWLINE // SECOND_LINE // NEWLINE // THIRD_LINE character ( len =* ), parameter :: TEMP_FILE_NAME = \"read_file_lines_tmp.txt\" type ( varying_string ), allocatable :: lines (:) integer :: file_unit allocate ( lines ( 0 )) ! TODO: remove once bug in gfortran has been fixed open ( newunit = file_unit , file = TEMP_FILE_NAME , action = \"WRITE\" , status = \"REPLACE\" ) call put ( file_unit , FILE_CONTENTS ) close ( file_unit ) lines = read_file_lines ( TEMP_FILE_NAME ) open ( newunit = file_unit , file = TEMP_FILE_NAME ) close ( file_unit , status = \"DELETE\" ) result_ = & assert_equals ( FIRST_LINE , lines ( 1 )) & . and . assert_equals ( SECOND_LINE , lines ( 2 )) & . and . assert_equals ( THIRD_LINE , lines ( 3 )) end function function check_speed () result ( result_ ) use iso_varying_string , only : varying_string , put use text_m , only : TEST_TEXT use vegetables , only : result_t , assert_faster_than type ( result_t ) :: result_ character ( len =* ), parameter :: TEMP_FILE_NAME = \"read_file_lines_speed_tmp.txt\" type ( varying_string ), allocatable :: lines (:) integer :: file_unit open ( newunit = file_unit , file = TEMP_FILE_NAME , action = \"WRITE\" , status = \"REPLACE\" ) call put ( file_unit , TEST_TEXT ) close ( file_unit ) result_ = assert_faster_than ( do_alt_read , do_fast_read , 50 ) open ( newunit = file_unit , file = TEMP_FILE_NAME ) close ( file_unit , status = \"DELETE\" ) contains subroutine do_fast_read use strff , only : read_file_lines lines = read_file_lines ( TEMP_FILE_NAME ) end subroutine subroutine do_alt_read lines = alt_read_file_lines ( TEMP_FILE_NAME ) end subroutine end function function alt_read_file_lines ( filename ) result ( lines ) use iso_fortran_env , only : IOSTAT_END use iso_varying_string , only : varying_string , operator ( // ), get use strff , only : split_at , NEWLINE character ( len =* ), intent ( in ) :: filename type ( varying_string ), allocatable :: lines (:) type ( varying_string ) :: contents integer :: file_unit integer :: stat type ( varying_string ) :: tmp open ( newunit = file_unit , file = filename , action = \"READ\" , status = \"OLD\" ) call get ( file_unit , contents , iostat = stat ) if ( stat == IOSTAT_END ) return do call get ( file_unit , tmp , iostat = stat ) if ( stat == IOSTAT_END ) exit contents = contents // NEWLINE // tmp end do close ( file_unit ) lines = split_at ( contents , NEWLINE ) end function end module","tags":"","loc":"sourcefile/read_file_lines_test.f90.html","title":"read_file_lines_test.f90 – miniFAVOR"},{"text":"Contents Modules text_m Source Code text_m.f90 Source Code module text_m use strff , only : NEWLINE implicit none private public :: TEST_TEXT character ( len =* ), parameter :: TEST_TEXT = & \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\" // NEWLINE & // \"incididunt ut labore et dolore magna aliqua. Dis parturient montes nascetur\" // NEWLINE & // \"ridiculus mus mauris vitae ultricies leo. Odio pellentesque diam volutpat\" // NEWLINE & // \"commodo. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\" // NEWLINE & // \"Blandit libero volutpat sed cras ornare arcu. Amet venenatis urna cursus eget\" // NEWLINE & // \"nunc. Venenatis cras sed felis eget velit aliquet sagittis id. Massa tincidunt\" // NEWLINE & // \"dui ut ornare lectus sit amet. Dui id ornare arcu odio ut sem nulla pharetra\" // NEWLINE & // \"diam. Condimentum mattis pellentesque id nibh tortor id aliquet. Arcu dictum\" // NEWLINE & // \"varius duis at consectetur lorem donec massa. Et netus et malesuada fames ac\" // NEWLINE & // \"turpis egestas. Aliquet risus feugiat in ante metus dictum at tempor. Sagittis\" // NEWLINE & // \"purus sit amet volutpat consequat. A arcu cursus vitae congue mauris rhoncus.\" // NEWLINE & // \"Luctus venenatis lectus magna fringilla urna porttitor rhoncus dolor. Massa\" // NEWLINE & // \"sapien faucibus et molestie ac feugiat sed lectus vestibulum. Turpis massa sed\" // NEWLINE & // \"elementum tempus. At urna condimentum mattis pellentesque id nibh.\" // NEWLINE & // \"\" // NEWLINE & // \"Nunc lobortis mattis aliquam faucibus purus in. Sit amet aliquam id diam\" // NEWLINE & // \"maecenas ultricies mi. Porttitor leo a diam sollicitudin tempor id eu nisl. Erat\" // NEWLINE & // \"nam at lectus urna duis convallis convallis tellus. Sapien nec sagittis aliquam\" // NEWLINE & // \"malesuada bibendum arcu vitae. Aenean pharetra magna ac placerat. Augue mauris\" // NEWLINE & // \"augue neque gravida in fermentum. Urna et pharetra pharetra massa massa\" // NEWLINE & // \"ultricies. Odio euismod lacinia at quis risus. Nisl tincidunt eget nullam non\" // NEWLINE & // \"nisi est sit amet facilisis. Pretium vulputate sapien nec sagittis aliquam. Enim\" // NEWLINE & // \"praesent elementum facilisis leo vel. Iaculis eu non diam phasellus vestibulum\" // NEWLINE & // \"lorem sed. Duis ultricies lacus sed turpis tincidunt id. Eget egestas purus\" // NEWLINE & // \"viverra accumsan in nisl. In eu mi bibendum neque egestas congue quisque egestas\" // NEWLINE & // \"diam.\" // NEWLINE & // \"\" // NEWLINE & // \"Scelerisque purus semper eget duis at tellus at urna condimentum. Pellentesque\" // NEWLINE & // \"dignissim enim sit amet. Urna nec tincidunt praesent semper feugiat. Lorem dolor\" // NEWLINE & // \"sed viverra ipsum nunc aliquet. Sit amet aliquam id diam maecenas ultricies mi.\" // NEWLINE & // \"Ut tortor pretium viverra suspendisse potenti nullam. Non quam lacus suspendisse\" // NEWLINE & // \"faucibus interdum posuere lorem ipsum dolor. Ut sem viverra aliquet eget sit\" // NEWLINE & // \"amet tellus cras adipiscing. Nulla malesuada pellentesque elit eget gravida.\" // NEWLINE & // \"Tellus rutrum tellus pellentesque eu tincidunt. Morbi tristique senectus et\" // NEWLINE & // \"netus et malesuada fames. Lacus sed viverra tellus in. Volutpat diam ut\" // NEWLINE & // \"venenatis tellus in metus vulputate eu scelerisque. Habitasse platea dictumst\" // NEWLINE & // \"quisque sagittis purus sit amet volutpat consequat. Enim ut sem viverra aliquet\" // NEWLINE & // \"eget sit amet. Enim tortor at auctor urna nunc id cursus metus aliquam. Magna\" // NEWLINE & // \"eget est lorem ipsum dolor sit amet consectetur adipiscing.\" // NEWLINE & // \"\" // NEWLINE & // \"Sed adipiscing diam donec adipiscing. Ultrices neque ornare aenean euismod\" // NEWLINE & // \"elementum nisi quis. At ultrices mi tempus imperdiet nulla. Pellentesque\" // NEWLINE & // \"habitant morbi tristique senectus et netus et malesuada fames. Pretium quam\" // NEWLINE & // \"vulputate dignissim suspendisse. Justo nec ultrices dui sapien eget mi proin.\" // NEWLINE & // \"Vitae sapien pellentesque habitant morbi tristique senectus. Neque volutpat ac\" // NEWLINE & // \"tincidunt vitae semper quis lectus. Penatibus et magnis dis parturient montes\" // NEWLINE & // \"nascetur ridiculus. Et malesuada fames ac turpis. Tellus elementum sagittis\" // NEWLINE & // \"vitae et leo duis ut diam. Adipiscing commodo elit at imperdiet dui accumsan sit\" // NEWLINE & // \"amet. Neque vitae tempus quam pellentesque nec nam aliquam.\" // NEWLINE & // \"\" // NEWLINE & // \"Faucibus in ornare quam viverra orci sagittis eu volutpat. Amet consectetur\" // NEWLINE & // \"adipiscing elit pellentesque habitant. Faucibus scelerisque eleifend donec\" // NEWLINE & // \"pretium vulputate sapien nec. Nunc scelerisque viverra mauris in aliquam sem\" // NEWLINE & // \"fringilla. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\" // NEWLINE & // \"Accumsan sit amet nulla facilisi morbi tempus iaculis urna id. Orci a\" // NEWLINE & // \"scelerisque purus semper. Nulla malesuada pellentesque elit eget gravida cum.\" // NEWLINE & // \"Gravida dictum fusce ut placerat orci nulla. Diam quam nulla porttitor massa id.\" // NEWLINE & // \"Arcu non sodales neque sodales ut. Arcu dictum varius duis at consectetur lorem.\" // NEWLINE & // \"Semper feugiat nibh sed pulvinar. Morbi tincidunt augue interdum velit euismod\" // NEWLINE & // \"in pellentesque massa. Felis eget nunc lobortis mattis aliquam faucibus purus.\" // NEWLINE & // \"Eros in cursus turpis massa tincidunt dui ut. Amet porttitor eget dolor morbi\" // NEWLINE & // \"non arcu risus. Sagittis eu volutpat odio facilisis mauris sit amet massa vitae.\" // NEWLINE & // \"Eu mi bibendum neque egestas.\" // NEWLINE & // \"\" // NEWLINE & // \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\" // NEWLINE & // \"incididunt ut labore et dolore magna aliqua. Dis parturient montes nascetur\" // NEWLINE & // \"ridiculus mus mauris vitae ultricies leo. Odio pellentesque diam volutpat\" // NEWLINE & // \"commodo. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\" // NEWLINE & // \"Blandit libero volutpat sed cras ornare arcu. Amet venenatis urna cursus eget\" // NEWLINE & // \"nunc. Venenatis cras sed felis eget velit aliquet sagittis id. Massa tincidunt\" // NEWLINE & // \"dui ut ornare lectus sit amet. Dui id ornare arcu odio ut sem nulla pharetra\" // NEWLINE & // \"diam. Condimentum mattis pellentesque id nibh tortor id aliquet. Arcu dictum\" // NEWLINE & // \"varius duis at consectetur lorem donec massa. Et netus et malesuada fames ac\" // NEWLINE & // \"turpis egestas. Aliquet risus feugiat in ante metus dictum at tempor. Sagittis\" // NEWLINE & // \"purus sit amet volutpat consequat. A arcu cursus vitae congue mauris rhoncus.\" // NEWLINE & // \"Luctus venenatis lectus magna fringilla urna porttitor rhoncus dolor. Massa\" // NEWLINE & // \"sapien faucibus et molestie ac feugiat sed lectus vestibulum. Turpis massa sed\" // NEWLINE & // \"elementum tempus. At urna condimentum mattis pellentesque id nibh.\" // NEWLINE & // \"\" // NEWLINE & // \"Nunc lobortis mattis aliquam faucibus purus in. Sit amet aliquam id diam\" // NEWLINE & // \"maecenas ultricies mi. Porttitor leo a diam sollicitudin tempor id eu nisl. Erat\" // NEWLINE & // \"nam at lectus urna duis convallis convallis tellus. Sapien nec sagittis aliquam\" // NEWLINE & // \"malesuada bibendum arcu vitae. Aenean pharetra magna ac placerat. Augue mauris\" // NEWLINE & // \"augue neque gravida in fermentum. Urna et pharetra pharetra massa massa\" // NEWLINE & // \"ultricies. Odio euismod lacinia at quis risus. Nisl tincidunt eget nullam non\" // NEWLINE & // \"nisi est sit amet facilisis. Pretium vulputate sapien nec sagittis aliquam. Enim\" // NEWLINE & // \"praesent elementum facilisis leo vel. Iaculis eu non diam phasellus vestibulum\" // NEWLINE & // \"lorem sed. Duis ultricies lacus sed turpis tincidunt id. Eget egestas purus\" // NEWLINE & // \"viverra accumsan in nisl. In eu mi bibendum neque egestas congue quisque egestas\" // NEWLINE & // \"diam.\" // NEWLINE & // \"\" // NEWLINE & // \"Scelerisque purus semper eget duis at tellus at urna condimentum. Pellentesque\" // NEWLINE & // \"dignissim enim sit amet. Urna nec tincidunt praesent semper feugiat. Lorem dolor\" // NEWLINE & // \"sed viverra ipsum nunc aliquet. Sit amet aliquam id diam maecenas ultricies mi.\" // NEWLINE & // \"Ut tortor pretium viverra suspendisse potenti nullam. Non quam lacus suspendisse\" // NEWLINE & // \"faucibus interdum posuere lorem ipsum dolor. Ut sem viverra aliquet eget sit\" // NEWLINE & // \"amet tellus cras adipiscing. Nulla malesuada pellentesque elit eget gravida.\" // NEWLINE & // \"Tellus rutrum tellus pellentesque eu tincidunt. Morbi tristique senectus et\" // NEWLINE & // \"netus et malesuada fames. Lacus sed viverra tellus in. Volutpat diam ut\" // NEWLINE & // \"venenatis tellus in metus vulputate eu scelerisque. Habitasse platea dictumst\" // NEWLINE & // \"quisque sagittis purus sit amet volutpat consequat. Enim ut sem viverra aliquet\" // NEWLINE & // \"eget sit amet. Enim tortor at auctor urna nunc id cursus metus aliquam. Magna\" // NEWLINE & // \"eget est lorem ipsum dolor sit amet consectetur adipiscing.\" // NEWLINE & // \"\" // NEWLINE & // \"Sed adipiscing diam donec adipiscing. Ultrices neque ornare aenean euismod\" // NEWLINE & // \"elementum nisi quis. At ultrices mi tempus imperdiet nulla. Pellentesque\" // NEWLINE & // \"habitant morbi tristique senectus et netus et malesuada fames. Pretium quam\" // NEWLINE & // \"vulputate dignissim suspendisse. Justo nec ultrices dui sapien eget mi proin.\" // NEWLINE & // \"Vitae sapien pellentesque habitant morbi tristique senectus. Neque volutpat ac\" // NEWLINE & // \"tincidunt vitae semper quis lectus. Penatibus et magnis dis parturient montes\" // NEWLINE & // \"nascetur ridiculus. Et malesuada fames ac turpis. Tellus elementum sagittis\" // NEWLINE & // \"vitae et leo duis ut diam. Adipiscing commodo elit at imperdiet dui accumsan sit\" // NEWLINE & // \"amet. Neque vitae tempus quam pellentesque nec nam aliquam.\" // NEWLINE & // \"\" // NEWLINE & // \"Faucibus in ornare quam viverra orci sagittis eu volutpat. Amet consectetur\" // NEWLINE & // \"adipiscing elit pellentesque habitant. Faucibus scelerisque eleifend donec\" // NEWLINE & // \"pretium vulputate sapien nec. Nunc scelerisque viverra mauris in aliquam sem\" // NEWLINE & // \"fringilla. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\" // NEWLINE & // \"Accumsan sit amet nulla facilisi morbi tempus iaculis urna id. Orci a\" // NEWLINE & // \"scelerisque purus semper. Nulla malesuada pellentesque elit eget gravida cum.\" // NEWLINE & // \"Gravida dictum fusce ut placerat orci nulla. Diam quam nulla porttitor massa id.\" // NEWLINE & // \"Arcu non sodales neque sodales ut. Arcu dictum varius duis at consectetur lorem.\" // NEWLINE & // \"Semper feugiat nibh sed pulvinar. Morbi tincidunt augue interdum velit euismod\" // NEWLINE & // \"in pellentesque massa. Felis eget nunc lobortis mattis aliquam faucibus purus.\" // NEWLINE & // \"Eros in cursus turpis massa tincidunt dui ut. Amet porttitor eget dolor morbi\" // NEWLINE & // \"non arcu risus. Sagittis eu volutpat odio facilisis mauris sit amet massa vitae.\" // NEWLINE & // \"Eu mi bibendum neque egestas.\" // NEWLINE & // \"\" // NEWLINE & // \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\" // NEWLINE & // \"incididunt ut labore et dolore magna aliqua. Dis parturient montes nascetur\" // NEWLINE & // \"ridiculus mus mauris vitae ultricies leo. Odio pellentesque diam volutpat\" // NEWLINE & // \"commodo. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\" // NEWLINE & // \"Blandit libero volutpat sed cras ornare arcu. Amet venenatis urna cursus eget\" // NEWLINE & // \"nunc. Venenatis cras sed felis eget velit aliquet sagittis id. Massa tincidunt\" // NEWLINE & // \"dui ut ornare lectus sit amet. Dui id ornare arcu odio ut sem nulla pharetra\" // NEWLINE & // \"diam. Condimentum mattis pellentesque id nibh tortor id aliquet. Arcu dictum\" // NEWLINE & // \"varius duis at consectetur lorem donec massa. Et netus et malesuada fames ac\" // NEWLINE & // \"turpis egestas. Aliquet risus feugiat in ante metus dictum at tempor. Sagittis\" // NEWLINE & // \"purus sit amet volutpat consequat. A arcu cursus vitae congue mauris rhoncus.\" // NEWLINE & // \"Luctus venenatis lectus magna fringilla urna porttitor rhoncus dolor. Massa\" // NEWLINE & // \"sapien faucibus et molestie ac feugiat sed lectus vestibulum. Turpis massa sed\" // NEWLINE & // \"elementum tempus. At urna condimentum mattis pellentesque id nibh.\" // NEWLINE & // \"\" // NEWLINE & // \"Nunc lobortis mattis aliquam faucibus purus in. Sit amet aliquam id diam\" // NEWLINE & // \"maecenas ultricies mi. Porttitor leo a diam sollicitudin tempor id eu nisl. Erat\" // NEWLINE & // \"nam at lectus urna duis convallis convallis tellus. Sapien nec sagittis aliquam\" // NEWLINE & // \"malesuada bibendum arcu vitae. Aenean pharetra magna ac placerat. Augue mauris\" // NEWLINE & // \"augue neque gravida in fermentum. Urna et pharetra pharetra massa massa\" // NEWLINE & // \"ultricies. Odio euismod lacinia at quis risus. Nisl tincidunt eget nullam non\" // NEWLINE & // \"nisi est sit amet facilisis. Pretium vulputate sapien nec sagittis aliquam. Enim\" // NEWLINE & // \"praesent elementum facilisis leo vel. Iaculis eu non diam phasellus vestibulum\" // NEWLINE & // \"lorem sed. Duis ultricies lacus sed turpis tincidunt id. Eget egestas purus\" // NEWLINE & // \"viverra accumsan in nisl. In eu mi bibendum neque egestas congue quisque egestas\" // NEWLINE & // \"diam.\" // NEWLINE & // \"\" // NEWLINE & // \"Scelerisque purus semper eget duis at tellus at urna condimentum. Pellentesque\" // NEWLINE & // \"dignissim enim sit amet. Urna nec tincidunt praesent semper feugiat. Lorem dolor\" // NEWLINE & // \"sed viverra ipsum nunc aliquet. Sit amet aliquam id diam maecenas ultricies mi.\" // NEWLINE & // \"Ut tortor pretium viverra suspendisse potenti nullam. Non quam lacus suspendisse\" // NEWLINE & // \"faucibus interdum posuere lorem ipsum dolor. Ut sem viverra aliquet eget sit\" // NEWLINE & // \"amet tellus cras adipiscing. Nulla malesuada pellentesque elit eget gravida.\" // NEWLINE & // \"Tellus rutrum tellus pellentesque eu tincidunt. Morbi tristique senectus et\" // NEWLINE & // \"netus et malesuada fames. Lacus sed viverra tellus in. Volutpat diam ut\" // NEWLINE & // \"venenatis tellus in metus vulputate eu scelerisque. Habitasse platea dictumst\" // NEWLINE & // \"quisque sagittis purus sit amet volutpat consequat. Enim ut sem viverra aliquet\" // NEWLINE & // \"eget sit amet. Enim tortor at auctor urna nunc id cursus metus aliquam. Magna\" // NEWLINE & // \"eget est lorem ipsum dolor sit amet consectetur adipiscing.\" // NEWLINE & // \"\" // NEWLINE & // \"Sed adipiscing diam donec adipiscing. Ultrices neque ornare aenean euismod\" // NEWLINE & // \"elementum nisi quis. At ultrices mi tempus imperdiet nulla. Pellentesque\" // NEWLINE & // \"habitant morbi tristique senectus et netus et malesuada fames. Pretium quam\" // NEWLINE & // \"vulputate dignissim suspendisse. Justo nec ultrices dui sapien eget mi proin.\" // NEWLINE & // \"Vitae sapien pellentesque habitant morbi tristique senectus. Neque volutpat ac\" // NEWLINE & // \"tincidunt vitae semper quis lectus. Penatibus et magnis dis parturient montes\" // NEWLINE & // \"nascetur ridiculus. Et malesuada fames ac turpis. Tellus elementum sagittis\" // NEWLINE & // \"vitae et leo duis ut diam. Adipiscing commodo elit at imperdiet dui accumsan sit\" // NEWLINE & // \"amet. Neque vitae tempus quam pellentesque nec nam aliquam.\" // NEWLINE & // \"\" // NEWLINE & // \"Faucibus in ornare quam viverra orci sagittis eu volutpat. Amet consectetur\" // NEWLINE & // \"adipiscing elit pellentesque habitant. Faucibus scelerisque eleifend donec\" // NEWLINE & // \"pretium vulputate sapien nec. Nunc scelerisque viverra mauris in aliquam sem\" // NEWLINE & // \"fringilla. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\" // NEWLINE & // \"Accumsan sit amet nulla facilisi morbi tempus iaculis urna id. Orci a\" // NEWLINE & // \"scelerisque purus semper. Nulla malesuada pellentesque elit eget gravida cum.\" // NEWLINE & // \"Gravida dictum fusce ut placerat orci nulla. Diam quam nulla porttitor massa id.\" // NEWLINE & // \"Arcu non sodales neque sodales ut. Arcu dictum varius duis at consectetur lorem.\" // NEWLINE & // \"Semper feugiat nibh sed pulvinar. Morbi tincidunt augue interdum velit euismod\" // NEWLINE & // \"in pellentesque massa. Felis eget nunc lobortis mattis aliquam faucibus purus.\" // NEWLINE & // \"Eros in cursus turpis massa tincidunt dui ut. Amet porttitor eget dolor morbi\" // NEWLINE & // \"non arcu risus. Sagittis eu volutpat odio facilisis mauris sit amet massa vitae.\" // NEWLINE & // \"Eu mi bibendum neque egestas.\" // NEWLINE & // \"\" // NEWLINE & // \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\" // NEWLINE & // \"incididunt ut labore et dolore magna aliqua. Dis parturient montes nascetur\" // NEWLINE & // \"ridiculus mus mauris vitae ultricies leo. Odio pellentesque diam volutpat\" // NEWLINE & // \"commodo. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\" // NEWLINE & // \"Blandit libero volutpat sed cras ornare arcu. Amet venenatis urna cursus eget\" // NEWLINE & // \"nunc. Venenatis cras sed felis eget velit aliquet sagittis id. Massa tincidunt\" // NEWLINE & // \"dui ut ornare lectus sit amet. Dui id ornare arcu odio ut sem nulla pharetra\" // NEWLINE & // \"diam. Condimentum mattis pellentesque id nibh tortor id aliquet. Arcu dictum\" // NEWLINE & // \"varius duis at consectetur lorem donec massa. Et netus et malesuada fames ac\" // NEWLINE & // \"turpis egestas. Aliquet risus feugiat in ante metus dictum at tempor. Sagittis\" // NEWLINE & // \"purus sit amet volutpat consequat. A arcu cursus vitae congue mauris rhoncus.\" // NEWLINE & // \"Luctus venenatis lectus magna fringilla urna porttitor rhoncus dolor. Massa\" // NEWLINE & // \"sapien faucibus et molestie ac feugiat sed lectus vestibulum. Turpis massa sed\" // NEWLINE & // \"elementum tempus. At urna condimentum mattis pellentesque id nibh.\" // NEWLINE & // \"\" // NEWLINE & // \"Nunc lobortis mattis aliquam faucibus purus in. Sit amet aliquam id diam\" // NEWLINE & // \"maecenas ultricies mi. Porttitor leo a diam sollicitudin tempor id eu nisl. Erat\" // NEWLINE & // \"nam at lectus urna duis convallis convallis tellus. Sapien nec sagittis aliquam\" // NEWLINE & // \"malesuada bibendum arcu vitae. Aenean pharetra magna ac placerat. Augue mauris\" // NEWLINE & // \"augue neque gravida in fermentum. Urna et pharetra pharetra massa massa\" // NEWLINE & // \"ultricies. Odio euismod lacinia at quis risus. Nisl tincidunt eget nullam non\" // NEWLINE & // \"nisi est sit amet facilisis. Pretium vulputate sapien nec sagittis aliquam. Enim\" // NEWLINE & // \"praesent elementum facilisis leo vel. Iaculis eu non diam phasellus vestibulum\" // NEWLINE & // \"lorem sed. Duis ultricies lacus sed turpis tincidunt id. Eget egestas purus\" // NEWLINE & // \"viverra accumsan in nisl. In eu mi bibendum neque egestas congue quisque egestas\" // NEWLINE & // \"diam.\" // NEWLINE & // \"\" // NEWLINE & // \"Scelerisque purus semper eget duis at tellus at urna condimentum. Pellentesque\" // NEWLINE & // \"dignissim enim sit amet. Urna nec tincidunt praesent semper feugiat. Lorem dolor\" // NEWLINE & // \"sed viverra ipsum nunc aliquet. Sit amet aliquam id diam maecenas ultricies mi.\" // NEWLINE & // \"Ut tortor pretium viverra suspendisse potenti nullam. Non quam lacus suspendisse\" // NEWLINE & // \"faucibus interdum posuere lorem ipsum dolor. Ut sem viverra aliquet eget sit\" // NEWLINE & // \"amet tellus cras adipiscing. Nulla malesuada pellentesque elit eget gravida.\" // NEWLINE & // \"Tellus rutrum tellus pellentesque eu tincidunt. Morbi tristique senectus et\" // NEWLINE & // \"netus et malesuada fames. Lacus sed viverra tellus in. Volutpat diam ut\" // NEWLINE & // \"venenatis tellus in metus vulputate eu scelerisque. Habitasse platea dictumst\" // NEWLINE & // \"quisque sagittis purus sit amet volutpat consequat. Enim ut sem viverra aliquet\" // NEWLINE & // \"eget sit amet. Enim tortor at auctor urna nunc id cursus metus aliquam. Magna\" // NEWLINE & // \"eget est lorem ipsum dolor sit amet consectetur adipiscing.\" // NEWLINE & // \"\" // NEWLINE & // \"Sed adipiscing diam donec adipiscing. Ultrices neque ornare aenean euismod\" // NEWLINE & // \"elementum nisi quis. At ultrices mi tempus imperdiet nulla. Pellentesque\" // NEWLINE & // \"habitant morbi tristique senectus et netus et malesuada fames. Pretium quam\" // NEWLINE & // \"vulputate dignissim suspendisse. Justo nec ultrices dui sapien eget mi proin.\" // NEWLINE & // \"Vitae sapien pellentesque habitant morbi tristique senectus. Neque volutpat ac\" // NEWLINE & // \"tincidunt vitae semper quis lectus. Penatibus et magnis dis parturient montes\" // NEWLINE & // \"nascetur ridiculus. Et malesuada fames ac turpis. Tellus elementum sagittis\" // NEWLINE & // \"vitae et leo duis ut diam. Adipiscing commodo elit at imperdiet dui accumsan sit\" // NEWLINE & // \"amet. Neque vitae tempus quam pellentesque nec nam aliquam.\" // NEWLINE & // \"\" // NEWLINE & // \"Faucibus in ornare quam viverra orci sagittis eu volutpat. Amet consectetur\" // NEWLINE & // \"adipiscing elit pellentesque habitant. Faucibus scelerisque eleifend donec\" // NEWLINE & // \"pretium vulputate sapien nec. Nunc scelerisque viverra mauris in aliquam sem\" // NEWLINE & // \"fringilla. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\" // NEWLINE & // \"Accumsan sit amet nulla facilisi morbi tempus iaculis urna id. Orci a\" // NEWLINE & // \"scelerisque purus semper. Nulla malesuada pellentesque elit eget gravida cum.\" // NEWLINE & // \"Gravida dictum fusce ut placerat orci nulla. Diam quam nulla porttitor massa id.\" // NEWLINE & // \"Arcu non sodales neque sodales ut. Arcu dictum varius duis at consectetur lorem.\" // NEWLINE & // \"Semper feugiat nibh sed pulvinar. Morbi tincidunt augue interdum velit euismod\" // NEWLINE & // \"in pellentesque massa. Felis eget nunc lobortis mattis aliquam faucibus purus.\" // NEWLINE & // \"Eros in cursus turpis massa tincidunt dui ut. Amet porttitor eget dolor morbi\" // NEWLINE & // \"non arcu risus. Sagittis eu volutpat odio facilisis mauris sit amet massa vitae.\" // NEWLINE & // \"Eu mi bibendum neque egestas.\" // NEWLINE end module","tags":"","loc":"sourcefile/text_m.f90.html","title":"text_m.f90 – miniFAVOR"},{"text":"Contents Modules to_string_test Source Code to_string_test.f90 Source Code module to_string_test implicit none private public :: test_to_string_for_doubles , test_to_string_for_integers contains function test_to_string_for_doubles () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 6 ) individual_tests ( 1 ) = it ( & \"includes zero after the decimal\" , & check_includes_zero_after_decimal ) individual_tests ( 2 ) = it ( & \"only keeps the specified number of digits\" , & check_only_keeps_six_digits ) individual_tests ( 3 ) = it ( & \"handles zero correctly\" , & check_handles_zero ) individual_tests ( 4 ) = it ( & \"handles extreme numbers correctly\" , & check_handles_extreme_numbers ) individual_tests ( 5 ) = it ( & \"can do negative numbers\" , & check_negative_numbers ) individual_tests ( 6 ) = it ( & \"shortens round numbers with scientific notation\" , & check_round_numbers ) tests = describe ( \"to_string for doubles\" , individual_tests ) end function function test_to_string_for_integers () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 1 ) individual_tests ( 1 ) = it ( \"works\" , checkto_string_for_integers ) tests = describe ( \"to_string for integers\" , individual_tests ) end function pure function check_includes_zero_after_decimal () result ( result_ ) use strff , only : to_string use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( \"1.0\" , to_string ( 1.0D0 )) & . and . assert_equals ( \"10.0\" , to_string ( 1.0D1 )) end function pure function check_only_keeps_six_digits () result ( result_ ) use strff , only : to_string use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( \"123457.0\" , to_string ( 12345 6.7D0 , 6 )) & . and . assert_equals ( \"123456.0\" , to_string ( 12345 6.1D0 , 6 )) & . and . assert_equals ( \"1.23457e6\" , to_string ( 123456 7.0D0 , 6 )) & . and . assert_equals ( \"1.23456e6\" , to_string ( 123456 1.0D0 , 6 )) & . and . assert_equals ( \"0.123457\" , to_string ( 0.1234567D0 , 6 )) & . and . assert_equals ( \"0.123456\" , to_string ( 0.1234561D0 , 6 )) & . and . assert_equals ( \"1.23457e-2\" , to_string ( 0.01234567D0 , 6 )) & . and . assert_equals ( \"1.23456e-2\" , to_string ( 0.01234561D0 , 6 )) end function pure function check_handles_zero () result ( result_ ) use strff , only : to_string use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( \"0.0\" , to_string ( 0.0D0 )) & . and . assert_equals ( \"0.0\" , to_string ( tiny ( 0.0D0 ))) end function pure function check_handles_extreme_numbers () result ( result_ ) use strff , only : to_string use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( \"1.23456e11\" , to_string ( 1.23456D11 , 6 )) & . and . assert_equals ( \"1.23457e11\" , to_string ( 1.234567D11 , 6 )) & . and . assert_equals ( \"1.23456e11\" , to_string ( 1.234561D11 , 6 )) & . and . assert_equals ( \"1.23456e111\" , to_string ( 1.23456D111 , 6 )) & . and . assert_equals ( \"1.23457e111\" , to_string ( 1.234567D111 , 6 )) & . and . assert_equals ( \"1.23456e111\" , to_string ( 1.234561D111 , 6 )) & . and . assert_equals ( \"1.23456e-11\" , to_string ( 1.23456D-11 , 6 )) & . and . assert_equals ( \"1.23457e-11\" , to_string ( 1.234567D-11 , 6 )) & . and . assert_equals ( \"1.23456e-11\" , to_string ( 1.234561D-11 , 6 )) & . and . assert_equals ( \"1.23456e-111\" , to_string ( 1.23456D-111 , 6 )) & . and . assert_equals ( \"1.23457e-111\" , to_string ( 1.234567D-111 , 6 )) & . and . assert_equals ( \"1.23456e-111\" , to_string ( 1.234561D-111 , 6 )) end function pure function check_negative_numbers () result ( result_ ) use strff , only : to_string use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( \"-1.0\" , to_string ( - 1.0D0 , 6 )) & . and . assert_equals ( \"-123457.0\" , to_string ( - 12345 6.7D0 , 6 )) & . and . assert_equals ( \"-0.123457\" , to_string ( - 0.1234567D0 , 6 )) & . and . assert_equals ( \"-1.23457e-2\" , to_string ( - 0.01234567D0 , 6 )) & . and . assert_equals ( \"-1.23457e111\" , to_string ( - 1.234567D111 , 6 )) end function pure function check_round_numbers () result ( result_ ) use strff , only : to_string use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"1.0e6\" , to_string ( 1.0D6 )) end function pure function checkto_string_for_integers () result ( result_ ) use strff , only : to_string use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = & assert_equals ( \"1\" , to_string ( 1 )) & . and . assert_equals ( \"12\" , to_string ( 12 )) & . and . assert_equals ( \"-1\" , to_string ( - 1 )) end function end module","tags":"","loc":"sourcefile/to_string_test.f90.html","title":"to_string_test.f90 – miniFAVOR"},{"text":"Contents Modules read_file_test Source Code read_file_test.f90 Source Code module read_file_test implicit none private public :: test_read_file contains function test_read_file () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 1 ) individual_tests ( 1 ) = it ( \"gets the contents from the file\" , check_read_file ) ! The performance of one implementation over another appears to be ! based heavily on platform, so we don't bother testing it for now. ! individual_tests(2) = it( & !         \"is faster than an alternative implementation\", check_speed) tests = describe ( \"read_file\" , individual_tests ) end function function check_read_file () result ( result_ ) use iso_varying_string , only : put use strff , only : read_file , NEWLINE use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: FILE_CONTENTS = & \"Just\" // NEWLINE & // \"Some\" // NEWLINE & // \"Contents\" character ( len =* ), parameter :: TEMP_FILE_NAME = \"read_file_tmp.txt\" integer :: file_unit open ( newunit = file_unit , file = TEMP_FILE_NAME , action = \"WRITE\" , status = \"REPLACE\" ) call put ( file_unit , FILE_CONTENTS ) close ( file_unit ) result_ = assert_equals ( FILE_CONTENTS , read_file ( TEMP_FILE_NAME )) open ( newunit = file_unit , file = TEMP_FILE_NAME ) close ( file_unit , status = \"DELETE\" ) end function ! function check_speed() result(result_) !     use iso_varying_string, only: varying_string, put !     use text_m, only: TEST_TEXT !     use vegetables, only: result_t, assert_faster_than ! !     type(result_t) :: result_ ! !     character(len=*), parameter :: TEMP_FILE_NAME = \"read_file_speed_tmp.txt\" !     type(varying_string) :: contents !     integer :: file_unit ! !     open(newunit = file_unit, file = TEMP_FILE_NAME, action = \"WRITE\", status = \"REPLACE\") !     call put(file_unit, TEST_TEXT) !     close(file_unit) ! !     result_ = assert_faster_than(do_alt_read, do_fast_read, 50) ! !     open(newunit = file_unit, file = TEMP_FILE_NAME) !     close(file_unit, status = \"DELETE\") ! contains !     subroutine do_fast_read !         use strff, only: read_file ! !         contents = read_file(TEMP_FILE_NAME) !     end subroutine ! !     subroutine do_alt_read !         contents = alt_read_file(TEMP_FILE_NAME) !     end subroutine ! end function ! ! function alt_read_file(filename) result(contents) !     use iso_fortran_env, only: IOSTAT_END !     use iso_varying_string, only: varying_string, get !     use strff, only: join, NEWLINE ! !     character(len=*), intent(in) :: filename !     type(varying_string) :: contents ! !     integer :: file_unit !     integer :: i !     type(varying_string), allocatable :: lines(:) !     integer :: num_lines !     integer :: stat !     type(varying_string) :: tmp ! !     open(newunit = file_unit, file = filename, action = \"READ\", status = \"OLD\") !     num_lines = 0 !     do !         call get(file_unit, tmp, iostat = stat) !         if (stat == IOSTAT_END) exit !         num_lines = num_lines + 1 !     end do !     rewind(file_unit) ! !     allocate(lines(num_lines)) !     do i = 1, num_lines !         call get(file_unit, lines(i)) !     end do !     close(file_unit) ! !     contents = join(lines, NEWLINE) ! end function end module","tags":"","loc":"sourcefile/read_file_test.f90.html","title":"read_file_test.f90 – miniFAVOR"},{"text":"Contents Modules indent_test Source Code indent_test.f90 Source Code module indent_test implicit none private public :: test_indent contains function test_indent () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( \"indents a single line\" , check_single_line ) individual_tests ( 2 ) = it ( \"indents multiple lines\" , check_indents_correctly ) tests = describe ( \"indent\" , individual_tests ) end function pure function check_single_line () result ( result_ ) use strff , only : indent use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"    Test\" , indent ( \"Test\" , 4 )) end function pure function check_indents_correctly () result ( result_ ) use strff , only : indent , NEWLINE use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: input = & \"First Line\" // NEWLINE & // \"Second Line\" // NEWLINE & // \"Third Line\" character ( len =* ), parameter :: expected = & \"    First Line\" // NEWLINE & // \"    Second Line\" // NEWLINE & // \"    Third Line\" result_ = assert_equals ( expected , indent ( input , 4 )) end function end module","tags":"","loc":"sourcefile/indent_test.f90.html","title":"indent_test.f90 – miniFAVOR"},{"text":"Contents Modules starts_with_test Source Code starts_with_test.f90 Source Code module starts_with_test implicit none private public :: test_starts_with contains function test_starts_with () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( & \"is true if the first string starts with the second\" , & check_true ) individual_tests ( 2 ) = it ( & \"is false if the first string doesn't start with the second\" , & check_false ) tests = describe ( \".startswith.\" , individual_tests ) end function pure function check_true () result ( result_ ) use strff , only : operator (. startswith .) use vegetables , only : result_t , assert_that type ( result_t ) :: result_ result_ = assert_that ( \"Hello, World!\" . startswith . \"Hello\" ) end function pure function check_false () result ( result_ ) use strff , only : operator (. startswith .) use vegetables , only : result_t , assert_not type ( result_t ) :: result_ result_ = assert_not ( \"Hello, World!\" . startswith . \"World!\" ) end function end module","tags":"","loc":"sourcefile/starts_with_test.f90.html","title":"starts_with_test.f90 – miniFAVOR"},{"text":"Contents Modules split_at_test Source Code split_at_test.f90 Source Code module split_at_test implicit none private public :: test_split_at contains function test_split_at () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 8 ) individual_tests ( 1 ) = it ( & \"returns the same string when split on a character it doesn't contain\" , & check_split_doesnt_contain ) individual_tests ( 2 ) = it ( & \"can split strings at something\" , check_split_at_something ) individual_tests ( 3 ) = it ( & \"doesn't include an empty string at the end\" , & check_no_empty_end ) individual_tests ( 4 ) = it ( & \"doesn't include an empty string at the beginning\" , & check_no_empty_begin ) individual_tests ( 5 ) = it ( & \"returns the same string when given no split characters\" , & check_no_split_characters ) individual_tests ( 6 ) = it ( & \"doesn't include an empty string between split characters\" , & check_no_empty_between ) individual_tests ( 7 ) = it ( & \"returns an empty array when given an empty string\" , & check_for_empty_string ) individual_tests ( 8 ) = it ( & \"returns an empty array when given a string that only contains split characters\" , & check_for_only_split_characters ) tests = describe ( \"split_at\" , individual_tests ) end function pure function check_split_doesnt_contain () result ( result_ ) use iso_varying_string , only : varying_string use strff , only : split_at use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ), allocatable :: strings (:) allocate ( strings ( 0 )) ! TODO: remove once bug in gfortran has been fixed strings = split_at ( \"Hello World\" , \",\" ) result_ = & assert_equals ( 1 , size ( strings )) & . and . assert_equals ( \"Hello World\" , strings ( 1 )) end function pure function check_split_at_something () result ( result_ ) use iso_varying_string , only : varying_string use strff , only : split_at use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ), allocatable :: strings (:) allocate ( strings ( 0 )) ! TODO: remove once bug in gfortran has been fixed strings = split_at ( \"Hello,World\" , \",\" ) result_ = & assert_equals ( 2 , size ( strings )) & . and . assert_equals ( \"Hello\" , strings ( 1 )) & . and . assert_equals ( \"World\" , strings ( 2 )) end function pure function check_no_empty_end () result ( result_ ) use iso_varying_string , only : varying_string use strff , only : split_at use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ), allocatable :: strings (:) allocate ( strings ( 0 )) ! TODO: remove once bug in gfortran has been fixed strings = split_at ( \"Hello,World,\" , \",\" ) result_ = & assert_equals ( 2 , size ( strings )) & . and . assert_equals ( \"Hello\" , strings ( 1 )) & . and . assert_equals ( \"World\" , strings ( 2 )) end function pure function check_no_empty_begin () result ( result_ ) use iso_varying_string , only : varying_string use strff , only : split_at use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ), allocatable :: strings (:) allocate ( strings ( 0 )) ! TODO: remove once bug in gfortran has been fixed strings = split_at ( \",Hello,World\" , \",\" ) result_ = & assert_equals ( 2 , size ( strings )) & . and . assert_equals ( \"Hello\" , strings ( 1 )) & . and . assert_equals ( \"World\" , strings ( 2 )) end function pure function check_no_split_characters () result ( result_ ) use iso_varying_string , only : varying_string use strff , only : split_at use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ), allocatable :: strings (:) allocate ( strings ( 0 )) ! TODO: remove once bug in gfortran has been fixed strings = split_at ( \"Hello,World\" , \"\" ) result_ = & assert_equals ( 1 , size ( strings )) & . and . assert_equals ( \"Hello,World\" , strings ( 1 )) end function pure function check_no_empty_between () result ( result_ ) use iso_varying_string , only : varying_string use strff , only : split_at use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ), allocatable :: strings (:) allocate ( strings ( 0 )) ! TODO: remove once bug in gfortran has been fixed strings = split_at ( \"Hello, World\" , \" ,\" ) result_ = & assert_equals ( 2 , size ( strings )) & . and . assert_equals ( \"Hello\" , strings ( 1 )) & . and . assert_equals ( \"World\" , strings ( 2 )) end function pure function check_for_empty_string () result ( result_ ) use iso_varying_string , only : varying_string use strff , only : split_at use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ), allocatable :: strings (:) allocate ( strings ( 0 )) ! TODO: remove once bug in gfortran has been fixed strings = split_at ( \"\" , \" ,\" ) result_ = assert_equals ( 0 , size ( strings )) end function pure function check_for_only_split_characters () result ( result_ ) use iso_varying_string , only : varying_string use strff , only : split_at use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ type ( varying_string ), allocatable :: strings (:) allocate ( strings ( 0 )) ! TODO: remove once bug in gfortran has been fixed strings = split_at ( \", \" , \" ,\" ) result_ = assert_equals ( 0 , size ( strings )) end function end module","tags":"","loc":"sourcefile/split_at_test.f90.html","title":"split_at_test.f90 – miniFAVOR"},{"text":"Contents Modules hanging_indent_test Source Code hanging_indent_test.f90 Source Code module hanging_indent_test implicit none private public :: test_hanging_indent contains function test_hanging_indent () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( \"does nothing to a single line\" , check_single_line ) individual_tests ( 2 ) = it ( \"indents all but the first line\" , check_indents_correctly ) tests = describe ( \"hanging_indent\" , individual_tests ) end function test_hanging_indent pure function check_single_line () result ( result_ ) use strff , only : hanging_indent use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ result_ = assert_equals ( \"Test\" , hanging_indent ( \"Test\" , 1 )) end function pure function check_indents_correctly () result ( result_ ) use strff , only : hanging_indent , NEWLINE use vegetables , only : result_t , assert_equals type ( result_t ) :: result_ character ( len =* ), parameter :: input = & \"First Line\" // NEWLINE & // \"Second Line\" // NEWLINE & // \"Third Line\" character ( len =* ), parameter :: expected = & \"First Line\" // NEWLINE & // \"    Second Line\" // NEWLINE & // \"    Third Line\" result_ = assert_equals ( expected , hanging_indent ( input , 4 )) end function end module","tags":"","loc":"sourcefile/hanging_indent_test.f90.html","title":"hanging_indent_test.f90 – miniFAVOR"},{"text":"Contents Modules strff Source Code strff.f90 Source Code module strff implicit none private public :: & operator (. includes .), & operator (. startswith .), & cover_empty_decimal , & first_character , & hanging_indent , & includes , & indent , & join , & last_character , & read_file , & read_file_lines , & remove_trailing_zeros , & split_at , & to_string , & without_first_character , & without_last_character , & NEWLINE interface operator (. includes .) module procedure includes_cc module procedure includes_cs module procedure includes_sc module procedure includes_ss end interface interface operator (. startswith .) module procedure starts_with_cc module procedure starts_with_cs module procedure starts_with_sc module procedure starts_with_ss end interface interface cover_empty_decimal module procedure cover_empty_decimal_c module procedure cover_empty_decimal_s end interface interface first_character module procedure first_character_c module procedure first_character_s end interface interface hanging_indent module procedure hanging_indent_c module procedure hanging_indent_s end interface interface includes module procedure includes_cc module procedure includes_cs module procedure includes_sc module procedure includes_ss end interface interface indent module procedure indent_c module procedure indent_s end interface interface join module procedure join_c module procedure join_s end interface interface last_character module procedure last_character_c module procedure last_character_s end interface interface read_file module procedure read_file_c module procedure read_file_s end interface interface read_file_lines module procedure read_file_lines_c module procedure read_file_lines_s end interface interface remove_trailing_zeros module procedure remove_trailing_zeros_c module procedure remove_trailing_zeros_s end interface interface split_at module procedure split_at_cc module procedure split_at_cs module procedure split_at_sc module procedure split_at_ss end interface interface to_string module procedure to_string_int8 module procedure to_string_int16 module procedure to_string_int32 module procedure to_string_int64 module procedure to_string_logical module procedure to_string_real32 module procedure to_string_real64 module procedure to_string_with_significant_digits_real32 module procedure to_string_with_significant_digits_real64 end interface interface without_first_character module procedure without_first_character_c module procedure without_first_character_s end interface interface without_last_character module procedure without_last_character_c module procedure without_last_character_s end interface character ( len =* ), parameter :: NEWLINE = NEW_LINE ( 'A' ) contains pure function cover_empty_decimal_c ( number ) result ( fixed ) use iso_varying_string , only : varying_string , assignment ( = ) character ( len =* ), intent ( in ) :: number type ( varying_string ) :: fixed if ( last_character ( number ) == \".\" ) then fixed = number // \"0\" else if ( first_character ( number ) == \".\" ) then fixed = \"0\" // number else fixed = number end if end function pure function cover_empty_decimal_s ( number ) result ( fixed ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: number type ( varying_string ) :: fixed fixed = cover_empty_decimal ( char ( number )) end function pure function first_character_c ( string ) result ( char_ ) character ( len =* ), intent ( in ) :: string character ( len = 1 ) :: char_ char_ = string ( 1 : 1 ) end function pure function first_character_s ( string ) result ( char_ ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: string character ( len = 1 ) :: char_ char_ = first_character ( char ( string )) end function pure function hanging_indent_c ( string , spaces ) result ( indented ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: spaces type ( varying_string ) :: indented indented = hanging_indent ( var_str ( string ), spaces ) end function pure function hanging_indent_s ( string , spaces ) result ( indented ) use iso_varying_string , only : varying_string type ( varying_string ), intent ( in ) :: string integer , intent ( in ) :: spaces type ( varying_string ) :: indented indented = join ( split_at ( string , NEWLINE ), NEWLINE // repeat ( \" \" , spaces )) end function pure function includes_cc ( within , search_for ) character ( len =* ), intent ( in ) :: within character ( len =* ), intent ( in ) :: search_for logical :: includes_cc includes_cc = index ( within , search_for ) > 0 end function pure function includes_cs ( within , search_for ) use iso_varying_string , only : varying_string , char character ( len =* ), intent ( in ) :: within type ( varying_string ), intent ( in ) :: search_for logical :: includes_cs includes_cs = within . includes . char ( search_for ) end function pure function includes_sc ( within , search_for ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: within character ( len =* ), intent ( in ) :: search_for logical :: includes_sc includes_sc = char ( within ). includes . search_for end function pure function includes_ss ( within , search_for ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: within type ( varying_string ), intent ( in ) :: search_for logical :: includes_ss includes_ss = char ( within ). includes . char ( search_for ) end function pure function indent_c ( string , spaces ) result ( indented ) use iso_varying_string , only : varying_string , var_str character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: spaces type ( varying_string ) :: indented indented = indent ( var_str ( string ), spaces ) end function pure function indent_s ( string , spaces ) result ( indented ) use iso_varying_string , only : varying_string , operator ( // ) type ( varying_string ), intent ( in ) :: string integer , intent ( in ) :: spaces type ( varying_string ) :: indented indented = repeat ( \" \" , spaces ) // hanging_indent ( string , spaces ) end function pure function join_c ( strings , separator ) result ( string ) use iso_varying_string , only : varying_string , var_str type ( varying_string ), intent ( in ) :: strings (:) character ( len =* ), intent ( in ) :: separator type ( varying_string ) :: string string = join ( strings , var_str ( separator )) end function pure recursive function join_s ( strings , separator ) result ( string ) use iso_varying_string , only : varying_string , assignment ( = ), operator ( // ) type ( varying_string ), intent ( in ) :: strings (:) type ( varying_string ), intent ( in ) :: separator type ( varying_string ) :: string integer :: num_strings num_strings = size ( strings ) if ( num_strings == 1 ) then string = strings ( 1 ) else if ( num_strings == 0 ) then string = \"\" else string = & strings ( 1 ) & // separator & // join ( strings ( 2 :), separator ) end if end function pure function last_character_c ( string ) result ( char_ ) character ( len =* ), intent ( in ) :: string character ( len = 1 ) :: char_ integer :: length length = len ( string ) char_ = string ( length : length ) end function pure function last_character_s ( string ) result ( char_ ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: string character ( len = 1 ) :: char_ char_ = last_character ( char ( string )) end function pure recursive function remove_trailing_zeros_c ( number ) result ( trimmed ) use iso_varying_string , only : varying_string , assignment ( = ) character ( len =* ), intent ( in ) :: number type ( varying_string ) :: trimmed if ( last_character ( number ) == \"0\" ) then trimmed = remove_trailing_zeros ( without_last_character ( number )) else trimmed = number end if end function pure recursive function remove_trailing_zeros_s ( number ) result ( trimmed ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: number type ( varying_string ) :: trimmed trimmed = remove_trailing_zeros ( char ( number )) end function function read_file_c ( filename ) result ( contents ) use iso_fortran_env , only : IOSTAT_END use iso_varying_string , only : varying_string , operator ( // ), get character ( len =* ), intent ( in ) :: filename type ( varying_string ) :: contents integer :: file_unit integer :: stat type ( varying_string ) :: tmp open ( newunit = file_unit , file = filename , action = \"READ\" , status = \"OLD\" ) call get ( file_unit , contents , iostat = stat ) if ( stat == IOSTAT_END ) return do call get ( file_unit , tmp , iostat = stat ) if ( stat == iostat_end ) exit contents = contents // NEWLINE // tmp end do close ( file_unit ) end function function read_file_s ( filename ) result ( contents ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: filename type ( varying_string ) :: contents contents = read_file ( char ( filename )) end function function read_file_lines_c ( filename ) result ( lines ) use iso_fortran_env , only : IOSTAT_END use iso_varying_string , only : varying_string , get character ( len =* ), intent ( in ) :: filename type ( varying_string ), allocatable :: lines (:) integer :: file_unit integer :: i integer :: num_lines integer :: stat type ( varying_string ) :: tmp open ( newunit = file_unit , file = filename , action = \"READ\" , status = \"OLD\" ) num_lines = 0 do call get ( file_unit , tmp , iostat = stat ) if ( stat == IOSTAT_END ) exit num_lines = num_lines + 1 end do rewind ( file_unit ) allocate ( lines ( num_lines )) do i = 1 , num_lines call get ( file_unit , lines ( i )) end do close ( file_unit ) end function function read_file_lines_s ( filename ) result ( lines ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: filename type ( varying_string ), allocatable :: lines (:) lines = read_file_lines ( char ( filename )) end function pure recursive function split_at_cc ( & string , split_characters ) result ( strings ) use iso_varying_string , only : varying_string , assignment ( = ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: split_characters type ( varying_string ), allocatable :: strings (:) if ( len ( split_characters ) > 0 ) then if ( len ( string ) > 0 ) then if ( split_characters . includes . first_character ( string )) then allocate ( strings , source = split_at ( & without_first_character ( string ), & split_characters )) else if ( split_characters . includes . last_character ( string )) then allocate ( strings , source = split_at ( & without_last_character ( string ), & split_characters )) else allocate ( strings , source = & do_split ( string , split_characters )) end if else allocate ( strings ( 0 )) end if else allocate ( strings ( 1 )) strings ( 1 ) = string end if contains pure recursive function do_split ( string_ , split_characters_ ) result ( strings_ ) use iso_varying_string , only : varying_string , assignment ( = ) character ( len =* ), intent ( in ) :: string_ character ( len =* ), intent ( in ) :: split_characters_ type ( varying_string ), allocatable :: strings_ (:) integer :: i type ( varying_string ), allocatable :: rest (:) integer :: string_length_ type ( varying_string ) :: this_string string_length_ = len ( string_ ) do i = 2 , string_length_ if ( split_characters_ . includes . string_ ( i : i )) exit end do if ( i < string_length_ ) then this_string = string_ ( 1 : i - 1 ) allocate ( rest , source = & split_at ( string_ ( i + 1 :), split_characters_ )) allocate ( strings_ ( size ( rest ) + 1 )) strings_ ( 1 ) = this_string strings_ ( 2 :) = rest (:) else allocate ( strings_ ( 1 )) strings_ ( 1 ) = string_ end if end function end function pure function split_at_cs ( string , split_characters ) result ( strings ) use iso_varying_string , only : varying_string , char character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: split_characters type ( varying_string ), allocatable :: strings (:) allocate ( strings , source = split_at ( string , char ( split_characters ))) end function pure recursive function split_at_sc ( string , split_characters ) result ( strings ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: split_characters type ( varying_string ), allocatable :: strings (:) allocate ( strings , source = split_at ( char ( string ), split_characters )) end function pure function split_at_ss ( string , split_characters ) result ( strings ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: split_characters type ( varying_string ), allocatable :: strings (:) allocate ( strings , source = split_at ( char ( string ), char ( split_characters ))) end function pure function starts_with_cc ( string , substring ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: starts_with_cc starts_with_cc = index ( string , substring ) == 1 end function pure function starts_with_cs ( string , substring ) use iso_varying_string , only : varying_string , char character ( len =* ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: substring logical :: starts_with_cs starts_with_cs = string . startswith . char ( substring ) end function pure function starts_with_sc ( string , substring ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: starts_with_sc starts_with_sc = char ( string ). startswith . substring end function pure function starts_with_ss ( string , substring ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: string type ( varying_string ), intent ( in ) :: substring logical :: starts_with_ss starts_with_ss = char ( string ). startswith . char ( substring ) end function pure function to_string_int8 ( number ) result ( string ) use iso_fortran_env , only : INT8 use iso_varying_string , only : varying_string , assignment ( = ) integer ( INT8 ), intent ( in ) :: number type ( varying_string ) :: string character ( len = 4 ) :: temp write ( temp , '(I0)' ) number string = trim ( temp ) end function pure function to_string_int16 ( number ) result ( string ) use iso_fortran_env , only : INT16 use iso_varying_string , only : varying_string , assignment ( = ) integer ( INT16 ), intent ( in ) :: number type ( varying_string ) :: string character ( len = 6 ) :: temp write ( temp , '(I0)' ) number string = trim ( temp ) end function pure function to_string_int32 ( number ) result ( string ) use iso_fortran_env , only : INT32 use iso_varying_string , only : varying_string , assignment ( = ) integer ( INT32 ), intent ( in ) :: number type ( varying_string ) :: string character ( len = 11 ) :: temp write ( temp , '(I0)' ) number string = trim ( temp ) end function pure function to_string_int64 ( number ) result ( string ) use iso_fortran_env , only : INT64 use iso_varying_string , only : varying_string , assignment ( = ) integer ( INT64 ), intent ( in ) :: number type ( varying_string ) :: string character ( len = 20 ) :: temp write ( temp , '(I0)' ) number string = trim ( temp ) end function pure function to_string_logical ( logical_ ) result ( string ) use iso_varying_string , only : varying_string , assignment ( = ) logical , intent ( in ) :: logical_ type ( varying_string ) :: string if ( logical_ ) then string = \"TRUE\" else string = \"FALSE\" end if end function pure function to_string_real32 ( number ) result ( string ) use iso_fortran_env , only : REAL32 use iso_varying_string , only : varying_string real ( REAL32 ), intent ( in ) :: number type ( varying_string ) :: string string = to_string ( number , 9 ) end function pure function to_string_real64 ( number ) result ( string ) use iso_fortran_env , only : REAL64 use iso_varying_string , only : varying_string real ( REAL64 ), intent ( in ) :: number type ( varying_string ) :: string string = to_string ( number , 17 ) end function ! TODO: implement to_string_real128 once conditions described below !       NOTE: the default precision will be 36 pure function to_string_with_significant_digits_real32 ( & number , significant_digits ) result ( string_ ) use iso_fortran_env , only : REAL32 use iso_varying_string , only : & varying_string , assignment ( = ), operator ( // ), len real ( REAL32 ), intent ( in ) :: number integer , intent ( in ) :: significant_digits type ( varying_string ) :: string_ integer , parameter :: C_LEN = 18 real ( REAL32 ), parameter :: MACHINE_TINY = tiny ( real ( 0.0 , kind = REAL32 )) real ( REAL32 ) :: abs_num character ( len = C_LEN ) :: exponent_part character ( len = C_LEN ) :: floating_part character ( len = 7 ) :: format_string type ( varying_string ) :: intermediate type ( varying_string ) :: intermediate_basic type ( varying_string ) :: intermediate_scientific integer :: scale_ abs_num = abs ( number ) if ( abs_num <= MACHINE_TINY ) then string_ = \"0.0\" return end if scale_ = floor ( log10 ( abs_num )) if ( scale_ <= - 2 ) then write ( format_string , '(A,I0,A)' ) & \"(f0.\" , significant_digits - 1 , \")\" write ( floating_part , format_string ) & abs_num * 1.0D1 ** ( - scale_ ) write ( exponent_part , '(A,I0)' ) 'e' , scale_ intermediate = & cover_empty_decimal ( & remove_trailing_zeros ( trim ( floating_part ))) & // trim ( exponent_part ) else write ( format_string , '(A,I0,A)' ) & \"(f0.\" , significant_digits - 1 , \")\" write ( floating_part , format_string ) abs_num / 1.0D1 ** scale_ write ( exponent_part , '(A,I0)' ) 'e' , scale_ intermediate_scientific = & cover_empty_decimal ( & remove_trailing_zeros ( trim ( floating_part ))) & // trim ( exponent_part ) if ( scale_ < significant_digits ) then write ( format_string , '(A,I0,A)' ) & \"(f0.\" , significant_digits - scale_ - 1 , \")\" write ( floating_part , format_string ) abs_num intermediate_basic = cover_empty_decimal ( & remove_trailing_zeros ( trim ( floating_part ))) if ( len ( intermediate_scientific ) < len ( intermediate_basic )) then intermediate = intermediate_scientific else intermediate = intermediate_basic end if else intermediate = intermediate_scientific end if end if if ( number < 0.0D0 ) then string_ = \"-\" // intermediate else string_ = intermediate end if end function pure function to_string_with_significant_digits_real64 ( & number , significant_digits ) result ( string_ ) use iso_fortran_env , only : REAL64 use iso_varying_string , only : & varying_string , assignment ( = ), operator ( // ), len real ( REAL64 ), intent ( in ) :: number integer , intent ( in ) :: significant_digits type ( varying_string ) :: string_ integer , parameter :: C_LEN = 34 real ( REAL64 ), parameter :: MACHINE_TINY = tiny ( real ( 0.0 , kind = REAL64 )) real ( REAL64 ) :: abs_num character ( len = C_LEN ) :: exponent_part character ( len = C_LEN ) :: floating_part character ( len = 7 ) :: format_string type ( varying_string ) :: intermediate type ( varying_string ) :: intermediate_basic type ( varying_string ) :: intermediate_scientific integer :: scale_ abs_num = abs ( number ) if ( abs_num <= MACHINE_TINY ) then string_ = \"0.0\" return end if scale_ = floor ( log10 ( abs_num )) if ( scale_ <= - 2 ) then write ( format_string , '(A,I0,A)' ) & \"(f0.\" , significant_digits - 1 , \")\" write ( floating_part , format_string ) & abs_num * 1.0D1 ** ( - scale_ ) write ( exponent_part , '(A,I0)' ) 'e' , scale_ intermediate = & cover_empty_decimal ( & remove_trailing_zeros ( trim ( floating_part ))) & // trim ( exponent_part ) else write ( format_string , '(A,I0,A)' ) & \"(f0.\" , significant_digits - 1 , \")\" write ( floating_part , format_string ) abs_num / 1.0D1 ** scale_ write ( exponent_part , '(A,I0)' ) 'e' , scale_ intermediate_scientific = & cover_empty_decimal ( & remove_trailing_zeros ( trim ( floating_part ))) & // trim ( exponent_part ) if ( scale_ < significant_digits ) then write ( format_string , '(A,I0,A)' ) & \"(f0.\" , significant_digits - scale_ - 1 , \")\" write ( floating_part , format_string ) abs_num intermediate_basic = cover_empty_decimal ( & remove_trailing_zeros ( trim ( floating_part ))) if ( len ( intermediate_scientific ) < len ( intermediate_basic )) then intermediate = intermediate_scientific else intermediate = intermediate_basic end if else intermediate = intermediate_scientific end if end if if ( number < 0.0D0 ) then string_ = \"-\" // intermediate else string_ = intermediate end if end function ! TODO: implement to_string_with_significant_digits_real128 !       once REAL128 is sufficiently portable, or the ifdef !       to conditionally include it is sufficiently portable. !       NOTE: C_LEN will be 72 pure function without_first_character_c ( string ) result ( trimmed ) use iso_varying_string , only : varying_string , assignment ( = ) character ( len =* ), intent ( in ) :: string type ( varying_string ) :: trimmed trimmed = string ( 2 :) end function pure function without_first_character_s ( string ) result ( trimmed ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: trimmed trimmed = without_first_character ( char ( string )) end function pure function without_last_character_c ( string ) result ( trimmed ) use iso_varying_string , only : varying_string , assignment ( = ) character ( len =* ), intent ( in ) :: string type ( varying_string ) :: trimmed trimmed = string ( 1 : len ( string ) - 1 ) end function pure function without_last_character_s ( string ) result ( trimmed ) use iso_varying_string , only : varying_string , char type ( varying_string ), intent ( in ) :: string type ( varying_string ) :: trimmed trimmed = without_last_character ( char ( string )) end function end module","tags":"","loc":"sourcefile/strff.f90.html","title":"strff.f90 – miniFAVOR"},{"text":"type, public, extends( object ) :: random_samples_t Contents Variables cu_local_ cu_sig_local_ ni_local_ phi_ Type-Bound Procedures cu_local cu_sig_local define mark_as_defined ni_local phi user_defined write(formatted) write_formatted Components Type Visibility Attributes Name Initial real, private :: cu_local_ real, private :: cu_sig_local_ real, private :: ni_local_ real, private :: phi_ Type-Bound Procedures procedure, public :: cu_local interface private pure module function cu_local(self) result(self_cu_local) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real procedure, public :: cu_sig_local interface private pure module function cu_sig_local(self) result(self_cu_sig_local) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real procedure, public :: define interface private module subroutine define(self) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(out) :: self procedure, public :: mark_as_defined interface private pure module subroutine mark_as_defined(this) Implementation → Mark the object as user-defined Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this procedure, public :: ni_local interface private pure module function ni_local(self) result(self_ni_local) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real procedure, public :: phi interface private pure module function phi(self) result(self_phi) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real procedure, public :: user_defined interface private pure module function user_defined(this) result(is_defined) Implementation → Return a boolean result indicating whether this object has been initialized since its declaration Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical generic, public :: write(formatted) => write_formatted subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public :: write_formatted interface private module subroutine write_formatted(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"type/random_samples_t.html","title":"random_samples_t – miniFAVOR "},{"text":"type, private, extends( input_t ) :: invalid_input_t Contents Variables string Components Type Visibility Attributes Name Initial type( varying_string ), public :: string","tags":"","loc":"type/invalid_input_t~2.html","title":"invalid_input_t – miniFAVOR "},{"text":"type, private, extends( input_t ) :: number_input_t Contents Variables string value_ Components Type Visibility Attributes Name Initial type( varying_string ), public :: string double precision, public :: value_","tags":"","loc":"type/number_input_t~2.html","title":"number_input_t – miniFAVOR "},{"text":"type, private, extends( input_t ) :: invalid_input_t Contents Variables string Components Type Visibility Attributes Name Initial type( varying_string ), public :: string","tags":"","loc":"type/invalid_input_t.html","title":"invalid_input_t – miniFAVOR "},{"text":"type, private, extends( input_t ) :: number_input_t Contents Variables string value_ Components Type Visibility Attributes Name Initial type( varying_string ), public :: string integer, public :: value_","tags":"","loc":"type/number_input_t.html","title":"number_input_t – miniFAVOR "},{"text":"type, public, extends( parsed_value_t ) :: intermediate_parsed_string_t Contents Variables left_to_parse parsed_so_far Components Type Visibility Attributes Name Initial type( varying_string ), public :: left_to_parse type( varying_string ), public :: parsed_so_far","tags":"","loc":"type/intermediate_parsed_string_t.html","title":"intermediate_parsed_string_t – miniFAVOR "},{"text":"type, public, extends( parsed_value_t ) :: intermediate_repeat_t Contents Variables parsed_so_far remaining Components Type Visibility Attributes Name Initial type( parsed_items_t ), public :: parsed_so_far integer, public :: remaining","tags":"","loc":"type/intermediate_repeat_t.html","title":"intermediate_repeat_t – miniFAVOR "},{"text":"type, public :: message_t Contents Variables expected found position Type-Bound Procedures to_string Components Type Visibility Attributes Name Initial type( varying_string ), public, allocatable :: expected (:) type( varying_string ), public :: found type( position_t ), public :: position Type-Bound Procedures procedure, public :: to_string => message_to_string private pure function message_to_string (self) result(string) Arguments Type Intent Optional Attributes Name class( message_t ), intent(in) :: self Return Value type( varying_string )","tags":"","loc":"type/message_t.html","title":"message_t – miniFAVOR "},{"text":"type, public :: parse_result_t Contents Variables message ok parsed Components Type Visibility Attributes Name Initial type( varying_string ), public :: message logical, public :: ok class( parsed_value_t ), public, allocatable :: parsed","tags":"","loc":"type/parse_result_t.html","title":"parse_result_t – miniFAVOR "},{"text":"type, public, extends( parsed_value_t ) :: parsed_character_t Contents Variables value_ Components Type Visibility Attributes Name Initial character(len=1), public :: value_","tags":"","loc":"type/parsed_character_t.html","title":"parsed_character_t – miniFAVOR "},{"text":"type, public, extends( parsed_value_t ) :: parsed_integer_t Contents Variables value_ Components Type Visibility Attributes Name Initial integer, public :: value_","tags":"","loc":"type/parsed_integer_t.html","title":"parsed_integer_t – miniFAVOR "},{"text":"type, public :: parsed_item_t Contents Variables item Components Type Visibility Attributes Name Initial class( parsed_value_t ), public, allocatable :: item","tags":"","loc":"type/parsed_item_t.html","title":"parsed_item_t – miniFAVOR "},{"text":"type, public, extends( parsed_value_t ) :: parsed_items_t Contents Variables items Components Type Visibility Attributes Name Initial type( parsed_item_t ), public, allocatable :: items (:)","tags":"","loc":"type/parsed_items_t.html","title":"parsed_items_t – miniFAVOR "},{"text":"type, public, extends( parsed_value_t ) :: parsed_nothing_t Contents None","tags":"","loc":"type/parsed_nothing_t.html","title":"parsed_nothing_t – miniFAVOR "},{"text":"type, public, extends( parsed_value_t ) :: parsed_rational_t Contents Variables value_ Components Type Visibility Attributes Name Initial double precision, public :: value_","tags":"","loc":"type/parsed_rational_t.html","title":"parsed_rational_t – miniFAVOR "},{"text":"type, public, extends( parsed_value_t ) :: parsed_string_t Contents Variables value_ Components Type Visibility Attributes Name Initial type( varying_string ), public :: value_","tags":"","loc":"type/parsed_string_t.html","title":"parsed_string_t – miniFAVOR "},{"text":"type, public, abstract :: parsed_value_t Contents None","tags":"","loc":"type/parsed_value_t.html","title":"parsed_value_t – miniFAVOR "},{"text":"type, public :: parser_output_t Contents Variables empty message ok parsed position remaining Components Type Visibility Attributes Name Initial logical, public :: empty type( message_t ), public :: message logical, public :: ok class( parsed_value_t ), public, allocatable :: parsed type( position_t ), public :: position type( varying_string ), public :: remaining","tags":"","loc":"type/parser_output_t.html","title":"parser_output_t – miniFAVOR "},{"text":"type, public :: position_t Contents Variables column line Components Type Visibility Attributes Name Initial integer, public :: column integer, public :: line","tags":"","loc":"type/position_t.html","title":"position_t – miniFAVOR "},{"text":"type, public :: state_t Contents Variables input position Components Type Visibility Attributes Name Initial type( varying_string ), public :: input type( position_t ), public :: position","tags":"","loc":"type/state_t.html","title":"state_t – miniFAVOR "},{"text":"type, public, extends( generator_t ) :: ascii_character_generator_t Contents Type-Bound Procedures generate shrink Type-Bound Procedures procedure, public :: generate => generate_character private function generate_character (self) result(generated_value) Arguments Type Intent Optional Attributes Name class( ascii_character_generator_t ), intent(in) :: self Return Value type( generated_t ) procedure, public, nopass :: shrink => shrink_character private pure function shrink_character (input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t )","tags":"","loc":"type/ascii_character_generator_t.html","title":"ascii_character_generator_t – miniFAVOR "},{"text":"type, public, extends( generator_t ) :: ascii_string_and_integer_generator_t Contents Type-Bound Procedures generate shrink Type-Bound Procedures procedure, public :: generate => generate_string_and_integer private function generate_string_and_integer (self) result(generated_value) Arguments Type Intent Optional Attributes Name class( ascii_string_and_integer_generator_t ), intent(in) :: self Return Value type( generated_t ) procedure, public, nopass :: shrink => shrink_string_and_integer private pure function shrink_string_and_integer (input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t )","tags":"","loc":"type/ascii_string_and_integer_generator_t.html","title":"ascii_string_and_integer_generator_t – miniFAVOR "},{"text":"type, public, extends( generator_t ) :: ascii_string_pair_generator_t Contents Type-Bound Procedures generate shrink Type-Bound Procedures procedure, public :: generate => generate_string_pair private function generate_string_pair (self) result(generated_value) Arguments Type Intent Optional Attributes Name class( ascii_string_pair_generator_t ), intent(in) :: self Return Value type( generated_t ) procedure, public, nopass :: shrink => shrink_string_pair private pure function shrink_string_pair (input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t )","tags":"","loc":"type/ascii_string_pair_generator_t.html","title":"ascii_string_pair_generator_t – miniFAVOR "},{"text":"type, public, extends( input_t ) :: character_input_t Contents Variables value_ Components Type Visibility Attributes Name Initial character(len=1), public :: value_","tags":"","loc":"type/character_input_t.html","title":"character_input_t – miniFAVOR "},{"text":"type, public, extends( input_t ) :: string_and_integer_input_t Contents Variables integer_ string Components Type Visibility Attributes Name Initial integer, public :: integer_ type( varying_string ), public :: string","tags":"","loc":"type/string_and_integer_input_t.html","title":"string_and_integer_input_t – miniFAVOR "},{"text":"type, public, extends( input_t ) :: string_pair_input_t Contents Variables first second Components Type Visibility Attributes Name Initial type( varying_string ), public :: first type( varying_string ), public :: second","tags":"","loc":"type/string_pair_input_t.html","title":"string_pair_input_t – miniFAVOR "},{"text":"type, public :: varying_string Contents Variables characters Components Type Visibility Attributes Name Initial character(len=1), private, allocatable :: characters (:)","tags":"","loc":"type/varying_string.html","title":"varying_string – miniFAVOR "},{"text":"type, private :: test_info_t Contents Variables function_names module_name Components Type Visibility Attributes Name Initial type( varying_string ), public, allocatable :: function_names (:) type( varying_string ), public :: module_name","tags":"","loc":"type/test_info_t.html","title":"test_info_t – miniFAVOR "},{"text":"type, private, extends( generator_t ) :: double_precision_generator_t Contents Type-Bound Procedures generate shrink Type-Bound Procedures procedure, public :: generate private function generate (self) result(random_double) Arguments Type Intent Optional Attributes Name class( double_precision_generator_t ), intent(in) :: self Return Value type( generated_t ) procedure, public, nopass :: shrink private pure function shrink (input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t )","tags":"","loc":"type/double_precision_generator_t.html","title":"double_precision_generator_t – miniFAVOR "},{"text":"type, private, extends( input_t ) :: filter_item_result_input_t Contents Variables input Components Type Visibility Attributes Name Initial type( filter_item_result_t ), public :: input","tags":"","loc":"type/filter_item_result_input_t.html","title":"filter_item_result_input_t – miniFAVOR "},{"text":"type, public, extends( input_t ) :: test_item_input_t Contents Variables input Components Type Visibility Attributes Name Initial type( test_item_t ), public :: input","tags":"","loc":"type/test_item_input_t.html","title":"test_item_input_t – miniFAVOR "},{"text":"type, public, extends( input_t ) :: test_result_item_input_t Contents Variables input Components Type Visibility Attributes Name Initial type( test_result_item_t ), public :: input","tags":"","loc":"type/test_result_item_input_t.html","title":"test_result_item_input_t – miniFAVOR "},{"text":"type, public, extends( generator_t ) :: ascii_string_generator_t Contents Type-Bound Procedures generate shrink Type-Bound Procedures procedure, public :: generate => generate_ascii_string private function generate_ascii_string (self) result(generated_value) Arguments Type Intent Optional Attributes Name class( ascii_string_generator_t ), intent(in) :: self Return Value type( generated_t ) procedure, public, nopass :: shrink => shrink_ascii_string private pure function shrink_ascii_string (input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t )","tags":"","loc":"type/ascii_string_generator_t.html","title":"ascii_string_generator_t – miniFAVOR "},{"text":"type, public, extends( input_t ) :: double_precision_input_t Contents Variables value_ Components Type Visibility Attributes Name Initial double precision, public :: value_","tags":"","loc":"type/double_precision_input_t.html","title":"double_precision_input_t – miniFAVOR "},{"text":"type, public :: example_t Contents Variables input Components Type Visibility Attributes Name Initial class( input_t ), private, allocatable :: input","tags":"","loc":"type/example_t.html","title":"example_t – miniFAVOR "},{"text":"type, public :: filter_item_result_t Contents Variables matched test Components Type Visibility Attributes Name Initial logical, public :: matched type( test_item_t ), public :: test","tags":"","loc":"type/filter_item_result_t.html","title":"filter_item_result_t – miniFAVOR "},{"text":"type, public :: generated_t Contents Variables input Components Type Visibility Attributes Name Initial class( input_t ), private, allocatable :: input","tags":"","loc":"type/generated_t.html","title":"generated_t – miniFAVOR "},{"text":"type, public, abstract :: generator_t Contents Type-Bound Procedures generate shrink Type-Bound Procedures procedure( generate_i ), public, deferred :: generate function generate_i(self) result(generated_value) Prototype Arguments Type Intent Optional Attributes Name class( generator_t ), intent(in) :: self Return Value type( generated_t ) procedure( shrink_i ), public, deferred, nopass :: shrink function shrink_i(input) result(shrunk) Prototype Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t )","tags":"","loc":"type/generator_t.html","title":"generator_t – miniFAVOR "},{"text":"type, public, abstract :: input_t Contents None","tags":"","loc":"type/input_t.html","title":"input_t – miniFAVOR "},{"text":"type, public, extends( test_case_t ) :: input_test_case_t Contents Variables test Type-Bound Procedures description filter num_cases run_with_input run_without_input Components Type Visibility Attributes Name Initial procedure( input_test_i ), private, nopass, pointer :: test Type-Bound Procedures procedure, public :: description => test_case_description private pure function test_case_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value type( varying_string ) procedure, public :: filter => test_case_filter private pure function test_case_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) procedure, public :: num_cases => test_case_num_cases private pure function test_case_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value integer procedure, private :: run_with_input => input_test_case_run_with_input private function input_test_case_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( input_test_case_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) procedure, private :: run_without_input => input_test_case_run_without_input private function input_test_case_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( input_test_case_t ), intent(in) :: self Return Value type( test_result_item_t )","tags":"","loc":"type/input_test_case_t.html","title":"input_test_case_t – miniFAVOR "},{"text":"type, public, extends( generator_t ) :: integer_generator_t Contents Type-Bound Procedures generate shrink Type-Bound Procedures procedure, public :: generate => generate_integer private function generate_integer (self) result(generated_value) Arguments Type Intent Optional Attributes Name class( integer_generator_t ), intent(in) :: self Return Value type( generated_t ) procedure, public, nopass :: shrink => shrink_integer private pure function shrink_integer (input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t )","tags":"","loc":"type/integer_generator_t.html","title":"integer_generator_t – miniFAVOR "},{"text":"type, public, extends( input_t ) :: integer_input_t Contents Variables value_ Components Type Visibility Attributes Name Initial integer, public :: value_","tags":"","loc":"type/integer_input_t.html","title":"integer_input_t – miniFAVOR "},{"text":"type, public :: result_t Contents Variables results Type-Bound Procedures failure_description num_asserts num_failing_asserts operator(.and.) passed verbose_description combine_results Components Type Visibility Attributes Name Initial type( individual_result_t ), private, allocatable :: results (:) Type-Bound Procedures procedure, public :: failure_description => result_failure_description private pure function result_failure_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) procedure, public :: num_asserts => result_num_asserts private pure function result_num_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self Return Value integer procedure, public :: num_failing_asserts => result_num_failing_asserts private pure function result_num_failing_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self Return Value integer generic, public :: operator(.and.) => combine_results private pure function combine_results (lhs, rhs) result(combined) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: lhs type( result_t ), intent(in) :: rhs Return Value type( result_t ) procedure, public :: passed => result_passed private pure function result_passed (self) result(passed) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self Return Value logical procedure, public :: verbose_description => result_verbose_description private pure function result_verbose_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) procedure, private :: combine_results private pure function combine_results (lhs, rhs) result(combined) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: lhs type( result_t ), intent(in) :: rhs Return Value type( result_t )","tags":"","loc":"type/result_t.html","title":"result_t – miniFAVOR "},{"text":"type, public :: shrink_result_t Contents Variables input simplest Components Type Visibility Attributes Name Initial class( input_t ), private, allocatable :: input logical, private :: simplest","tags":"","loc":"type/shrink_result_t.html","title":"shrink_result_t – miniFAVOR "},{"text":"type, public, extends( test_case_t ) :: simple_test_case_t Contents Variables test Type-Bound Procedures description filter num_cases run_with_input run_without_input Components Type Visibility Attributes Name Initial procedure( simple_test_i ), private, nopass, pointer :: test Type-Bound Procedures procedure, public :: description => test_case_description private pure function test_case_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value type( varying_string ) procedure, public :: filter => test_case_filter private pure function test_case_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) procedure, public :: num_cases => test_case_num_cases private pure function test_case_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value integer procedure, private :: run_with_input => simple_test_case_run_with_input private function simple_test_case_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( simple_test_case_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) procedure, private :: run_without_input => simple_test_case_run_without_input private function simple_test_case_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( simple_test_case_t ), intent(in) :: self Return Value type( test_result_item_t )","tags":"","loc":"type/simple_test_case_t.html","title":"simple_test_case_t – miniFAVOR "},{"text":"type, public, extends( test_collection_t ) :: simple_test_collection_t Contents Type-Bound Procedures description filter num_cases run_with_input run_without_input Type-Bound Procedures procedure, public :: description => test_collection_description private pure recursive function test_collection_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self Return Value type( varying_string ) procedure, public :: filter => test_collection_filter private pure recursive function test_collection_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) procedure, public :: num_cases => test_collection_num_cases private pure recursive function test_collection_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self Return Value integer procedure, private :: run_with_input => simple_test_collection_run_with_input private recursive function simple_test_collection_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( simple_test_collection_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) procedure, private :: run_without_input => simple_test_collection_run_without_input private recursive function simple_test_collection_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( simple_test_collection_t ), intent(in) :: self Return Value type( test_result_item_t )","tags":"","loc":"type/simple_test_collection_t.html","title":"simple_test_collection_t – miniFAVOR "},{"text":"type, public, extends( input_t ) :: string_input_t Contents Variables value_ Components Type Visibility Attributes Name Initial type( varying_string ), public :: value_","tags":"","loc":"type/string_input_t.html","title":"string_input_t – miniFAVOR "},{"text":"type, public, extends( test_result_t ) :: test_case_result_t Contents Variables result_ Type-Bound Procedures failure_description num_asserts num_cases num_failing_asserts num_failing_cases passed verbose_description Components Type Visibility Attributes Name Initial type( result_t ), private :: result_ Type-Bound Procedures procedure, public :: failure_description => test_case_result_failure_description private pure function test_case_result_failure_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) procedure, public :: num_asserts => test_case_result_num_asserts private pure function test_case_result_num_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value integer procedure, public :: num_cases => test_case_result_num_cases private pure function test_case_result_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value integer procedure, public :: num_failing_asserts => test_case_result_num_failing_asserts private pure function test_case_result_num_failing_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value integer procedure, public :: num_failing_cases => test_case_result_num_failing_cases private pure function test_case_result_num_failing_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value integer procedure, public :: passed => test_case_result_passed private pure function test_case_result_passed (self) result(passed) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value logical procedure, public :: verbose_description => test_case_result_verbose_description private pure function test_case_result_verbose_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string )","tags":"","loc":"type/test_case_result_t.html","title":"test_case_result_t – miniFAVOR "},{"text":"type, public, abstract, extends( test_t ) :: test_case_t Contents Type-Bound Procedures description filter num_cases Type-Bound Procedures procedure, public :: description => test_case_description private pure function test_case_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value type( varying_string ) procedure, public :: filter => test_case_filter private pure function test_case_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) procedure, public :: num_cases => test_case_num_cases private pure function test_case_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value integer","tags":"","loc":"type/test_case_t.html","title":"test_case_t – miniFAVOR "},{"text":"type, public, extends( test_case_t ) :: test_case_with_examples_t Contents Variables examples test Type-Bound Procedures description filter num_cases run_with_input run_without_input Components Type Visibility Attributes Name Initial type( example_t ), private, allocatable :: examples (:) procedure( input_test_i ), private, nopass, pointer :: test Type-Bound Procedures procedure, public :: description => test_case_description private pure function test_case_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value type( varying_string ) procedure, public :: filter => test_case_filter private pure function test_case_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) procedure, public :: num_cases => test_case_num_cases private pure function test_case_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value integer procedure, private :: run_with_input => test_case_with_examples_run_with_input private function test_case_with_examples_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_case_with_examples_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) procedure, private :: run_without_input => test_case_with_examples_run_without_input private function test_case_with_examples_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( test_case_with_examples_t ), intent(in) :: self Return Value type( test_result_item_t )","tags":"","loc":"type/test_case_with_examples_t.html","title":"test_case_with_examples_t – miniFAVOR "},{"text":"type, public, extends( test_case_t ) :: test_case_with_generator_t Contents Variables generator test Type-Bound Procedures description filter num_cases run_with_input run_without_input Components Type Visibility Attributes Name Initial class( generator_t ), private, allocatable :: generator procedure( input_test_i ), private, nopass, pointer :: test Type-Bound Procedures procedure, public :: description => test_case_description private pure function test_case_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value type( varying_string ) procedure, public :: filter => test_case_filter private pure function test_case_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) procedure, public :: num_cases => test_case_num_cases private pure function test_case_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value integer procedure, private :: run_with_input => test_case_with_generator_run_with_input private function test_case_with_generator_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_case_with_generator_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) procedure, private :: run_without_input => test_case_with_generator_run_without_input private function test_case_with_generator_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( test_case_with_generator_t ), intent(in) :: self Return Value type( test_result_item_t )","tags":"","loc":"type/test_case_with_generator_t.html","title":"test_case_with_generator_t – miniFAVOR "},{"text":"type, public, extends( test_result_t ) :: test_collection_result_t Contents Variables results Type-Bound Procedures failure_description num_asserts num_cases num_failing_asserts num_failing_cases passed verbose_description Components Type Visibility Attributes Name Initial type( test_result_item_t ), private, allocatable :: results (:) Type-Bound Procedures procedure, public :: failure_description => test_collection_result_failure_description private pure recursive function test_collection_result_failure_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) procedure, public :: num_asserts => test_collection_result_num_asserts private pure recursive function test_collection_result_num_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value integer procedure, public :: num_cases => test_collection_result_num_cases private pure recursive function test_collection_result_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value integer procedure, public :: num_failing_asserts => test_collection_result_num_failing_asserts private pure recursive function test_collection_result_num_failing_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value integer procedure, public :: num_failing_cases => test_collection_result_num_failing_cases private pure recursive function test_collection_result_num_failing_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value integer procedure, public :: passed => test_collection_result_passed private pure recursive function test_collection_result_passed (self) result(passed) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value logical procedure, public :: verbose_description => test_collection_result_verbose_description private pure recursive function test_collection_result_verbose_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string )","tags":"","loc":"type/test_collection_result_t.html","title":"test_collection_result_t – miniFAVOR "},{"text":"type, public, abstract, extends( test_t ) :: test_collection_t Contents Variables tests Type-Bound Procedures description filter num_cases Components Type Visibility Attributes Name Initial type( test_item_t ), private, allocatable :: tests (:) Type-Bound Procedures procedure, public :: description => test_collection_description private pure recursive function test_collection_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self Return Value type( varying_string ) procedure, public :: filter => test_collection_filter private pure recursive function test_collection_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) procedure, public :: num_cases => test_collection_num_cases private pure recursive function test_collection_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self Return Value integer","tags":"","loc":"type/test_collection_t.html","title":"test_collection_t – miniFAVOR "},{"text":"type, public, extends( test_collection_t ) :: test_collection_with_input_t Contents Variables input Type-Bound Procedures description filter num_cases run_with_input run_without_input Components Type Visibility Attributes Name Initial class( input_t ), private, allocatable :: input Type-Bound Procedures procedure, public :: description => test_collection_description private pure recursive function test_collection_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self Return Value type( varying_string ) procedure, public :: filter => test_collection_filter private pure recursive function test_collection_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) procedure, public :: num_cases => test_collection_num_cases private pure recursive function test_collection_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self Return Value integer procedure, private :: run_with_input => test_collection_with_input_run_with_input private recursive function test_collection_with_input_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_collection_with_input_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) procedure, private :: run_without_input => test_collection_with_input_run_without_input private recursive function test_collection_with_input_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( test_collection_with_input_t ), intent(in) :: self Return Value type( test_result_item_t )","tags":"","loc":"type/test_collection_with_input_t.html","title":"test_collection_with_input_t – miniFAVOR "},{"text":"type, public :: test_item_t Contents Variables test Type-Bound Procedures description filter num_cases run run_with_input run_without_input Components Type Visibility Attributes Name Initial class( test_t ), private, allocatable :: test Type-Bound Procedures procedure, public :: description => test_item_description private pure recursive function test_item_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self Return Value type( varying_string ) procedure, public :: filter => test_item_filter private pure recursive function test_item_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_item_result_t ) procedure, public :: num_cases => test_item_num_cases private pure recursive function test_item_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self Return Value integer generic, public :: run => run_with_input , run_without_input private recursive function test_item_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) private recursive function test_item_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self Return Value type( test_result_item_t ) procedure, private :: run_with_input => test_item_run_with_input private recursive function test_item_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) procedure, private :: run_without_input => test_item_run_without_input private recursive function test_item_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self Return Value type( test_result_item_t )","tags":"","loc":"type/test_item_t.html","title":"test_item_t – miniFAVOR "},{"text":"type, public :: test_result_item_t Contents Variables result_ Type-Bound Procedures failure_description num_asserts num_cases num_failing_asserts num_failing_cases passed verbose_description Components Type Visibility Attributes Name Initial class( test_result_t ), private, allocatable :: result_ Type-Bound Procedures procedure, public :: failure_description => test_result_item_failure_description private pure recursive function test_result_item_failure_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) procedure, public :: num_asserts => test_result_item_num_asserts private pure recursive function test_result_item_num_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value integer procedure, public :: num_cases => test_result_item_num_cases private pure recursive function test_result_item_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value integer procedure, public :: num_failing_asserts => test_result_item_num_failing_asserts private pure recursive function test_result_item_num_failing_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value integer procedure, public :: num_failing_cases => test_result_item_num_failing_cases private pure recursive function test_result_item_num_failing_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value integer procedure, public :: passed => test_result_item_passed private pure recursive function test_result_item_passed (self) result(passed) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value logical procedure, public :: verbose_description => test_result_item_verbose_description private pure recursive function test_result_item_verbose_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string )","tags":"","loc":"type/test_result_item_t.html","title":"test_result_item_t – miniFAVOR "},{"text":"type, public, extends( input_t ) :: transformation_failure_t Contents Variables result_ Components Type Visibility Attributes Name Initial type( result_t ), public :: result_","tags":"","loc":"type/transformation_failure_t.html","title":"transformation_failure_t – miniFAVOR "},{"text":"type, public :: transformed_t Contents Variables input Components Type Visibility Attributes Name Initial class( input_t ), private, allocatable :: input","tags":"","loc":"type/transformed_t.html","title":"transformed_t – miniFAVOR "},{"text":"type, public, extends( test_collection_t ) :: transforming_test_collection_t Contents Variables transformer Type-Bound Procedures description filter num_cases run_with_input run_without_input Components Type Visibility Attributes Name Initial procedure( transformer_i ), private, nopass, pointer :: transformer Type-Bound Procedures procedure, public :: description => test_collection_description private pure recursive function test_collection_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self Return Value type( varying_string ) procedure, public :: filter => test_collection_filter private pure recursive function test_collection_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) procedure, public :: num_cases => test_collection_num_cases private pure recursive function test_collection_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self Return Value integer procedure, private :: run_with_input => transforming_test_collection_run_with_input private recursive function transforming_test_collection_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( transforming_test_collection_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) procedure, private :: run_without_input => transforming_test_collection_run_without_input private function transforming_test_collection_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( transforming_test_collection_t ), intent(in) :: self Return Value type( test_result_item_t )","tags":"","loc":"type/transforming_test_collection_t.html","title":"transforming_test_collection_t – miniFAVOR "},{"text":"type, private :: filter_result_t Contents Variables matched test Components Type Visibility Attributes Name Initial logical, public :: matched class( test_t ), public, allocatable :: test","tags":"","loc":"type/filter_result_t.html","title":"filter_result_t – miniFAVOR "},{"text":"type, private :: individual_result_t Contents Variables message passed_ Type-Bound Procedures failure_description verbose_description Components Type Visibility Attributes Name Initial type( varying_string ), private :: message logical, private :: passed_ Type-Bound Procedures procedure, private :: failure_description => individual_result_failure_description private elemental function individual_result_failure_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( individual_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) procedure, private :: verbose_description => individual_result_verbose_description private elemental function individual_result_verbose_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( individual_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string )","tags":"","loc":"type/individual_result_t.html","title":"individual_result_t – miniFAVOR "},{"text":"type, private :: options_t Contents Variables colorize filter_string filter_tests quiet verbose Components Type Visibility Attributes Name Initial logical, private :: colorize type( varying_string ), private :: filter_string logical, private :: filter_tests logical, private :: quiet logical, private :: verbose","tags":"","loc":"type/options_t.html","title":"options_t – miniFAVOR "},{"text":"type, private, abstract :: test_result_t Contents Variables description Type-Bound Procedures failure_description num_asserts num_cases num_failing_asserts num_failing_cases passed verbose_description Components Type Visibility Attributes Name Initial type( varying_string ), private :: description Type-Bound Procedures procedure( test_result_colorized_description_i ), public, deferred :: failure_description pure function test_result_colorized_description_i(self, colorize) result(description) Prototype Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) procedure( test_result_count_i ), public, deferred :: num_asserts pure function test_result_count_i(self) result(num) Prototype Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value integer procedure( test_result_count_i ), public, deferred :: num_cases pure function test_result_count_i(self) result(num) Prototype Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value integer procedure( test_result_count_i ), public, deferred :: num_failing_asserts pure function test_result_count_i(self) result(num) Prototype Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value integer procedure( test_result_count_i ), public, deferred :: num_failing_cases pure function test_result_count_i(self) result(num) Prototype Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value integer procedure( test_result_passed_i ), public, deferred :: passed pure function test_result_passed_i(self) result(passed) Prototype Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value logical procedure( test_result_colorized_description_i ), public, deferred :: verbose_description pure function test_result_colorized_description_i(self, colorize) result(description) Prototype Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string )","tags":"","loc":"type/test_result_t.html","title":"test_result_t – miniFAVOR "},{"text":"type, private, abstract :: test_t Contents Variables description_ Type-Bound Procedures description filter num_cases run run_with_input run_without_input Components Type Visibility Attributes Name Initial type( varying_string ), private :: description_ Type-Bound Procedures procedure( test_description_i ), public, deferred :: description pure function test_description_i(self) result(description) Prototype Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self Return Value type( varying_string ) procedure( filter_i ), public, deferred :: filter pure function filter_i(self, filter_string) result(filter_result) Prototype Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) procedure( test_count_i ), public, deferred :: num_cases pure function test_count_i(self) result(num) Prototype Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self Return Value integer generic, private :: run => run_with_input , run_without_input function run_with_input_i(self, input) result(result_) Prototype Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) function run_without_input_i(self) result(result_) Prototype Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self Return Value type( test_result_item_t ) procedure( run_with_input_i ), private, deferred :: run_with_input function run_with_input_i(self, input) result(result_) Prototype Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) procedure( run_without_input_i ), private, deferred :: run_without_input function run_without_input_i(self) result(result_) Prototype Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self Return Value type( test_result_item_t )","tags":"","loc":"type/test_t.html","title":"test_t – miniFAVOR "},{"text":"type, private, extends( object ) :: subject Contents Variables write_formatted Type-Bound Procedures mark_as_defined user_defined write(formatted) write_formatted Components Type Visibility Attributes Name Initial procedure, public :: write_formatted Type-Bound Procedures procedure, public :: mark_as_defined interface private pure module subroutine mark_as_defined(this) Implementation → Mark the object as user-defined Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this procedure, public :: user_defined interface private pure module function user_defined(this) result(is_defined) Implementation → Return a boolean result indicating whether this object has been initialized since its declaration Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical generic, public :: write(formatted) => write_formatted subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure( write_interface ), public, deferred :: write_formatted subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"type/subject.html","title":"subject – miniFAVOR "},{"text":"type, public, abstract :: co_object Contents Variables defined facilitate_type_extension Type-Bound Procedures mark_as_defined user_defined Components Type Visibility Attributes Name Initial logical, private :: defined = .false. Default initialization indicates not yet user-defined logical, private, allocatable :: facilitate_type_extension [:] Type-Bound Procedures procedure, public :: mark_as_defined interface private pure module subroutine mark_as_defined(this) Implementation → Mark the co_object as user-defined Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: this procedure, public :: user_defined interface private pure module function user_defined(this) result(is_defined) Implementation → Return a boolean result indicating whether this co_object has been initialized since its declaration Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this Return Value logical","tags":"","loc":"type/co_object.html","title":"co_object – miniFAVOR "},{"text":"type, public :: data_partition encapsulate a description of the data subset the executing image owns Contents Type-Bound Procedures define_partitions first gather last gather_real_1d_array gather_real_2d_array Type-Bound Procedures procedure, public, nopass :: define_partitions interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private module subroutine define_partitions(cardinality) Implementation → define the range of data identification numbers owned by the executing image Arguments Type Intent Optional Attributes Name integer, intent(in) :: cardinality procedure, public, nopass :: first interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private pure module function first(image_number) result(first_index) Implementation → the result is the first identification number owned by the executing image Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer generic, public :: gather => gather_real_2d_array , gather_real_1d_array private interface gather_real_2d_array () Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. Arguments None private interface gather_real_1d_array () Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. Arguments None procedure, public, nopass :: last interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private pure module function last(image_number) result(last_index) Implementation → the result is the last identification number owned by the executing image Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer procedure, private, nopass :: gather_real_1d_array interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private module subroutine gather_real_1d_array(a, result_image, dim) Implementation → Gather the elements of an 1D array distributed along dimension dim onto result_image Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim procedure, private, nopass :: gather_real_2d_array interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private module subroutine gather_real_2d_array(a, result_image, dim) Implementation → Gather the elements of an 2D array distributed along dimension dim onto result_image Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim","tags":"","loc":"type/data_partition.html","title":"data_partition – miniFAVOR "},{"text":"type, public, abstract :: object Define an abstract parent type to ensure basic functionality expected to be provided by all non-abstract types.\n Each non-abstract type provides the functionality by extending this type and implementing its deferred binding(s).  This\n type resembles java's Object class in the sense that it is intended to be the ultimate ancestor of every other type. Contents Variables defined Type-Bound Procedures mark_as_defined user_defined write(formatted) write_formatted Components Type Visibility Attributes Name Initial logical, private :: defined = .false. Default initialization indicates not yet user-defined Type-Bound Procedures procedure, public :: mark_as_defined interface private pure module subroutine mark_as_defined(this) Implementation → Mark the object as user-defined Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this procedure, public :: user_defined interface private pure module function user_defined(this) result(is_defined) Implementation → Return a boolean result indicating whether this object has been initialized since its declaration Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical generic, public :: write(formatted) => write_formatted subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure( write_interface ), public, deferred :: write_formatted subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"Morfeus-FD","loc":"type/object.html","title":"object – miniFAVOR "},{"text":"abstract interface private pure function match_i(char_) result(matches) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char_ Return Value logical","tags":"","loc":"interface/match_i.html","title":"match_i – miniFAVOR"},{"text":"abstract interface private pure function parser_i(state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"interface/parser_i.html","title":"parser_i – miniFAVOR"},{"text":"abstract interface private pure function then_parser_i(previous, state_) result(result_) Arguments Type Intent Optional Attributes Name class( parsed_value_t ), intent(in) :: previous type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"interface/then_parser_i.html","title":"then_parser_i – miniFAVOR"},{"text":"abstract interface private subroutine computation_i() Arguments None","tags":"","loc":"interface/computation_i.html","title":"computation_i – miniFAVOR"},{"text":"abstract interface private pure function filter_i(self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t )","tags":"","loc":"interface/filter_i.html","title":"filter_i – miniFAVOR"},{"text":"abstract interface private function generate_i(self) result(generated_value) Arguments Type Intent Optional Attributes Name class( generator_t ), intent(in) :: self Return Value type( generated_t )","tags":"","loc":"interface/generate_i.html","title":"generate_i – miniFAVOR"},{"text":"abstract interface private function input_test_i(input) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( result_t )","tags":"","loc":"interface/input_test_i.html","title":"input_test_i – miniFAVOR"},{"text":"abstract interface private function run_with_input_i(self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t )","tags":"","loc":"interface/run_with_input_i.html","title":"run_with_input_i – miniFAVOR"},{"text":"abstract interface private function run_without_input_i(self) result(result_) Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self Return Value type( test_result_item_t )","tags":"","loc":"interface/run_without_input_i.html","title":"run_without_input_i – miniFAVOR"},{"text":"abstract interface private function shrink_i(input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t )","tags":"","loc":"interface/shrink_i.html","title":"shrink_i – miniFAVOR"},{"text":"abstract interface private function simple_test_i() result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"interface/simple_test_i.html","title":"simple_test_i – miniFAVOR"},{"text":"abstract interface private pure function test_count_i(self) result(num) Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/test_count_i.html","title":"test_count_i – miniFAVOR"},{"text":"abstract interface private pure function test_description_i(self) result(description) Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self Return Value type( varying_string )","tags":"","loc":"interface/test_description_i.html","title":"test_description_i – miniFAVOR"},{"text":"abstract interface private pure function test_result_colorized_description_i(self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string )","tags":"","loc":"interface/test_result_colorized_description_i.html","title":"test_result_colorized_description_i – miniFAVOR"},{"text":"abstract interface private pure function test_result_count_i(self) result(num) Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/test_result_count_i.html","title":"test_result_count_i – miniFAVOR"},{"text":"abstract interface private pure function test_result_passed_i(self) result(passed) Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/test_result_passed_i.html","title":"test_result_passed_i – miniFAVOR"},{"text":"abstract interface private function transformer_i(input) result(output) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( transformed_t )","tags":"","loc":"interface/transformer_i.html","title":"transformer_i – miniFAVOR"},{"text":"abstract interface private subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/write_interface.html","title":"write_interface – miniFAVOR"},{"text":"public subroutine read_in(fn_in, n_in, n_echo, a, b, nsim, ntime, details, cu_ave, ni_ave, cu_sig, ni_sig, fsurf, rtndt0, stress, temp) Arguments Type Intent Optional Attributes Name character(len=64), intent(in) :: fn_in integer, intent(in) :: n_in integer, intent(in) :: n_echo real, intent(out) :: a real, intent(out) :: b integer, intent(out) :: nsim integer, intent(out) :: ntime logical, intent(out) :: details real, intent(out) :: cu_ave real, intent(out) :: ni_ave real, intent(out) :: cu_sig real, intent(out) :: ni_sig real, intent(out) :: fsurf real, intent(out) :: rtndt0 real, intent(out), allocatable :: stress (:) real, intent(out), allocatable :: temp (:) Contents Source Code read_in Source Code subroutine read_IN ( fn_IN , n_IN , n_ECHO , & a , b , nsim , ntime , details , Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 , stress , temp ) !Variables integer , intent ( in ) :: n_IN , n_ECHO character ( len = 64 ), intent ( in ) :: fn_IN real , intent ( out ) :: a , b , Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 integer , intent ( out ) :: nsim , ntime logical , intent ( out ) :: details real , allocatable , intent ( out ) :: stress (:), temp (:) character ( len = 64 ) :: fn_ECHO integer :: i !Open input file and create echo file open ( unit = n_IN , file = fn_IN , status = 'old' , form = 'formatted' ) fn_ECHO = fn_IN ( 1 : index ( fn_IN , '.in' ) - 1 ) // '.echo' open ( unit = n_ECHO , file = fn_ECHO , status = 'unknown' , form = 'formatted' ) !Read and echo crack depth and vessel thickness read ( n_IN , * ) a , b write ( n_ECHO , '(a25,f10.3,a)' ) 'Crack Depth: ' , a , ' in' write ( n_ECHO , '(a25,f10.3,a)' ) 'Vessel Thickness: ' , b , ' in' !Read and echo number of simulations to be performed andnumber of time steps read ( n_IN , * ) nsim , ntime write ( n_ECHO , '(a25,i10)' ) 'Number of Simulations: ' , nsim write ( n_ECHO , '(a25,i10)' ) 'Number of Time Steps: ' , ntime !Read in and echo type of output to be written read ( n_IN , * ) details write ( n_ECHO , '(a25,l10)' ) 'Detailed output: ' , details !Read and echo embrittlement inputs read ( n_IN , * ) Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 write ( n_ECHO , '(a25,f10.3,a)' ) 'Copper Content: ' , Cu_ave , ' %' write ( n_ECHO , '(a25,f10.3,a)' ) 'Nickel Content: ' , Ni_ave , ' %' write ( n_ECHO , '(a25,f10.3,a)' ) 'Copper Content STDEV: ' , Cu_sig , ' %' write ( n_ECHO , '(a25,f10.3,a)' ) 'Nickel Content STDEV: ' , Ni_sig , ' %' write ( n_ECHO , '(a25,f10.3,a)' ) 'ID Surface Fluence: ' , fsurf , ' n/cm&#94;2' write ( n_ECHO , '(a25,f10.3,a)' ) 'Unirradiated RTndt: ' , RTndt0 , ' degF' !Allocate stress and temperature arrays allocate ( stress ( ntime )) allocate ( temp ( ntime )) !Read and echo stress and temerature inputs write ( n_ECHO , '(a)' ) 'Stress (ksi),      Temperature (degF)' read_transient : do i = 1 , ntime read ( n_IN , * ) stress ( i ), temp ( i ) write ( n_ECHO , '(f10.3,9x,f10.3)' ) stress ( i ), temp ( i ) end do read_transient end subroutine read_IN","tags":"","loc":"proc/read_in.html","title":"read_in – miniFAVOR"},{"text":"public subroutine write_out(fn_in, n_out, n_dat, a, b, nsim, ntime, details, cu_ave, ni_ave, cu_sig, ni_sig, fsurf, rtndt0, r_tndt, cpi, cpi_avg, k_hist, chemistry_content, chemistry_factor) Arguments Type Intent Optional Attributes Name character(len=64), intent(in) :: fn_in integer, intent(in) :: n_out integer, intent(in) :: n_dat real, intent(in) :: a real, intent(in) :: b integer, intent(in) :: nsim integer, intent(in) :: ntime logical, intent(in) :: details real, intent(in) :: cu_ave real, intent(in) :: ni_ave real, intent(in) :: cu_sig real, intent(in) :: ni_sig real, intent(in) :: fsurf real, intent(in) :: rtndt0 real, intent(in) :: r_tndt (:) real, intent(in) :: cpi (:) real, intent(in) :: cpi_avg (:) real, intent(in) :: k_hist (:) real, intent(in) :: chemistry_content (:,:) real, intent(in) :: chemistry_factor (:) Contents Source Code write_out Source Code subroutine write_OUT ( fn_IN , n_OUT , n_DAT , & a , b , nsim , ntime , details , Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 , & R_Tndt , CPI , CPI_avg , K_hist , Chemistry_content , Chemistry_factor ) !Variables character ( len = 64 ), intent ( in ) :: fn_IN integer , intent ( in ) :: n_OUT , n_DAT real , intent ( in ) :: a , b , Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 integer , intent ( in ) :: nsim , ntime logical , intent ( in ) :: details real , intent ( in ) :: K_hist (:), Chemistry_content (:,:), Chemistry_factor (:) real , intent ( in ) :: R_Tndt (:) real , intent ( in ) :: CPI (:) real , intent ( in ) :: CPI_avg (:) character ( len = 64 ) :: fn_OUT , fn_DAT integer :: i !Open output file fn_OUT = fn_IN ( 1 : index ( fn_IN , '.in' ) - 1 ) // '.out' open ( unit = n_OUT , file = fn_OUT , status = 'unknown' , form = 'formatted' ) !Write out important outputs summary write ( n_OUT , '(a)' ) 'MiniFAVOR Output Summary' write ( n_OUT , '(a)' ) '/Key inputs/' write ( n_OUT , '(a25,f10.3,a)' ) 'Crack Depth: ' , a , ' in' write ( n_OUT , '(a25,f10.3,a)' ) 'Vessel Thickness: ' , b , ' in' write ( n_OUT , '(a25,i10)' ) 'Number of Simulations: ' , nsim write ( n_OUT , '(a25,f10.3,a)' ) 'Copper Content: ' , Cu_ave , ' %' write ( n_OUT , '(a25,f10.3,a)' ) 'Nickel Content: ' , Ni_ave , ' %' write ( n_OUT , '(a25,f10.3,a)' ) 'Copper Content STDEV: ' , Cu_sig , ' %' write ( n_OUT , '(a25,f10.3,a)' ) 'Nickel Content STDEV: ' , Ni_sig , ' %' write ( n_OUT , '(a25,f10.3,a)' ) 'ID Surface Fluence: ' , fsurf , ' n/cm&#94;2' write ( n_OUT , '(a25,f10.3,a)' ) 'Unirradiated RTndt: ' , RTndt0 , ' degF' write ( n_OUT , '(a)' ) '/Results/' write ( n_OUT , '(a25,f10.3)' ) 'Final CPI: ' , CPI_avg ( nsim ) write ( n_OUT , '(a25,f10.3,a)' ) 'Minimum crack tip RTndt: ' , & minval ( R_Tndt ), ' degF' write ( n_OUT , '(a25,f10.3,a)' ) 'Maximum crack tip  RTndt: ' , & maxval ( R_Tndt ), ' degF' write ( n_OUT , '(a25,f10.3,a)' ) 'Average crack tip RTndt: ' , & sum ( R_Tndt ) / nsim , ' degF' !Write out detailed output to data file if ( details ) then fn_DAT = fn_IN ( 1 : index ( fn_IN , '.in' ) - 1 ) // '.dat' open ( unit = n_DAT , file = fn_DAT , status = 'unknown' , form = 'formatted' ) write ( n_DAT , '(a)' ) 'MiniFAVOR Detailed Output' write ( n_DAT , '(a)' ) '/Applied SIF (ksi*in&#94;0.5)/' write_SIF : do i = 1 , ntime write ( n_DAT , '(f10.3)' ) K_hist ( i ) end do write_SIF write ( n_DAT , '(a)' ) '/Chemistry Results' write ( n_DAT , '(a)' ) 'Cu content (%),  Ni Content (%), Chemistry Factor CF' write_chem : do i = 1 , nsim write ( n_DAT , '(3f10.3)' ) Chemistry_content ( i , 1 ), Chemistry_content ( i , 2 ), Chemistry_factor ( i ) end do write_chem write ( n_DAT , '(a)' ) '/Vessel CPI data' write ( n_DAT , '(a)' ) 'Vessel RTndt (degF),  Vessel CPI, Cumulative Average CPI' write_CPI : do i = 1 , nsim write ( n_DAT , '(3f10.3)' ) R_Tndt ( i ), CPI ( i ), CPI_avg ( i ) end do write_CPI end if end subroutine write_OUT","tags":"","loc":"proc/write_out.html","title":"write_out – miniFAVOR"},{"text":"interface private pure module function cu_local(self) result(self_cu_local) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real","tags":"","loc":"interface/cu_local.html","title":"cu_local – miniFAVOR"},{"text":"interface private pure module function cu_sig_local(self) result(self_cu_sig_local) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real","tags":"","loc":"interface/cu_sig_local.html","title":"cu_sig_local – miniFAVOR"},{"text":"interface private module subroutine define(self) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(out) :: self","tags":"","loc":"interface/define.html","title":"define – miniFAVOR"},{"text":"interface private pure module function ni_local(self) result(self_ni_local) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real","tags":"","loc":"interface/ni_local.html","title":"ni_local – miniFAVOR"},{"text":"interface private pure module function phi(self) result(self_phi) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real","tags":"","loc":"interface/phi.html","title":"phi – miniFAVOR"},{"text":"interface private module subroutine write_formatted(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/write_formatted.html","title":"write_formatted – miniFAVOR"},{"text":"public function cpi_t(k, rtndt, t) Arguments Type Intent Optional Attributes Name real, intent(in) :: k real, intent(in) :: rtndt real, intent(in) :: t Return Value real Contents Source Code cpi_t Source Code function cpi_t ( K , RTndt , T ) !Variables real :: cpi_t real , intent ( in ) :: K , RTndt , T real :: aKic , bKic , cKic !Calculate aKic, bKic, cKic aKic = 1 9.35 + 8.335 * exp ( 0.02254 * ( T - RTndt )) bKic = 1 5.61 + 5 0.132 * exp ( 0.008 * ( T - RTndt )) cKic = 4.0 !Calculate cpi_t if ( K < aKic ) then cpi_t = 0.0 else cpi_t = 1 - exp ( - (( K - aKic ) / bKic ) ** cKic ) end if end function cpi_t","tags":"","loc":"proc/cpi_t.html","title":"cpi_t – miniFAVOR"},{"text":"public function cf(cu, ni) Uses constants_h Arguments Type Intent Optional Attributes Name real, intent(in) :: cu real, intent(in) :: ni Return Value real Contents Source Code cf Source Code function RTndt ( a , CF , fsurf , RTndt0 , phi ) !Variables real :: RTndt , D_RTepi , D_RTndt , f real , intent ( in ) :: a , CF , fsurf , RTndt0 , phi !Calculate D_RTepi D_RTepi = - 2 9.5 + 7 8.0 * ( - log ( 1 - phi )) ** ( 1 / 1.73 ) !Calculate D_RTndt f = fsurf * exp ( - 0.24 * a ) D_RTndt = CF * f ** ( 0.28 - 0.10 * log10 ( f )) !Calculate the RTndt RTndt = RTndt0 + D_RTepi + D_RTndt end function RTndt !This function calculates the weld chemistry factor given the copper and nickel contents function CF ( Cu , Ni ) use constants_h , only : CF_weld !Variables real :: CF real , intent ( in ) :: Cu , Ni integer :: Cu_int , Ni_int real :: CF_1 , CF_2 !Calculate indexes for copper interpolation: !  multiply the Cu-% by 100 and take the integer truncation to find interpolation bounds !  truncate interpolation between 0% and 0.40% Cu_int = int ( Cu * 100 ) if ( Cu_int < 0 ) then Cu_int = 0 else if ( Cu_int > 40 ) then Cu_int = 40 end if !Calculate indexes for nickel interpolation: !  multiply the Ni-% by 100 and take the integer truncation to find interpolation bounds !  truncate interpolation between 0% and 1.20% Ni_int = int ( Ni * 100 ) if ( Ni_int < 0 ) then Ni_int = 0 else if ( Ni_int > 120 ) then Ni_int = 120 end if !Nickel contents in CF_weld are at intervals of 0.20% nickel Ni_int = int ( Ni_int / 20 ) + 1 !Bi-linear interpolation if ( Cu <= 0.0 . or . Cu >= 0.40 ) then !only interpolate on nickel select case ( Ni_int ) case ( 7 ) CF = CF_weld ( Cu_int , Ni_int ) case default CF = CF_weld ( Cu_int , Ni_int ) + & ( Ni - 0.2 * ( Ni_int - 1 )) / 0.2 * ( CF_weld ( Cu_int , Ni_int + 1 ) - CF_weld ( Cu_int , Ni_int )) end select else !First, interpolate on copper select case ( Ni_int ) case ( 7 ) CF = CF_weld ( Cu_int , Ni_int ) + & ( Cu - 0.01 * ( Cu_int )) / 0.01 * ( CF_weld ( Cu_int + 1 , Ni_int ) - CF_weld ( Cu_int + 1 , Ni_int )) case default CF_1 = CF_weld ( Cu_int , Ni_int ) + & ( Cu - 0.01 * ( Cu_int )) / 0.01 * ( CF_weld ( Cu_int + 1 , Ni_int ) - CF_weld ( Cu_int + 1 , Ni_int )) CF_2 = CF_weld ( Cu_int , Ni_int + 1 ) + & ( Cu - 0.01 * ( Cu_int )) / 0.01 * ( CF_weld ( Cu_int + 1 , Ni_int + 1 ) - CF_weld ( Cu_int + 1 , Ni_int + 1 )) !Second, interpolate on nickel CF = CF_1 + ( Ni - 0.2 * ( Ni_int - 1 )) / 0.2 * ( CF_2 - CF_1 ) end select end if end function CF","tags":"","loc":"proc/cf.html","title":"cf – miniFAVOR"},{"text":"public function rtndt(a, cf, fsurf, rtndt0, phi) Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: cf real, intent(in) :: fsurf real, intent(in) :: rtndt0 real, intent(in) :: phi Return Value real Contents Source Code rtndt Source Code function RTndt ( a , CF , fsurf , RTndt0 , phi ) !Variables real :: RTndt , D_RTepi , D_RTndt , f real , intent ( in ) :: a , CF , fsurf , RTndt0 , phi !Calculate D_RTepi D_RTepi = - 2 9.5 + 7 8.0 * ( - log ( 1 - phi )) ** ( 1 / 1.73 ) !Calculate D_RTndt f = fsurf * exp ( - 0.24 * a ) D_RTndt = CF * f ** ( 0.28 - 0.10 * log10 ( f )) !Calculate the RTndt RTndt = RTndt0 + D_RTepi + D_RTndt end function RTndt","tags":"","loc":"proc/rtndt.html","title":"rtndt – miniFAVOR"},{"text":"public subroutine sample_chem(cu_ave, ni_ave, cu_sig, ni_sig, cu_local, ni_local, samples) Uses randomness_m Arguments Type Intent Optional Attributes Name real, intent(in) :: cu_ave real, intent(in) :: ni_ave real, intent(in) :: cu_sig real, intent(in) :: ni_sig real, intent(out) :: cu_local real, intent(out) :: ni_local type( random_samples_t ), intent(in) :: samples Contents Source Code sample_chem Source Code subroutine sample_chem ( Cu_ave , Ni_ave , Cu_sig , Ni_sig , Cu_local , Ni_local , samples ) use randomness_m , only : random_samples_t !Variables type ( random_samples_t ), intent ( in ) :: samples real , intent ( in ) :: Cu_ave , Ni_ave , Cu_sig , Ni_sig real , intent ( out ) :: Cu_local , Ni_local real :: Cu_bar , Cu_sig_star , Cu_sig_local ! Requires call assert ( samples % user_defined (), \"random_samples_t%sample_chem: samples%user_defined()\" ) !Sample local copper content based on weld copper sampling procedure Cu_bar = Cu_ave * Cu_sig Cu_sig_star = min ( 0.0718 * Cu_ave , 0.0185 ) Cu_sig_local = Cu_bar + Cu_sig_star * sqrt ( 2.0 ) * erfc ( 2 * samples % Cu_sig_local () - 1 ) Cu_local = Cu_ave + Cu_sig_local * sqrt ( 2.0 ) * erfc ( 2 * samples % Cu_local () - 1 ) !Sample local nickel content based on weld nickel heat 34B009 & W5214 procedure Ni_local = Ni_ave + Ni_sig * sqrt ( 2.0 ) * erfc ( 2 * samples % Ni_local () - 1 ) end subroutine sample_chem","tags":"","loc":"proc/sample_chem.html","title":"sample_chem – miniFAVOR"},{"text":"public elemental function ki_t(a, b, stress) Uses constants_h Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: b real, intent(in) :: stress Return Value real Contents Source Code ki_t Source Code elemental function Ki_t ( a , b , stress ) use constants_h , only : Pi !Variables real :: Ki_t real , intent ( in ) :: a , b , stress !Calculate Ki_t Ki_t = stress * sqrt ( Pi * a ) * & ( 1.122 - 0.231 * ( a / b ) + 1 0.55 * ( a / b ) ** 2 - 2 1.71 * ( a / b ) ** 3 + 3 0.382 * ( a / b ) ** 4 ) end function Ki_t","tags":"","loc":"proc/ki_t.html","title":"ki_t – miniFAVOR"},{"text":"public function test_many1_with_separator() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_many1_with_separator.html","title":"test_many1_with_separator – miniFAVOR"},{"text":"private pure function check_many() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_many.html","title":"check_many – miniFAVOR"},{"text":"private pure function check_many_with_separator() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_many_with_separator.html","title":"check_many_with_separator – miniFAVOR"},{"text":"private pure function check_none() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_none.html","title":"check_none – miniFAVOR"},{"text":"private pure function check_one() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_one.html","title":"check_one – miniFAVOR"},{"text":"private pure function check_one_with_separator() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_one_with_separator.html","title":"check_one_with_separator – miniFAVOR"},{"text":"private pure function parse_a(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_a.html","title":"parse_a – miniFAVOR"},{"text":"private pure function parse_comma(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_comma.html","title":"parse_comma – miniFAVOR"},{"text":"public function test_parse_string() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_parse_string.html","title":"test_parse_string – miniFAVOR"},{"text":"private pure function check_fail() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_fail.html","title":"check_fail – miniFAVOR"},{"text":"private pure function check_pass() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_pass.html","title":"check_pass – miniFAVOR"},{"text":"public function test_parse_whitespace() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_parse_whitespace.html","title":"test_parse_whitespace – miniFAVOR"},{"text":"private pure function check_parse_different_character() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_different_character.html","title":"check_parse_different_character – miniFAVOR"},{"text":"private pure function check_parse_empty_string() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_empty_string.html","title":"check_parse_empty_string – miniFAVOR"},{"text":"private pure function check_parse_first_character() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_first_character.html","title":"check_parse_first_character – miniFAVOR"},{"text":"public function test_sequence() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_sequence.html","title":"test_sequence – miniFAVOR"},{"text":"private pure function check_both_pass() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_both_pass.html","title":"check_both_pass – miniFAVOR"},{"text":"private pure function check_first_fail() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_first_fail.html","title":"check_first_fail – miniFAVOR"},{"text":"private pure function check_second_fail() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_second_fail.html","title":"check_second_fail – miniFAVOR"},{"text":"private pure function parse_a(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_a~2.html","title":"parse_a – miniFAVOR"},{"text":"private pure function then_parse_b(previous, state_) result(result_) Uses iso_varying_string parff Arguments Type Intent Optional Attributes Name class( parsed_value_t ), intent(in) :: previous type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/then_parse_b.html","title":"then_parse_b – miniFAVOR"},{"text":"public function test_many1() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_many1.html","title":"test_many1 – miniFAVOR"},{"text":"private pure function check_many() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_many~2.html","title":"check_many – miniFAVOR"},{"text":"private pure function check_none() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_none~2.html","title":"check_none – miniFAVOR"},{"text":"private pure function check_parse_one() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_one.html","title":"check_parse_one – miniFAVOR"},{"text":"private pure function parse_a(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_a~3.html","title":"parse_a – miniFAVOR"},{"text":"public function test_many() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_many.html","title":"test_many – miniFAVOR"},{"text":"private pure function check_many() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_many~3.html","title":"check_many – miniFAVOR"},{"text":"private pure function check_none() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_none~3.html","title":"check_none – miniFAVOR"},{"text":"private pure function check_one() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_one~2.html","title":"check_one – miniFAVOR"},{"text":"private pure function parse_a(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_a~4.html","title":"parse_a – miniFAVOR"},{"text":"subroutine run() Uses drop_then_test either_test many1_test many1_with_separator_test many_test many_with_separator_test optionally_test parse_character_test parse_digit_test parse_integer_test parse_rational_test parse_string_test parse_whitespace_test parse_with_test repeat_test sequence_test then_drop_test vegetables Arguments None Contents None","tags":"","loc":"proc/run.html","title":"run – miniFAVOR"},{"text":"public function test_repeat() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_repeat.html","title":"test_repeat – miniFAVOR"},{"text":"private pure function check_not_enough() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_enough.html","title":"check_not_enough – miniFAVOR"},{"text":"private pure function check_repeat() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_repeat.html","title":"check_repeat – miniFAVOR"},{"text":"private pure function parse_a(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_a~5.html","title":"parse_a – miniFAVOR"},{"text":"public function test_parse_rational() result(tests) Uses iso_varying_string vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_parse_rational.html","title":"test_parse_rational – miniFAVOR"},{"text":"private pure function check_parse_empty() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_empty.html","title":"check_parse_empty – miniFAVOR"},{"text":"private pure function check_parse_invalid(input) result(result_) Uses parff vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_invalid.html","title":"check_parse_invalid – miniFAVOR"},{"text":"private pure function check_parse_rational(input) result(result_) Uses parff vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_rational.html","title":"check_parse_rational – miniFAVOR"},{"text":"public function test_drop_then() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_drop_then.html","title":"test_drop_then – miniFAVOR"},{"text":"private pure function check_both_pass() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_both_pass~2.html","title":"check_both_pass – miniFAVOR"},{"text":"private pure function check_first_fail() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_first_fail~2.html","title":"check_first_fail – miniFAVOR"},{"text":"private pure function check_second_fail() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_second_fail~2.html","title":"check_second_fail – miniFAVOR"},{"text":"private pure function parse_a(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_a~6.html","title":"parse_a – miniFAVOR"},{"text":"private pure function parse_b(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_b.html","title":"parse_b – miniFAVOR"},{"text":"public function test_parse_with() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_parse_with.html","title":"test_parse_with – miniFAVOR"},{"text":"private pure function check_failure() result(result_) Uses parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure.html","title":"check_failure – miniFAVOR"},{"text":"private pure function check_successful() result(result_) Uses parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_successful.html","title":"check_successful – miniFAVOR"},{"text":"private pure function the_parser(state) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/the_parser.html","title":"the_parser – miniFAVOR"},{"text":"public function test_then_drop() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_then_drop.html","title":"test_then_drop – miniFAVOR"},{"text":"private pure function check_both_pass() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_both_pass~3.html","title":"check_both_pass – miniFAVOR"},{"text":"private pure function check_first_fail() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_first_fail~3.html","title":"check_first_fail – miniFAVOR"},{"text":"private pure function check_second_fail() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_second_fail~3.html","title":"check_second_fail – miniFAVOR"},{"text":"private pure function parse_a(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_a~7.html","title":"parse_a – miniFAVOR"},{"text":"private pure function parse_b(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_b~2.html","title":"parse_b – miniFAVOR"},{"text":"public function test_either() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_either.html","title":"test_either – miniFAVOR"},{"text":"private pure function check_both_fail() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_both_fail.html","title":"check_both_fail – miniFAVOR"},{"text":"private pure function check_first_pass() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_first_pass.html","title":"check_first_pass – miniFAVOR"},{"text":"private pure function check_second_pass() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_second_pass.html","title":"check_second_pass – miniFAVOR"},{"text":"private pure function parse_a(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_a~8.html","title":"parse_a – miniFAVOR"},{"text":"private pure function parse_f(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_f.html","title":"parse_f – miniFAVOR"},{"text":"public function test_parse_character() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_parse_character.html","title":"test_parse_character – miniFAVOR"},{"text":"private pure function check_parse_different_character() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_different_character~2.html","title":"check_parse_different_character – miniFAVOR"},{"text":"private pure function check_parse_empty_string() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_empty_string~2.html","title":"check_parse_empty_string – miniFAVOR"},{"text":"private pure function check_parse_first_character() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_first_character~2.html","title":"check_parse_first_character – miniFAVOR"},{"text":"public function test_optionally() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_optionally.html","title":"test_optionally – miniFAVOR"},{"text":"private pure function check_parse_empty() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_empty~2.html","title":"check_parse_empty – miniFAVOR"},{"text":"private pure function check_parse_fails() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_fails.html","title":"check_parse_fails – miniFAVOR"},{"text":"private pure function check_parse_succeed() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_succeed.html","title":"check_parse_succeed – miniFAVOR"},{"text":"private pure function parse_a(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_a~9.html","title":"parse_a – miniFAVOR"},{"text":"public function test_many_with_separator() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_many_with_separator.html","title":"test_many_with_separator – miniFAVOR"},{"text":"private pure function check_many() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_many~4.html","title":"check_many – miniFAVOR"},{"text":"private pure function check_many_with_separator() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_many_with_separator~2.html","title":"check_many_with_separator – miniFAVOR"},{"text":"private pure function check_none() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_none~4.html","title":"check_none – miniFAVOR"},{"text":"private pure function check_one() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_one~3.html","title":"check_one – miniFAVOR"},{"text":"private pure function check_one_with_separator() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_one_with_separator~2.html","title":"check_one_with_separator – miniFAVOR"},{"text":"private pure function parse_a(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_a~10.html","title":"parse_a – miniFAVOR"},{"text":"private pure function parse_comma(state_) result(result_) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_comma~2.html","title":"parse_comma – miniFAVOR"},{"text":"public function test_parse_digit() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_parse_digit.html","title":"test_parse_digit – miniFAVOR"},{"text":"private pure function check_parse_different_character() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_different_character~3.html","title":"check_parse_different_character – miniFAVOR"},{"text":"private pure function check_parse_empty_string() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_empty_string~3.html","title":"check_parse_empty_string – miniFAVOR"},{"text":"private pure function check_parse_first_character() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_first_character~3.html","title":"check_parse_first_character – miniFAVOR"},{"text":"public function test_parse_integer() result(tests) Uses iso_varying_string vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_parse_integer.html","title":"test_parse_integer – miniFAVOR"},{"text":"private pure function check_parse_empty() result(result_) Uses iso_varying_string parff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_empty~3.html","title":"check_parse_empty – miniFAVOR"},{"text":"private pure function check_parse_integer(input) result(result_) Uses parff vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_integer.html","title":"check_parse_integer – miniFAVOR"},{"text":"private pure function check_parse_invalid(input) result(result_) Uses parff vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_parse_invalid~2.html","title":"check_parse_invalid – miniFAVOR"},{"text":"public pure function consumed_ok(parsed, remaining, position, message_) Uses iso_varying_string Arguments Type Intent Optional Attributes Name class( parsed_value_t ), intent(in) :: parsed type( varying_string ), intent(in) :: remaining type( position_t ), intent(in) :: position type( message_t ), intent(in) :: message_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/consumed_ok.html","title":"consumed_ok – miniFAVOR"},{"text":"public pure recursive function either(parse1, parse2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parse1 procedure( parser_i ) :: parse2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/either.html","title":"either – miniFAVOR"},{"text":"public pure function empty_error(message_) Arguments Type Intent Optional Attributes Name type( message_t ), intent(in) :: message_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/empty_error.html","title":"empty_error – miniFAVOR"},{"text":"public pure function empty_ok(parsed, remaining, position, message_) Uses iso_varying_string Arguments Type Intent Optional Attributes Name class( parsed_value_t ), intent(in) :: parsed type( varying_string ), intent(in) :: remaining type( position_t ), intent(in) :: position type( message_t ), intent(in) :: message_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/empty_ok.html","title":"empty_ok – miniFAVOR"},{"text":"public pure function many(the_parser, the_state) result(the_result) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: the_parser type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/many.html","title":"many – miniFAVOR"},{"text":"public pure function many1(the_parser, the_state) result(the_result) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: the_parser type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/many1.html","title":"many1 – miniFAVOR"},{"text":"public pure function many1_with_separator(the_parser, the_separator, the_state) result(the_result) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: the_parser procedure( parser_i ) :: the_separator type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/many1_with_separator.html","title":"many1_with_separator – miniFAVOR"},{"text":"public pure function many_with_separator(the_parser, the_separator, the_state) result(the_result) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: the_parser procedure( parser_i ) :: the_separator type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/many_with_separator.html","title":"many_with_separator – miniFAVOR"},{"text":"public pure function message(position, found, expected) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( position_t ), intent(in) :: position type( varying_string ), intent(in) :: found type( varying_string ), intent(in) :: expected (:) Return Value type( message_t ) Contents None","tags":"","loc":"proc/message.html","title":"message – miniFAVOR"},{"text":"public pure function new_state(input) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: input Return Value type( state_t ) Contents None","tags":"","loc":"proc/new_state.html","title":"new_state – miniFAVOR"},{"text":"public pure function optionally(parser, the_state) result(the_result) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/optionally.html","title":"optionally – miniFAVOR"},{"text":"public pure function parse_char(the_char, the_state) result(the_result) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: the_char type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_char.html","title":"parse_char – miniFAVOR"},{"text":"public pure function parse_digit(the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_digit.html","title":"parse_digit – miniFAVOR"},{"text":"public pure function parse_integer(the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_integer.html","title":"parse_integer – miniFAVOR"},{"text":"public pure function parse_nothing(the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_nothing.html","title":"parse_nothing – miniFAVOR"},{"text":"public pure function parse_rational(the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_rational.html","title":"parse_rational – miniFAVOR"},{"text":"public pure function parse_whitespace(the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_whitespace.html","title":"parse_whitespace – miniFAVOR"},{"text":"public pure function repeat_(the_parser, times, the_state) result(the_result) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: the_parser integer, intent(in) :: times type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/repeat_.html","title":"repeat_ – miniFAVOR"},{"text":"public pure function return_(parsed, state_) result(result_) Uses iso_varying_string Arguments Type Intent Optional Attributes Name class( parsed_value_t ), intent(in) :: parsed type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/return_.html","title":"return_ – miniFAVOR"},{"text":"public pure function satisfy(matches, state_) result(result_) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name procedure( match_i ) :: matches type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/satisfy.html","title":"satisfy – miniFAVOR"},{"text":"private pure recursive function drop_then_parser(parser1, parser2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser1 procedure( parser_i ) :: parser2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/drop_then_parser.html","title":"drop_then_parser – miniFAVOR"},{"text":"private pure recursive function drop_then_result(previous, parser) result(result_) Arguments Type Intent Optional Attributes Name type( parser_output_t ), intent(in) :: previous procedure( parser_i ) :: parser Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/drop_then_result.html","title":"drop_then_result – miniFAVOR"},{"text":"private pure function expect(message_, label) result(new_message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( message_t ), intent(in) :: message_ type( varying_string ), intent(in) :: label Return Value type( message_t ) Contents None","tags":"","loc":"proc/expect.html","title":"expect – miniFAVOR"},{"text":"private pure function merge_(message1, message2) result(merged) Arguments Type Intent Optional Attributes Name type( message_t ), intent(in) :: message1 type( message_t ), intent(in) :: message2 Return Value type( message_t ) Contents None","tags":"","loc":"proc/merge_.html","title":"merge_ – miniFAVOR"},{"text":"private pure function merge_error(message1, message2) result(result_) Arguments Type Intent Optional Attributes Name type( message_t ), intent(in) :: message1 type( message_t ), intent(in) :: message2 Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/merge_error.html","title":"merge_error – miniFAVOR"},{"text":"private pure function merge_ok(parsed, remaining, position, message1, message2) result(result_) Uses iso_varying_string Arguments Type Intent Optional Attributes Name class( parsed_value_t ), intent(in) :: parsed type( varying_string ), intent(in) :: remaining type( position_t ), intent(in) :: position type( message_t ), intent(in) :: message1 type( message_t ), intent(in) :: message2 Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/merge_ok.html","title":"merge_ok – miniFAVOR"},{"text":"private pure function message_to_string(self) result(string) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name class( message_t ), intent(in) :: self Return Value type( varying_string ) Contents None","tags":"","loc":"proc/message_to_string.html","title":"message_to_string – miniFAVOR"},{"text":"private pure function new_position() Arguments None Return Value type( position_t ) Contents None","tags":"","loc":"proc/new_position.html","title":"new_position – miniFAVOR"},{"text":"private pure function next_position(char_, position) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char_ type( position_t ), intent(in) :: position Return Value type( position_t ) Contents None","tags":"","loc":"proc/next_position.html","title":"next_position – miniFAVOR"},{"text":"private pure function parse_string_c(string, the_state) result(the_result) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_string_c.html","title":"parse_string_c – miniFAVOR"},{"text":"private pure function parse_string_s(string, the_state) result(the_result) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_string_s.html","title":"parse_string_s – miniFAVOR"},{"text":"private pure function parse_with_c(parser, string) result(result_) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser character(len=*), intent(in) :: string Return Value type( parse_result_t ) Contents None","tags":"","loc":"proc/parse_with_c.html","title":"parse_with_c – miniFAVOR"},{"text":"private pure function parse_with_s(parser, string) result(result_) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser type( varying_string ), intent(in) :: string Return Value type( parse_result_t ) Contents None","tags":"","loc":"proc/parse_with_s.html","title":"parse_with_s – miniFAVOR"},{"text":"private pure recursive function sequence_parser(parser1, parser2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser1 procedure( then_parser_i ) :: parser2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/sequence_parser.html","title":"sequence_parser – miniFAVOR"},{"text":"private pure recursive function sequence_result(previous, parser) result(result_) Arguments Type Intent Optional Attributes Name type( parser_output_t ), intent(in) :: previous procedure( then_parser_i ) :: parser Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/sequence_result.html","title":"sequence_result – miniFAVOR"},{"text":"private pure function state(input, position) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: input type( position_t ), intent(in) :: position Return Value type( state_t ) Contents None","tags":"","loc":"proc/state.html","title":"state – miniFAVOR"},{"text":"private pure function then_drop_parser(parser1, parser2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser1 procedure( parser_i ) :: parser2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/then_drop_parser.html","title":"then_drop_parser – miniFAVOR"},{"text":"private pure function then_drop_result(previous, parser) result(result_) Arguments Type Intent Optional Attributes Name type( parser_output_t ), intent(in) :: previous procedure( parser_i ) :: parser Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/then_drop_result.html","title":"then_drop_result – miniFAVOR"},{"text":"private pure recursive function with_label_c(label, parse, state_) result(result_) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label procedure( parser_i ) :: parse type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/with_label_c.html","title":"with_label_c – miniFAVOR"},{"text":"private pure recursive function with_label_s(label, parse, state_) result(result_) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: label procedure( parser_i ) :: parse type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/with_label_s.html","title":"with_label_s – miniFAVOR"},{"text":"public interface drop_then Contents Module Procedures drop_then_parser drop_then_result Module Procedures private pure recursive function drop_then_parser (parser1, parser2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser1 procedure( parser_i ) :: parser2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure recursive function drop_then_result (previous, parser) result(result_) Arguments Type Intent Optional Attributes Name type( parser_output_t ), intent(in) :: previous procedure( parser_i ) :: parser Return Value type( parser_output_t )","tags":"","loc":"interface/drop_then.html","title":"drop_then – miniFAVOR"},{"text":"public interface parse_string Contents Module Procedures parse_string_c parse_string_s Module Procedures private pure function parse_string_c (string, the_state) result(the_result) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_string_s (string, the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( state_t ), intent(in) :: the_state Return Value type( parser_output_t )","tags":"","loc":"interface/parse_string.html","title":"parse_string – miniFAVOR"},{"text":"public interface parse_with Contents Module Procedures parse_with_c parse_with_s Module Procedures private pure function parse_with_c (parser, string) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser character(len=*), intent(in) :: string Return Value type( parse_result_t ) private pure function parse_with_s (parser, string) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser type( varying_string ), intent(in) :: string Return Value type( parse_result_t )","tags":"","loc":"interface/parse_with.html","title":"parse_with – miniFAVOR"},{"text":"public interface sequence Contents Module Procedures sequence_parser sequence_result Module Procedures private pure recursive function sequence_parser (parser1, parser2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser1 procedure( then_parser_i ) :: parser2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure recursive function sequence_result (previous, parser) result(result_) Arguments Type Intent Optional Attributes Name type( parser_output_t ), intent(in) :: previous procedure( then_parser_i ) :: parser Return Value type( parser_output_t )","tags":"","loc":"interface/sequence.html","title":"sequence – miniFAVOR"},{"text":"public interface then_drop Contents Module Procedures then_drop_parser then_drop_result Module Procedures private pure function then_drop_parser (parser1, parser2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser1 procedure( parser_i ) :: parser2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure function then_drop_result (previous, parser) result(result_) Arguments Type Intent Optional Attributes Name type( parser_output_t ), intent(in) :: previous procedure( parser_i ) :: parser Return Value type( parser_output_t )","tags":"","loc":"interface/then_drop.html","title":"then_drop – miniFAVOR"},{"text":"public interface with_label Contents Module Procedures with_label_c with_label_s Module Procedures private pure recursive function with_label_c (label, parse, state_) result(result_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label procedure( parser_i ) :: parse type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure recursive function with_label_s (label, parse, state_) result(result_) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: label procedure( parser_i ) :: parse type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"interface/with_label.html","title":"with_label – miniFAVOR"},{"text":"public function test_split_character() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_split_character.html","title":"test_split_character – miniFAVOR"},{"text":"private pure function check_backward_no_separator() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_backward_no_separator.html","title":"check_backward_no_separator – miniFAVOR"},{"text":"private pure function check_backward_no_separator_empty_set() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_backward_no_separator_empty_set.html","title":"check_backward_no_separator_empty_set – miniFAVOR"},{"text":"private pure function check_backward_no_separator_not_found() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_backward_no_separator_not_found.html","title":"check_backward_no_separator_not_found – miniFAVOR"},{"text":"private pure function check_backward_with_separator() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_backward_with_separator.html","title":"check_backward_with_separator – miniFAVOR"},{"text":"private pure function check_backward_with_separator_empty_set() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_backward_with_separator_empty_set.html","title":"check_backward_with_separator_empty_set – miniFAVOR"},{"text":"private pure function check_backward_with_separator_not_found() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_backward_with_separator_not_found.html","title":"check_backward_with_separator_not_found – miniFAVOR"},{"text":"private pure function check_forward_no_separator() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_forward_no_separator.html","title":"check_forward_no_separator – miniFAVOR"},{"text":"private pure function check_forward_no_separator_empty_set() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_forward_no_separator_empty_set.html","title":"check_forward_no_separator_empty_set – miniFAVOR"},{"text":"private pure function check_forward_no_separator_not_found() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_forward_no_separator_not_found.html","title":"check_forward_no_separator_not_found – miniFAVOR"},{"text":"private pure function check_forward_with_separator() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_forward_with_separator.html","title":"check_forward_with_separator – miniFAVOR"},{"text":"private pure function check_forward_with_separator_empty_set() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_forward_with_separator_empty_set.html","title":"check_forward_with_separator_empty_set – miniFAVOR"},{"text":"private pure function check_forward_with_separator_not_found() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_forward_with_separator_not_found.html","title":"check_forward_with_separator_not_found – miniFAVOR"},{"text":"private pure function check_not_backward_no_separator() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_backward_no_separator.html","title":"check_not_backward_no_separator – miniFAVOR"},{"text":"private pure function check_not_backward_no_separator_empty_set() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_backward_no_separator_empty_set.html","title":"check_not_backward_no_separator_empty_set – miniFAVOR"},{"text":"private pure function check_not_backward_no_separator_not_found() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_backward_no_separator_not_found.html","title":"check_not_backward_no_separator_not_found – miniFAVOR"},{"text":"private pure function check_not_backward_with_separator() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_backward_with_separator.html","title":"check_not_backward_with_separator – miniFAVOR"},{"text":"private pure function check_not_backward_with_separator_empty_set() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_backward_with_separator_empty_set.html","title":"check_not_backward_with_separator_empty_set – miniFAVOR"},{"text":"private pure function check_not_backward_with_separator_not_found() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_backward_with_separator_not_found.html","title":"check_not_backward_with_separator_not_found – miniFAVOR"},{"text":"public function test_llt() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_llt.html","title":"test_llt – miniFAVOR"},{"text":"private pure function check_character_llt_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_character_llt_string.html","title":"check_character_llt_string – miniFAVOR"},{"text":"private pure function check_string_llt_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_llt_character.html","title":"check_string_llt_character – miniFAVOR"},{"text":"private pure function check_string_llt_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_llt_string.html","title":"check_string_llt_string – miniFAVOR"},{"text":"private function generate_character(self) result(generated_value) Uses vegetables Arguments Type Intent Optional Attributes Name class( ascii_character_generator_t ), intent(in) :: self Return Value type( generated_t ) Contents None","tags":"","loc":"proc/generate_character.html","title":"generate_character – miniFAVOR"},{"text":"private function generate_string_and_integer(self) result(generated_value) Uses vegetables Arguments Type Intent Optional Attributes Name class( ascii_string_and_integer_generator_t ), intent(in) :: self Return Value type( generated_t ) Contents None","tags":"","loc":"proc/generate_string_and_integer.html","title":"generate_string_and_integer – miniFAVOR"},{"text":"private function generate_string_pair(self) result(generated_value) Uses vegetables Arguments Type Intent Optional Attributes Name class( ascii_string_pair_generator_t ), intent(in) :: self Return Value type( generated_t ) Contents None","tags":"","loc":"proc/generate_string_pair.html","title":"generate_string_pair – miniFAVOR"},{"text":"private pure function shrink_character(input) result(shrunk) Uses vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t ) Contents None","tags":"","loc":"proc/shrink_character.html","title":"shrink_character – miniFAVOR"},{"text":"private pure function shrink_string_and_integer(input) result(shrunk) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t ) Contents None","tags":"","loc":"proc/shrink_string_and_integer.html","title":"shrink_string_and_integer – miniFAVOR"},{"text":"private pure function shrink_string_pair(input) result(shrunk) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t ) Contents None","tags":"","loc":"proc/shrink_string_pair.html","title":"shrink_string_pair – miniFAVOR"},{"text":"public function test_adjustr() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_adjustr.html","title":"test_adjustr – miniFAVOR"},{"text":"private pure function check_adjustr(string) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_adjustr.html","title":"check_adjustr – miniFAVOR"},{"text":"public function test_not_equals() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_not_equals.html","title":"test_not_equals – miniFAVOR"},{"text":"private pure function check_character_not_equal_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_character_not_equal_string.html","title":"check_character_not_equal_string – miniFAVOR"},{"text":"private pure function check_string_not_equal_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_not_equal_character.html","title":"check_string_not_equal_character – miniFAVOR"},{"text":"private pure function check_string_not_equal_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_not_equal_string.html","title":"check_string_not_equal_string – miniFAVOR"},{"text":"public function test_split_character() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_split_character~2.html","title":"test_split_character – miniFAVOR"},{"text":"private pure function check_backward_no_separator() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_backward_no_separator~2.html","title":"check_backward_no_separator – miniFAVOR"},{"text":"private pure function check_backward_no_separator_empty_set() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_backward_no_separator_empty_set~2.html","title":"check_backward_no_separator_empty_set – miniFAVOR"},{"text":"private pure function check_backward_no_separator_not_found() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_backward_no_separator_not_found~2.html","title":"check_backward_no_separator_not_found – miniFAVOR"},{"text":"private pure function check_backward_with_separator() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_backward_with_separator~2.html","title":"check_backward_with_separator – miniFAVOR"},{"text":"private pure function check_backward_with_separator_empty_set() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_backward_with_separator_empty_set~2.html","title":"check_backward_with_separator_empty_set – miniFAVOR"},{"text":"private pure function check_backward_with_separator_not_found() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_backward_with_separator_not_found~2.html","title":"check_backward_with_separator_not_found – miniFAVOR"},{"text":"private pure function check_forward_no_separator() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_forward_no_separator~2.html","title":"check_forward_no_separator – miniFAVOR"},{"text":"private pure function check_forward_no_separator_empty_set() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_forward_no_separator_empty_set~2.html","title":"check_forward_no_separator_empty_set – miniFAVOR"},{"text":"private pure function check_forward_no_separator_not_found() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_forward_no_separator_not_found~2.html","title":"check_forward_no_separator_not_found – miniFAVOR"},{"text":"private pure function check_forward_with_separator() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_forward_with_separator~2.html","title":"check_forward_with_separator – miniFAVOR"},{"text":"private pure function check_forward_with_separator_empty_set() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_forward_with_separator_empty_set~2.html","title":"check_forward_with_separator_empty_set – miniFAVOR"},{"text":"private pure function check_forward_with_separator_not_found() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_forward_with_separator_not_found~2.html","title":"check_forward_with_separator_not_found – miniFAVOR"},{"text":"private pure function check_not_backward_no_separator() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_backward_no_separator~2.html","title":"check_not_backward_no_separator – miniFAVOR"},{"text":"private pure function check_not_backward_no_separator_empty_set() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_backward_no_separator_empty_set~2.html","title":"check_not_backward_no_separator_empty_set – miniFAVOR"},{"text":"private pure function check_not_backward_no_separator_not_found() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_backward_no_separator_not_found~2.html","title":"check_not_backward_no_separator_not_found – miniFAVOR"},{"text":"private pure function check_not_backward_with_separator() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_backward_with_separator~2.html","title":"check_not_backward_with_separator – miniFAVOR"},{"text":"private pure function check_not_backward_with_separator_empty_set() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_backward_with_separator_empty_set~2.html","title":"check_not_backward_with_separator_empty_set – miniFAVOR"},{"text":"private pure function check_not_backward_with_separator_not_found() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_not_backward_with_separator_not_found~2.html","title":"check_not_backward_with_separator_not_found – miniFAVOR"},{"text":"public function test_lge() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_lge.html","title":"test_lge – miniFAVOR"},{"text":"private pure function check_character_lge_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_character_lge_string.html","title":"check_character_lge_string – miniFAVOR"},{"text":"private pure function check_string_lge_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_lge_character.html","title":"check_string_lge_character – miniFAVOR"},{"text":"private pure function check_string_lge_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_lge_string.html","title":"check_string_lge_string – miniFAVOR"},{"text":"public function test_index() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_index.html","title":"test_index – miniFAVOR"},{"text":"private pure function check_index_character_and_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_index_character_and_string.html","title":"check_index_character_and_string – miniFAVOR"},{"text":"private pure function check_index_string_and_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_index_string_and_character.html","title":"check_index_string_and_character – miniFAVOR"},{"text":"private pure function check_index_strings(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_index_strings.html","title":"check_index_strings – miniFAVOR"},{"text":"public function test_lgt() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_lgt.html","title":"test_lgt – miniFAVOR"},{"text":"private pure function check_character_lgt_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_character_lgt_string.html","title":"check_character_lgt_string – miniFAVOR"},{"text":"private pure function check_string_lgt_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_lgt_character.html","title":"check_string_lgt_character – miniFAVOR"},{"text":"private pure function check_string_lgt_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_lgt_string.html","title":"check_string_lgt_string – miniFAVOR"},{"text":"public function test_iachar() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_iachar.html","title":"test_iachar – miniFAVOR"},{"text":"private pure function check_iachar(char_) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: char_ Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_iachar.html","title":"check_iachar – miniFAVOR"},{"text":"public function test_char() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_char.html","title":"test_char – miniFAVOR"},{"text":"private pure function check_char_with_longer_length() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_char_with_longer_length.html","title":"check_char_with_longer_length – miniFAVOR"},{"text":"private pure function check_char_with_negative_length() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_char_with_negative_length.html","title":"check_char_with_negative_length – miniFAVOR"},{"text":"private pure function check_char_with_shorter_length() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_char_with_shorter_length.html","title":"check_char_with_shorter_length – miniFAVOR"},{"text":"private pure function check_char_with_zero_length() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_char_with_zero_length.html","title":"check_char_with_zero_length – miniFAVOR"},{"text":"private pure function check_char_without_length(example) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_char_without_length.html","title":"check_char_without_length – miniFAVOR"},{"text":"subroutine run() Uses adjustl_test adjustr_test assignment_test char_test concat_test equal_test extract_test greater_than_equal_test greater_than_test iachar_test ichar_test index_test insert_test len_test len_trim_test less_than_equal_test less_than_test lge_test lgt_test lle_test llt_test not_equal_test remove_test repeat_test replace_range_test replace_start_test replace_target_test scan_test split_character_set_test split_string_set_test trim_test var_str_test verify_test vegetables Arguments None Contents None","tags":"","loc":"proc/run~2.html","title":"run – miniFAVOR"},{"text":"public function test_repeat() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_repeat~2.html","title":"test_repeat – miniFAVOR"},{"text":"private pure function check_repeat(example) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_repeat~2.html","title":"check_repeat – miniFAVOR"},{"text":"public function test_extract_character() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_extract_character.html","title":"test_extract_character – miniFAVOR"},{"text":"public function test_extract_string() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_extract_string.html","title":"test_extract_string – miniFAVOR"},{"text":"private pure function check_extract_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_extract_character.html","title":"check_extract_character – miniFAVOR"},{"text":"private pure function check_extract_character_with_finish_gt_len_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_extract_character_with_finish_gt_len_string.html","title":"check_extract_character_with_finish_gt_len_string – miniFAVOR"},{"text":"private pure function check_extract_character_with_start_lt_one() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_extract_character_with_start_lt_one.html","title":"check_extract_character_with_start_lt_one – miniFAVOR"},{"text":"private pure function check_extract_character_without_finish() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_extract_character_without_finish.html","title":"check_extract_character_without_finish – miniFAVOR"},{"text":"private pure function check_extract_character_without_start() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_extract_character_without_start.html","title":"check_extract_character_without_start – miniFAVOR"},{"text":"private pure function check_extract_character_zero_length() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_extract_character_zero_length.html","title":"check_extract_character_zero_length – miniFAVOR"},{"text":"private pure function check_extract_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_extract_string.html","title":"check_extract_string – miniFAVOR"},{"text":"private pure function check_extract_string_with_finish_gt_len_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_extract_string_with_finish_gt_len_string.html","title":"check_extract_string_with_finish_gt_len_string – miniFAVOR"},{"text":"private pure function check_extract_string_with_start_lt_one() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_extract_string_with_start_lt_one.html","title":"check_extract_string_with_start_lt_one – miniFAVOR"},{"text":"private pure function check_extract_string_without_finish() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_extract_string_without_finish.html","title":"check_extract_string_without_finish – miniFAVOR"},{"text":"private pure function check_extract_string_without_start() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_extract_string_without_start.html","title":"check_extract_string_without_start – miniFAVOR"},{"text":"private pure function check_extract_string_zero_length() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_extract_string_zero_length.html","title":"check_extract_string_zero_length – miniFAVOR"},{"text":"public function test_len() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_len.html","title":"test_len – miniFAVOR"},{"text":"private pure function check_len(string) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_len.html","title":"check_len – miniFAVOR"},{"text":"public function test_replace_character_in_character_start() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_character_in_character_start.html","title":"test_replace_character_in_character_start – miniFAVOR"},{"text":"public function test_replace_character_in_string_start() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_character_in_string_start.html","title":"test_replace_character_in_string_start – miniFAVOR"},{"text":"public function test_replace_string_in_character_start() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_string_in_character_start.html","title":"test_replace_string_in_character_start – miniFAVOR"},{"text":"public function test_replace_string_in_string_start() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_string_in_string_start.html","title":"test_replace_string_in_string_start – miniFAVOR"},{"text":"private pure function check_replace_character_in_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_character.html","title":"check_replace_character_in_character – miniFAVOR"},{"text":"private pure function check_replace_character_in_character_after() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_character_after.html","title":"check_replace_character_in_character_after – miniFAVOR"},{"text":"private pure function check_replace_character_in_character_before() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_character_before.html","title":"check_replace_character_in_character_before – miniFAVOR"},{"text":"private pure function check_replace_character_in_character_overrun() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_character_overrun.html","title":"check_replace_character_in_character_overrun – miniFAVOR"},{"text":"private pure function check_replace_character_in_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_string.html","title":"check_replace_character_in_string – miniFAVOR"},{"text":"private pure function check_replace_character_in_string_after() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_string_after.html","title":"check_replace_character_in_string_after – miniFAVOR"},{"text":"private pure function check_replace_character_in_string_before() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_string_before.html","title":"check_replace_character_in_string_before – miniFAVOR"},{"text":"private pure function check_replace_character_in_string_overrun() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_string_overrun.html","title":"check_replace_character_in_string_overrun – miniFAVOR"},{"text":"private pure function check_replace_string_in_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_character.html","title":"check_replace_string_in_character – miniFAVOR"},{"text":"private pure function check_replace_string_in_character_after() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_character_after.html","title":"check_replace_string_in_character_after – miniFAVOR"},{"text":"private pure function check_replace_string_in_character_before() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_character_before.html","title":"check_replace_string_in_character_before – miniFAVOR"},{"text":"private pure function check_replace_string_in_character_overrun() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_character_overrun.html","title":"check_replace_string_in_character_overrun – miniFAVOR"},{"text":"private pure function check_replace_string_in_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_string.html","title":"check_replace_string_in_string – miniFAVOR"},{"text":"private pure function check_replace_string_in_string_after() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_string_after.html","title":"check_replace_string_in_string_after – miniFAVOR"},{"text":"private pure function check_replace_string_in_string_before() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_string_before.html","title":"check_replace_string_in_string_before – miniFAVOR"},{"text":"private pure function check_replace_string_in_string_overrun() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_string_overrun.html","title":"check_replace_string_in_string_overrun – miniFAVOR"},{"text":"public function test_replace_character_with_character_in_character() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_character_with_character_in_character.html","title":"test_replace_character_with_character_in_character – miniFAVOR"},{"text":"public function test_replace_character_with_character_in_string() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_character_with_character_in_string.html","title":"test_replace_character_with_character_in_string – miniFAVOR"},{"text":"public function test_replace_character_with_string_in_character() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_character_with_string_in_character.html","title":"test_replace_character_with_string_in_character – miniFAVOR"},{"text":"public function test_replace_character_with_string_in_string() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_character_with_string_in_string.html","title":"test_replace_character_with_string_in_string – miniFAVOR"},{"text":"public function test_replace_string_with_character_in_character() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_string_with_character_in_character.html","title":"test_replace_string_with_character_in_character – miniFAVOR"},{"text":"public function test_replace_string_with_character_in_string() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_string_with_character_in_string.html","title":"test_replace_string_with_character_in_string – miniFAVOR"},{"text":"public function test_replace_string_with_string_in_character() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_string_with_string_in_character.html","title":"test_replace_string_with_string_in_character – miniFAVOR"},{"text":"public function test_replace_string_with_string_in_string() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_string_with_string_in_string.html","title":"test_replace_string_with_string_in_string – miniFAVOR"},{"text":"private pure function check_replace_character_with_character_in_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_with_character_in_character.html","title":"check_replace_character_with_character_in_character – miniFAVOR"},{"text":"private pure function check_replace_character_with_character_in_character_backward() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_with_character_in_character_backward.html","title":"check_replace_character_with_character_in_character_backward – miniFAVOR"},{"text":"private pure function check_replace_character_with_character_in_character_every() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_with_character_in_character_every.html","title":"check_replace_character_with_character_in_character_every – miniFAVOR"},{"text":"private pure function check_replace_character_with_character_in_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_with_character_in_string.html","title":"check_replace_character_with_character_in_string – miniFAVOR"},{"text":"private pure function check_replace_character_with_character_in_string_backward() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_with_character_in_string_backward.html","title":"check_replace_character_with_character_in_string_backward – miniFAVOR"},{"text":"private pure function check_replace_character_with_character_in_string_every() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_with_character_in_string_every.html","title":"check_replace_character_with_character_in_string_every – miniFAVOR"},{"text":"private pure function check_replace_character_with_string_in_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_with_string_in_character.html","title":"check_replace_character_with_string_in_character – miniFAVOR"},{"text":"private pure function check_replace_character_with_string_in_character_backward() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_with_string_in_character_backward.html","title":"check_replace_character_with_string_in_character_backward – miniFAVOR"},{"text":"private pure function check_replace_character_with_string_in_character_every() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_with_string_in_character_every.html","title":"check_replace_character_with_string_in_character_every – miniFAVOR"},{"text":"private pure function check_replace_character_with_string_in_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_with_string_in_string.html","title":"check_replace_character_with_string_in_string – miniFAVOR"},{"text":"private pure function check_replace_character_with_string_in_string_backward() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_with_string_in_string_backward.html","title":"check_replace_character_with_string_in_string_backward – miniFAVOR"},{"text":"private pure function check_replace_character_with_string_in_string_every() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_with_string_in_string_every.html","title":"check_replace_character_with_string_in_string_every – miniFAVOR"},{"text":"private pure function check_replace_string_with_character_in_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_with_character_in_character.html","title":"check_replace_string_with_character_in_character – miniFAVOR"},{"text":"private pure function check_replace_string_with_character_in_character_backward() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_with_character_in_character_backward.html","title":"check_replace_string_with_character_in_character_backward – miniFAVOR"},{"text":"private pure function check_replace_string_with_character_in_character_every() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_with_character_in_character_every.html","title":"check_replace_string_with_character_in_character_every – miniFAVOR"},{"text":"private pure function check_replace_string_with_character_in_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_with_character_in_string.html","title":"check_replace_string_with_character_in_string – miniFAVOR"},{"text":"private pure function check_replace_string_with_character_in_string_backward() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_with_character_in_string_backward.html","title":"check_replace_string_with_character_in_string_backward – miniFAVOR"},{"text":"private pure function check_replace_string_with_character_in_string_every() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_with_character_in_string_every.html","title":"check_replace_string_with_character_in_string_every – miniFAVOR"},{"text":"private pure function check_replace_string_with_string_in_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_with_string_in_character.html","title":"check_replace_string_with_string_in_character – miniFAVOR"},{"text":"private pure function check_replace_string_with_string_in_character_backward() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_with_string_in_character_backward.html","title":"check_replace_string_with_string_in_character_backward – miniFAVOR"},{"text":"private pure function check_replace_string_with_string_in_character_every() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_with_string_in_character_every.html","title":"check_replace_string_with_string_in_character_every – miniFAVOR"},{"text":"private pure function check_replace_string_with_string_in_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_with_string_in_string.html","title":"check_replace_string_with_string_in_string – miniFAVOR"},{"text":"private pure function check_replace_string_with_string_in_string_backward() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_with_string_in_string_backward.html","title":"check_replace_string_with_string_in_string_backward – miniFAVOR"},{"text":"private pure function check_replace_string_with_string_in_string_every() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_with_string_in_string_every.html","title":"check_replace_string_with_string_in_string_every – miniFAVOR"},{"text":"public function test_greater_than_equals() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_greater_than_equals.html","title":"test_greater_than_equals – miniFAVOR"},{"text":"private pure function check_character_greater_than_equal_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_character_greater_than_equal_string.html","title":"check_character_greater_than_equal_string – miniFAVOR"},{"text":"private pure function check_string_greater_than_equal_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_greater_than_equal_character.html","title":"check_string_greater_than_equal_character – miniFAVOR"},{"text":"private pure function check_string_greater_than_equal_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_greater_than_equal_string.html","title":"check_string_greater_than_equal_string – miniFAVOR"},{"text":"public function test_greater_than() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_greater_than.html","title":"test_greater_than – miniFAVOR"},{"text":"private pure function check_character_greater_than_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_character_greater_than_string.html","title":"check_character_greater_than_string – miniFAVOR"},{"text":"private pure function check_string_greater_than_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_greater_than_character.html","title":"check_string_greater_than_character – miniFAVOR"},{"text":"private pure function check_string_greater_than_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_greater_than_string.html","title":"check_string_greater_than_string – miniFAVOR"},{"text":"public function test_concat() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents Source Code test_concat Source Code function test_concat () result ( tests ) use custom_generator , only : ASCII_STRING_PAIR_GENERATOR use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 3 ) individual_tests ( 1 ) = it ( & \"two strings\" , & ASCII_STRING_PAIR_GENERATOR , & check_concat_strings ) individual_tests ( 2 ) = it ( & \"a string and a character\" , & ASCII_STRING_PAIR_GENERATOR , & check_concat_string_and_character ) individual_tests ( 3 ) = it ( & \"a character and a string\" , & ASCII_STRING_PAIR_GENERATOR , & check_concat_character_and_string ) tests = describe ( & \"Sec. 3.3.2: operator(//) functions the same as for two characters for\" , & individual_tests ) end function test_concat","tags":"","loc":"proc/test_concat.html","title":"test_concat – miniFAVOR"},{"text":"private pure function check_concat_character_and_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_concat_character_and_string.html","title":"check_concat_character_and_string – miniFAVOR"},{"text":"private pure function check_concat_string_and_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_concat_string_and_character.html","title":"check_concat_string_and_character – miniFAVOR"},{"text":"private pure function check_concat_strings(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_concat_strings.html","title":"check_concat_strings – miniFAVOR"},{"text":"public function test_trim() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_trim.html","title":"test_trim – miniFAVOR"},{"text":"private pure function check_trim(string) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_trim.html","title":"check_trim – miniFAVOR"},{"text":"public function test_len_trim() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_len_trim.html","title":"test_len_trim – miniFAVOR"},{"text":"private pure function check_len_trim(string) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_len_trim.html","title":"check_len_trim – miniFAVOR"},{"text":"public function test_insert_character_into_character() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_insert_character_into_character.html","title":"test_insert_character_into_character – miniFAVOR"},{"text":"public function test_insert_character_into_string() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_insert_character_into_string.html","title":"test_insert_character_into_string – miniFAVOR"},{"text":"public function test_insert_string_into_character() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_insert_string_into_character.html","title":"test_insert_string_into_character – miniFAVOR"},{"text":"public function test_insert_string_into_string() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_insert_string_into_string.html","title":"test_insert_string_into_string – miniFAVOR"},{"text":"private pure function check_insert_character_into_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_insert_character_into_character.html","title":"check_insert_character_into_character – miniFAVOR"},{"text":"private pure function check_insert_character_into_character_at_beginning() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_insert_character_into_character_at_beginning.html","title":"check_insert_character_into_character_at_beginning – miniFAVOR"},{"text":"private pure function check_insert_character_into_character_at_end() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_insert_character_into_character_at_end.html","title":"check_insert_character_into_character_at_end – miniFAVOR"},{"text":"private pure function check_insert_character_into_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_insert_character_into_string.html","title":"check_insert_character_into_string – miniFAVOR"},{"text":"private pure function check_insert_character_into_string_at_beginning() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_insert_character_into_string_at_beginning.html","title":"check_insert_character_into_string_at_beginning – miniFAVOR"},{"text":"private pure function check_insert_character_into_string_at_end() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_insert_character_into_string_at_end.html","title":"check_insert_character_into_string_at_end – miniFAVOR"},{"text":"private pure function check_insert_string_into_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_insert_string_into_character.html","title":"check_insert_string_into_character – miniFAVOR"},{"text":"private pure function check_insert_string_into_character_at_beginning() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_insert_string_into_character_at_beginning.html","title":"check_insert_string_into_character_at_beginning – miniFAVOR"},{"text":"private pure function check_insert_string_into_character_at_end() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_insert_string_into_character_at_end.html","title":"check_insert_string_into_character_at_end – miniFAVOR"},{"text":"private pure function check_insert_string_into_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_insert_string_into_string.html","title":"check_insert_string_into_string – miniFAVOR"},{"text":"private pure function check_insert_string_into_string_at_beginning() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_insert_string_into_string_at_beginning.html","title":"check_insert_string_into_string_at_beginning – miniFAVOR"},{"text":"private pure function check_insert_string_into_string_at_end() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_insert_string_into_string_at_end.html","title":"check_insert_string_into_string_at_end – miniFAVOR"},{"text":"public function test_scan() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_scan.html","title":"test_scan – miniFAVOR"},{"text":"private pure function check_scan_character_and_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_scan_character_and_string.html","title":"check_scan_character_and_string – miniFAVOR"},{"text":"private pure function check_scan_string_and_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_scan_string_and_character.html","title":"check_scan_string_and_character – miniFAVOR"},{"text":"private pure function check_scan_strings(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_scan_strings.html","title":"check_scan_strings – miniFAVOR"},{"text":"public function test_less_than_equals() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_less_than_equals.html","title":"test_less_than_equals – miniFAVOR"},{"text":"private pure function check_character_less_than_equal_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_character_less_than_equal_string.html","title":"check_character_less_than_equal_string – miniFAVOR"},{"text":"private pure function check_string_less_than_equal_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_less_than_equal_character.html","title":"check_string_less_than_equal_character – miniFAVOR"},{"text":"private pure function check_string_less_than_equal_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_less_than_equal_string.html","title":"check_string_less_than_equal_string – miniFAVOR"},{"text":"public function test_assignment() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_assignment.html","title":"test_assignment – miniFAVOR"},{"text":"private pure function check_assign_character_to_string(string) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_assign_character_to_string.html","title":"check_assign_character_to_string – miniFAVOR"},{"text":"private pure function check_assign_string_to_string(string) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_assign_string_to_string.html","title":"check_assign_string_to_string – miniFAVOR"},{"text":"private pure function check_assign_to_longer_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_assign_to_longer_character.html","title":"check_assign_to_longer_character – miniFAVOR"},{"text":"private pure function check_assign_to_shorter_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_assign_to_shorter_character.html","title":"check_assign_to_shorter_character – miniFAVOR"},{"text":"public function test_ichar() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_ichar.html","title":"test_ichar – miniFAVOR"},{"text":"private pure function check_ichar(char_) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: char_ Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_ichar.html","title":"check_ichar – miniFAVOR"},{"text":"public function test_lle() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_lle.html","title":"test_lle – miniFAVOR"},{"text":"private pure function check_character_lle_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_character_lle_string.html","title":"check_character_lle_string – miniFAVOR"},{"text":"private pure function check_string_lle_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_lle_character.html","title":"check_string_lle_character – miniFAVOR"},{"text":"private pure function check_string_lle_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_lle_string.html","title":"check_string_lle_string – miniFAVOR"},{"text":"public function test_less_than() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_less_than.html","title":"test_less_than – miniFAVOR"},{"text":"private pure function check_character_less_than_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_character_less_than_string.html","title":"check_character_less_than_string – miniFAVOR"},{"text":"private pure function check_string_less_than_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_less_than_character.html","title":"check_string_less_than_character – miniFAVOR"},{"text":"private pure function check_string_less_than_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_less_than_string.html","title":"check_string_less_than_string – miniFAVOR"},{"text":"public function test_remove_character() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_remove_character.html","title":"test_remove_character – miniFAVOR"},{"text":"public function test_remove_string() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_remove_string.html","title":"test_remove_string – miniFAVOR"},{"text":"private pure function check_remove_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_remove_character.html","title":"check_remove_character – miniFAVOR"},{"text":"private pure function check_remove_character_with_finish_gt_len_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_remove_character_with_finish_gt_len_string.html","title":"check_remove_character_with_finish_gt_len_string – miniFAVOR"},{"text":"private pure function check_remove_character_with_start_lt_one() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_remove_character_with_start_lt_one.html","title":"check_remove_character_with_start_lt_one – miniFAVOR"},{"text":"private pure function check_remove_character_without_finish() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_remove_character_without_finish.html","title":"check_remove_character_without_finish – miniFAVOR"},{"text":"private pure function check_remove_character_without_start() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_remove_character_without_start.html","title":"check_remove_character_without_start – miniFAVOR"},{"text":"private pure function check_remove_character_zero_length() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_remove_character_zero_length.html","title":"check_remove_character_zero_length – miniFAVOR"},{"text":"private pure function check_remove_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_remove_string.html","title":"check_remove_string – miniFAVOR"},{"text":"private pure function check_remove_string_with_finish_gt_len_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_remove_string_with_finish_gt_len_string.html","title":"check_remove_string_with_finish_gt_len_string – miniFAVOR"},{"text":"private pure function check_remove_string_with_start_lt_one() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_remove_string_with_start_lt_one.html","title":"check_remove_string_with_start_lt_one – miniFAVOR"},{"text":"private pure function check_remove_string_without_finish() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_remove_string_without_finish.html","title":"check_remove_string_without_finish – miniFAVOR"},{"text":"private pure function check_remove_string_without_start() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_remove_string_without_start.html","title":"check_remove_string_without_start – miniFAVOR"},{"text":"private pure function check_remove_string_zero_length() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_remove_string_zero_length.html","title":"check_remove_string_zero_length – miniFAVOR"},{"text":"public function test_verify() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_verify.html","title":"test_verify – miniFAVOR"},{"text":"private pure function check_verify_character_and_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verify_character_and_string.html","title":"check_verify_character_and_string – miniFAVOR"},{"text":"private pure function check_verify_string_and_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verify_string_and_character.html","title":"check_verify_string_and_character – miniFAVOR"},{"text":"private pure function check_verify_strings(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verify_strings.html","title":"check_verify_strings – miniFAVOR"},{"text":"public function test_equals() result(tests) Uses custom_generator vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_equals.html","title":"test_equals – miniFAVOR"},{"text":"private pure function check_character_equal_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_character_equal_string.html","title":"check_character_equal_string – miniFAVOR"},{"text":"private pure function check_string_equal_character(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_equal_character.html","title":"check_string_equal_character – miniFAVOR"},{"text":"private pure function check_string_equal_string(strings) result(result_) Uses custom_generator iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_string_equal_string.html","title":"check_string_equal_string – miniFAVOR"},{"text":"public function test_replace_character_in_character_range() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_character_in_character_range.html","title":"test_replace_character_in_character_range – miniFAVOR"},{"text":"public function test_replace_character_in_string_range() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_character_in_string_range.html","title":"test_replace_character_in_string_range – miniFAVOR"},{"text":"public function test_replace_string_in_character_range() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_string_in_character_range.html","title":"test_replace_string_in_character_range – miniFAVOR"},{"text":"public function test_replace_string_in_string_range() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_replace_string_in_string_range.html","title":"test_replace_string_in_string_range – miniFAVOR"},{"text":"private pure function check_replace_character_in_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_character~2.html","title":"check_replace_character_in_character – miniFAVOR"},{"text":"private pure function check_replace_character_in_character_start_gt_end() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_character_start_gt_end.html","title":"check_replace_character_in_character_start_gt_end – miniFAVOR"},{"text":"private pure function check_replace_character_in_character_start_gt_finish() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_character_start_gt_finish.html","title":"check_replace_character_in_character_start_gt_finish – miniFAVOR"},{"text":"private pure function check_replace_character_in_character_start_lt_one() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_character_start_lt_one.html","title":"check_replace_character_in_character_start_lt_one – miniFAVOR"},{"text":"private pure function check_replace_character_in_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_string~2.html","title":"check_replace_character_in_string – miniFAVOR"},{"text":"private pure function check_replace_character_in_string_start_gt_end() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_string_start_gt_end.html","title":"check_replace_character_in_string_start_gt_end – miniFAVOR"},{"text":"private pure function check_replace_character_in_string_start_gt_finish() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_string_start_gt_finish.html","title":"check_replace_character_in_string_start_gt_finish – miniFAVOR"},{"text":"private pure function check_replace_character_in_string_start_lt_one() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_character_in_string_start_lt_one.html","title":"check_replace_character_in_string_start_lt_one – miniFAVOR"},{"text":"private pure function check_replace_string_in_character() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_character~2.html","title":"check_replace_string_in_character – miniFAVOR"},{"text":"private pure function check_replace_string_in_character_start_gt_end() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_character_start_gt_end.html","title":"check_replace_string_in_character_start_gt_end – miniFAVOR"},{"text":"private pure function check_replace_string_in_character_start_gt_finish() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_character_start_gt_finish.html","title":"check_replace_string_in_character_start_gt_finish – miniFAVOR"},{"text":"private pure function check_replace_string_in_character_start_lt_one() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_character_start_lt_one.html","title":"check_replace_string_in_character_start_lt_one – miniFAVOR"},{"text":"private pure function check_replace_string_in_string() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_string~2.html","title":"check_replace_string_in_string – miniFAVOR"},{"text":"private pure function check_replace_string_in_string_start_gt_end() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_string_start_gt_end.html","title":"check_replace_string_in_string_start_gt_end – miniFAVOR"},{"text":"private pure function check_replace_string_in_string_start_gt_finish() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_string_start_gt_finish.html","title":"check_replace_string_in_string_start_gt_finish – miniFAVOR"},{"text":"private pure function check_replace_string_in_string_start_lt_one() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_replace_string_in_string_start_lt_one.html","title":"check_replace_string_in_string_start_lt_one – miniFAVOR"},{"text":"public function test_var_str() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_var_str.html","title":"test_var_str – miniFAVOR"},{"text":"private pure function check_var_str(string) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_var_str.html","title":"check_var_str – miniFAVOR"},{"text":"public function test_adjustl() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_adjustl.html","title":"test_adjustl – miniFAVOR"},{"text":"private pure function check_adjustl(string) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_adjustl.html","title":"check_adjustl – miniFAVOR"},{"text":"public elemental function var_str(char) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: char Return Value type( varying_string ) Contents None","tags":"","loc":"proc/var_str.html","title":"var_str – miniFAVOR"},{"text":"private elemental function character_eq_string(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/character_eq_string.html","title":"character_eq_string – miniFAVOR"},{"text":"private elemental function character_ge_string(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/character_ge_string.html","title":"character_ge_string – miniFAVOR"},{"text":"private elemental function character_gt_string(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/character_gt_string.html","title":"character_gt_string – miniFAVOR"},{"text":"private elemental function character_index_string(string, substring, back) result(position) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/character_index_string.html","title":"character_index_string – miniFAVOR"},{"text":"private elemental function character_le_string(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/character_le_string.html","title":"character_le_string – miniFAVOR"},{"text":"private elemental function character_lge_string(string_a, string_b) result(greater_than_or_equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical Contents None","tags":"","loc":"proc/character_lge_string.html","title":"character_lge_string – miniFAVOR"},{"text":"private elemental function character_lgt_string(string_a, string_b) result(greater_than) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical Contents None","tags":"","loc":"proc/character_lgt_string.html","title":"character_lgt_string – miniFAVOR"},{"text":"private elemental function character_lle_string(string_a, string_b) result(less_than_or_equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical Contents None","tags":"","loc":"proc/character_lle_string.html","title":"character_lle_string – miniFAVOR"},{"text":"private elemental function character_llt_string(string_a, string_b) result(less_than) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical Contents None","tags":"","loc":"proc/character_llt_string.html","title":"character_llt_string – miniFAVOR"},{"text":"private elemental function character_lt_string(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/character_lt_string.html","title":"character_lt_string – miniFAVOR"},{"text":"private elemental function character_ne_string(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/character_ne_string.html","title":"character_ne_string – miniFAVOR"},{"text":"private elemental function character_scan_string(string, set, back) result(position) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/character_scan_string.html","title":"character_scan_string – miniFAVOR"},{"text":"private elemental function character_verify_string(string, set, back) result(position) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/character_verify_string.html","title":"character_verify_string – miniFAVOR"},{"text":"private elemental function concat_character_and_string(lhs, rhs) result(concatenated) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value type( varying_string ) Contents None","tags":"","loc":"proc/concat_character_and_string.html","title":"concat_character_and_string – miniFAVOR"},{"text":"private elemental function concat_string_and_character(lhs, rhs) result(concatenated) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( varying_string ) Contents None","tags":"","loc":"proc/concat_string_and_character.html","title":"concat_string_and_character – miniFAVOR"},{"text":"private elemental function concat_strings(lhs, rhs) result(concatenated) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value type( varying_string ) Contents None","tags":"","loc":"proc/concat_strings.html","title":"concat_strings – miniFAVOR"},{"text":"private elemental function extract_character(string, start, finish) result(extracted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) Contents None","tags":"","loc":"proc/extract_character.html","title":"extract_character – miniFAVOR"},{"text":"private elemental function extract_string(string, start, finish) result(extracted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) Contents None","tags":"","loc":"proc/extract_string.html","title":"extract_string – miniFAVOR"},{"text":"private elemental function insert_character_into_character(string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) Contents None","tags":"","loc":"proc/insert_character_into_character.html","title":"insert_character_into_character – miniFAVOR"},{"text":"private elemental function insert_character_into_string(string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) Contents None","tags":"","loc":"proc/insert_character_into_string.html","title":"insert_character_into_string – miniFAVOR"},{"text":"private elemental function insert_string_into_character(string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) Contents None","tags":"","loc":"proc/insert_string_into_character.html","title":"insert_string_into_character – miniFAVOR"},{"text":"private elemental function insert_string_into_string(string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) Contents None","tags":"","loc":"proc/insert_string_into_string.html","title":"insert_string_into_string – miniFAVOR"},{"text":"private elemental function len_string(string) result(length) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value integer Contents None","tags":"","loc":"proc/len_string.html","title":"len_string – miniFAVOR"},{"text":"private elemental function len_trim_string(string) result(length) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value integer Contents None","tags":"","loc":"proc/len_trim_string.html","title":"len_trim_string – miniFAVOR"},{"text":"private elemental function remove_character(string, start, finish) result(removed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) Contents None","tags":"","loc":"proc/remove_character.html","title":"remove_character – miniFAVOR"},{"text":"private elemental function remove_string(string, start, finish) result(removed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) Contents None","tags":"","loc":"proc/remove_string.html","title":"remove_string – miniFAVOR"},{"text":"private elemental function replace_character_with_character_range(string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish character(len=*), intent(in) :: substring Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_character_with_character_range.html","title":"replace_character_with_character_range – miniFAVOR"},{"text":"private elemental function replace_character_with_character_start(string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_character_with_character_start.html","title":"replace_character_with_character_start – miniFAVOR"},{"text":"private elemental function replace_character_with_string_range(string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish type( varying_string ), intent(in) :: substring Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_character_with_string_range.html","title":"replace_character_with_string_range – miniFAVOR"},{"text":"private elemental function replace_character_with_string_start(string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_character_with_string_start.html","title":"replace_character_with_string_start – miniFAVOR"},{"text":"private elemental function replace_string_with_character_range(string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish character(len=*), intent(in) :: substring Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_string_with_character_range.html","title":"replace_string_with_character_range – miniFAVOR"},{"text":"private elemental function replace_string_with_character_start(string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_string_with_character_start.html","title":"replace_string_with_character_start – miniFAVOR"},{"text":"private elemental function replace_string_with_string_range(string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish type( varying_string ), intent(in) :: substring Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_string_with_string_range.html","title":"replace_string_with_string_range – miniFAVOR"},{"text":"private elemental function replace_string_with_string_start(string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_string_with_string_start.html","title":"replace_string_with_string_start – miniFAVOR"},{"text":"private elemental function replace_target_character_with_character_in_character(string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) Contents Source Code replace_target_character_with_character_in_character Source Code elemental function replace_target_character_with_character_in_character ( & string , target , substring , every , back ) result ( replaced ) ! Sec. 3.7.4 character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: target character ( len =* ), intent ( in ) :: substring logical , optional , intent ( in ) :: every logical , optional , intent ( in ) :: back type ( varying_string ) :: replaced logical :: back_ logical :: every_ if ( present ( back )) then back_ = back else back_ = . false . end if if ( present ( every )) then every_ = every else every_ = . false . end if replaced = recursive_replace ( string ) contains pure recursive function recursive_replace ( string_ ) result ( replaced_ ) character ( len =* ), intent ( in ) :: string_ type ( varying_string ) :: replaced_ integer :: position position = index ( string_ , target , back_ ) if ( position /= 0 ) then if ( every_ ) then if ( back_ ) then replaced_ = & recursive_replace ( string_ ( 1 : position - 1 )) & // substring & // string_ ( position + len ( target ):) else replaced_ = & string_ ( 1 : position - 1 ) & // substring & // recursive_replace ( string_ ( position + len ( target ):)) end if else replaced_ = replace ( & string_ , position , position + len ( target ) - 1 , substring ) end if else replaced_ = string_ end if end function end function replace_target_character_with_character_in_character","tags":"","loc":"proc/replace_target_character_with_character_in_character.html","title":"replace_target_character_with_character_in_character – miniFAVOR"},{"text":"private elemental function replace_target_character_with_character_in_string(string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_target_character_with_character_in_string.html","title":"replace_target_character_with_character_in_string – miniFAVOR"},{"text":"private elemental function replace_target_character_with_string_in_character(string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_target_character_with_string_in_character.html","title":"replace_target_character_with_string_in_character – miniFAVOR"},{"text":"private elemental function replace_target_character_with_string_in_string(string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_target_character_with_string_in_string.html","title":"replace_target_character_with_string_in_string – miniFAVOR"},{"text":"private elemental function replace_target_string_with_character_in_character(string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_target_string_with_character_in_character.html","title":"replace_target_string_with_character_in_character – miniFAVOR"},{"text":"private elemental function replace_target_string_with_character_in_string(string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_target_string_with_character_in_string.html","title":"replace_target_string_with_character_in_string – miniFAVOR"},{"text":"private elemental function replace_target_string_with_string_in_character(string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_target_string_with_string_in_character.html","title":"replace_target_string_with_string_in_character – miniFAVOR"},{"text":"private elemental function replace_target_string_with_string_in_string(string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) Contents None","tags":"","loc":"proc/replace_target_string_with_string_in_string.html","title":"replace_target_string_with_string_in_string – miniFAVOR"},{"text":"private elemental function string_adjustl(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/string_adjustl.html","title":"string_adjustl – miniFAVOR"},{"text":"private elemental function string_adjustr(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/string_adjustr.html","title":"string_adjustr – miniFAVOR"},{"text":"private elemental function string_eq_character(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/string_eq_character.html","title":"string_eq_character – miniFAVOR"},{"text":"private elemental function string_eq_string(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/string_eq_string.html","title":"string_eq_string – miniFAVOR"},{"text":"private elemental function string_ge_character(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/string_ge_character.html","title":"string_ge_character – miniFAVOR"},{"text":"private elemental function string_ge_string(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/string_ge_string.html","title":"string_ge_string – miniFAVOR"},{"text":"private elemental function string_gt_character(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/string_gt_character.html","title":"string_gt_character – miniFAVOR"},{"text":"private elemental function string_gt_string(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/string_gt_string.html","title":"string_gt_string – miniFAVOR"},{"text":"private elemental function string_iachar(c) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: c Return Value integer Contents None","tags":"","loc":"proc/string_iachar.html","title":"string_iachar – miniFAVOR"},{"text":"private elemental function string_ichar(c) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: c Return Value integer Contents None","tags":"","loc":"proc/string_ichar.html","title":"string_ichar – miniFAVOR"},{"text":"private elemental function string_index_character(string, substring, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/string_index_character.html","title":"string_index_character – miniFAVOR"},{"text":"private elemental function string_index_string(string, substring, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/string_index_string.html","title":"string_index_string – miniFAVOR"},{"text":"private elemental function string_le_character(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/string_le_character.html","title":"string_le_character – miniFAVOR"},{"text":"private elemental function string_le_string(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/string_le_string.html","title":"string_le_string – miniFAVOR"},{"text":"private elemental function string_lge_character(string_a, string_b) result(greater_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical Contents None","tags":"","loc":"proc/string_lge_character.html","title":"string_lge_character – miniFAVOR"},{"text":"private elemental function string_lge_string(string_a, string_b) result(greater_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical Contents None","tags":"","loc":"proc/string_lge_string.html","title":"string_lge_string – miniFAVOR"},{"text":"private elemental function string_lgt_character(string_a, string_b) result(greater_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical Contents None","tags":"","loc":"proc/string_lgt_character.html","title":"string_lgt_character – miniFAVOR"},{"text":"private elemental function string_lgt_string(string_a, string_b) result(greater_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical Contents None","tags":"","loc":"proc/string_lgt_string.html","title":"string_lgt_string – miniFAVOR"},{"text":"private elemental function string_lle_character(string_a, string_b) result(less_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical Contents None","tags":"","loc":"proc/string_lle_character.html","title":"string_lle_character – miniFAVOR"},{"text":"private elemental function string_lle_string(string_a, string_b) result(less_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical Contents None","tags":"","loc":"proc/string_lle_string.html","title":"string_lle_string – miniFAVOR"},{"text":"private elemental function string_llt_character(string_a, string_b) result(less_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical Contents None","tags":"","loc":"proc/string_llt_character.html","title":"string_llt_character – miniFAVOR"},{"text":"private elemental function string_llt_string(string_a, string_b) result(less_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical Contents None","tags":"","loc":"proc/string_llt_string.html","title":"string_llt_string – miniFAVOR"},{"text":"private elemental function string_lt_character(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/string_lt_character.html","title":"string_lt_character – miniFAVOR"},{"text":"private elemental function string_lt_string(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/string_lt_string.html","title":"string_lt_string – miniFAVOR"},{"text":"private elemental function string_ne_character(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/string_ne_character.html","title":"string_ne_character – miniFAVOR"},{"text":"private elemental function string_ne_string(lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/string_ne_string.html","title":"string_ne_string – miniFAVOR"},{"text":"private elemental function string_repeat(string, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( varying_string ) Contents None","tags":"","loc":"proc/string_repeat.html","title":"string_repeat – miniFAVOR"},{"text":"private elemental function string_scan_character(string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/string_scan_character.html","title":"string_scan_character – miniFAVOR"},{"text":"private elemental function string_scan_string(string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/string_scan_string.html","title":"string_scan_string – miniFAVOR"},{"text":"private pure function string_to_char(string) result(chars) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/string_to_char.html","title":"string_to_char – miniFAVOR"},{"text":"private pure function string_to_char_with_length(string, length) result(chars) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: length Return Value character(len=length) Contents None","tags":"","loc":"proc/string_to_char_with_length.html","title":"string_to_char_with_length – miniFAVOR"},{"text":"private elemental function string_verify_character(string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/string_verify_character.html","title":"string_verify_character – miniFAVOR"},{"text":"private elemental function string_verify_string(string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Contents None","tags":"","loc":"proc/string_verify_string.html","title":"string_verify_string – miniFAVOR"},{"text":"private elemental function trim_string(string) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/trim_string.html","title":"trim_string – miniFAVOR"},{"text":"private elemental subroutine assign_character_to_string(lhs, rhs) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: lhs character(len=*), intent(in) :: rhs Contents None","tags":"","loc":"proc/assign_character_to_string.html","title":"assign_character_to_string – miniFAVOR"},{"text":"private elemental subroutine assign_string_to_character(lhs, rhs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: lhs type( varying_string ), intent(in) :: rhs Contents None","tags":"","loc":"proc/assign_string_to_character.html","title":"assign_string_to_character – miniFAVOR"},{"text":"private subroutine get_default_unit_to_end_of_record(string, maxlen, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: string integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/get_default_unit_to_end_of_record.html","title":"get_default_unit_to_end_of_record – miniFAVOR"},{"text":"private subroutine get_default_unit_to_terminator_characters(string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: string character(len=*), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/get_default_unit_to_terminator_characters.html","title":"get_default_unit_to_terminator_characters – miniFAVOR"},{"text":"private subroutine get_default_unit_to_terminator_string(string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: string type( varying_string ), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/get_default_unit_to_terminator_string.html","title":"get_default_unit_to_terminator_string – miniFAVOR"},{"text":"private subroutine get_with_unit_to_end_of_record(unit, string, maxlen, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(out) :: string integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/get_with_unit_to_end_of_record.html","title":"get_with_unit_to_end_of_record – miniFAVOR"},{"text":"private subroutine get_with_unit_to_terminator_characters(unit, string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(out) :: string character(len=*), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/get_with_unit_to_terminator_characters.html","title":"get_with_unit_to_terminator_characters – miniFAVOR"},{"text":"private subroutine get_with_unit_to_terminator_string(unit, string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(out) :: string type( varying_string ), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/get_with_unit_to_terminator_string.html","title":"get_with_unit_to_terminator_string – miniFAVOR"},{"text":"private subroutine put_characters_default_unit(string, iostat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/put_characters_default_unit.html","title":"put_characters_default_unit – miniFAVOR"},{"text":"private subroutine put_characters_with_unit(unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=*), intent(in) :: string integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/put_characters_with_unit.html","title":"put_characters_with_unit – miniFAVOR"},{"text":"private subroutine put_line_characters_default_unit(string, iostat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/put_line_characters_default_unit.html","title":"put_line_characters_default_unit – miniFAVOR"},{"text":"private subroutine put_line_characters_with_unit(unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=*), intent(in) :: string integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/put_line_characters_with_unit.html","title":"put_line_characters_with_unit – miniFAVOR"},{"text":"private subroutine put_line_string_default_unit(string, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/put_line_string_default_unit.html","title":"put_line_string_default_unit – miniFAVOR"},{"text":"private subroutine put_line_string_with_unit(unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/put_line_string_with_unit.html","title":"put_line_string_with_unit – miniFAVOR"},{"text":"private subroutine put_string_default_unit(string, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/put_string_default_unit.html","title":"put_string_default_unit – miniFAVOR"},{"text":"private subroutine put_string_with_unit(unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat Contents None","tags":"","loc":"proc/put_string_with_unit.html","title":"put_string_with_unit – miniFAVOR"},{"text":"private elemental subroutine split_character(string, word, set, separator, back) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(inout) :: string type( varying_string ), intent(out) :: word character(len=*), intent(in) :: set type( varying_string ), intent(out), optional :: separator logical, intent(in), optional :: back Contents None","tags":"","loc":"proc/split_character.html","title":"split_character – miniFAVOR"},{"text":"private elemental subroutine split_string(string, word, set, separator, back) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(inout) :: string type( varying_string ), intent(out) :: word type( varying_string ), intent(in) :: set type( varying_string ), intent(out), optional :: separator logical, intent(in), optional :: back Contents None","tags":"","loc":"proc/split_string.html","title":"split_string – miniFAVOR"},{"text":"public interface adjustl Contents Module Procedures string_adjustl Module Procedures private elemental function string_adjustl (string) result(adjusted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string )","tags":"","loc":"interface/adjustl.html","title":"adjustl – miniFAVOR"},{"text":"public interface adjustr Contents Module Procedures string_adjustr Module Procedures private elemental function string_adjustr (string) result(adjusted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string )","tags":"","loc":"interface/adjustr.html","title":"adjustr – miniFAVOR"},{"text":"public interface assignment(=) Contents Module Procedures assign_character_to_string assign_string_to_character Module Procedures private elemental subroutine assign_character_to_string (lhs, rhs) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: lhs character(len=*), intent(in) :: rhs private elemental subroutine assign_string_to_character (lhs, rhs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: lhs type( varying_string ), intent(in) :: rhs","tags":"","loc":"interface/assignment(=).html","title":"assignment(=) – miniFAVOR"},{"text":"public interface char Contents Module Procedures string_to_char string_to_char_with_length Module Procedures private pure function string_to_char (string) result(chars) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value character(len=:),\n  allocatable private pure function string_to_char_with_length (string, length) result(chars) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: length Return Value character(len=length)","tags":"","loc":"interface/char.html","title":"char – miniFAVOR"},{"text":"public interface extract Contents Module Procedures extract_character extract_string Module Procedures private elemental function extract_character (string, start, finish) result(extracted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) private elemental function extract_string (string, start, finish) result(extracted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string )","tags":"","loc":"interface/extract.html","title":"extract – miniFAVOR"},{"text":"public interface get Contents Module Procedures get_default_unit_to_end_of_record get_with_unit_to_end_of_record get_default_unit_to_terminator_string get_with_unit_to_terminator_string get_default_unit_to_terminator_characters get_with_unit_to_terminator_characters Module Procedures private subroutine get_default_unit_to_end_of_record (string, maxlen, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: string integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_with_unit_to_end_of_record (unit, string, maxlen, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(out) :: string integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_default_unit_to_terminator_string (string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: string type( varying_string ), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_with_unit_to_terminator_string (unit, string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(out) :: string type( varying_string ), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_default_unit_to_terminator_characters (string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: string character(len=*), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_with_unit_to_terminator_characters (unit, string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(out) :: string character(len=*), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat","tags":"","loc":"interface/get.html","title":"get – miniFAVOR"},{"text":"public interface iachar Contents Module Procedures string_iachar Module Procedures private elemental function string_iachar (c) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: c Return Value integer","tags":"","loc":"interface/iachar.html","title":"iachar – miniFAVOR"},{"text":"public interface ichar Contents Module Procedures string_ichar Module Procedures private elemental function string_ichar (c) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: c Return Value integer","tags":"","loc":"interface/ichar.html","title":"ichar – miniFAVOR"},{"text":"public interface index Contents Module Procedures string_index_string string_index_character character_index_string Module Procedures private elemental function string_index_string (string, substring, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function string_index_character (string, substring, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function character_index_string (string, substring, back) result(position) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer","tags":"","loc":"interface/index.html","title":"index – miniFAVOR"},{"text":"public interface insert Contents Module Procedures insert_character_into_character insert_character_into_string insert_string_into_character insert_string_into_string Module Procedures private elemental function insert_character_into_character (string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function insert_character_into_string (string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function insert_string_into_character (string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function insert_string_into_string (string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string )","tags":"","loc":"interface/insert.html","title":"insert – miniFAVOR"},{"text":"public interface len Contents Module Procedures len_string Module Procedures private elemental function len_string (string) result(length) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value integer","tags":"","loc":"interface/len.html","title":"len – miniFAVOR"},{"text":"public interface len_trim Contents Module Procedures len_trim_string Module Procedures private elemental function len_trim_string (string) result(length) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value integer","tags":"","loc":"interface/len_trim.html","title":"len_trim – miniFAVOR"},{"text":"public interface lge Contents Module Procedures string_lge_string character_lge_string string_lge_character Module Procedures private elemental function string_lge_string (string_a, string_b) result(greater_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function character_lge_string (string_a, string_b) result(greater_than_or_equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function string_lge_character (string_a, string_b) result(greater_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical","tags":"","loc":"interface/lge.html","title":"lge – miniFAVOR"},{"text":"public interface lgt Contents Module Procedures string_lgt_string character_lgt_string string_lgt_character Module Procedures private elemental function string_lgt_string (string_a, string_b) result(greater_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function character_lgt_string (string_a, string_b) result(greater_than) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function string_lgt_character (string_a, string_b) result(greater_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical","tags":"","loc":"interface/lgt.html","title":"lgt – miniFAVOR"},{"text":"public interface lle Contents Module Procedures string_lle_string character_lle_string string_lle_character Module Procedures private elemental function string_lle_string (string_a, string_b) result(less_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function character_lle_string (string_a, string_b) result(less_than_or_equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function string_lle_character (string_a, string_b) result(less_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical","tags":"","loc":"interface/lle.html","title":"lle – miniFAVOR"},{"text":"public interface llt Contents Module Procedures string_llt_string character_llt_string string_llt_character Module Procedures private elemental function string_llt_string (string_a, string_b) result(less_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function character_llt_string (string_a, string_b) result(less_than) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function string_llt_character (string_a, string_b) result(less_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical","tags":"","loc":"interface/llt.html","title":"llt – miniFAVOR"},{"text":"public interface operator(//) Contents Module Procedures concat_strings concat_string_and_character concat_character_and_string Module Procedures private elemental function concat_strings (lhs, rhs) result(concatenated) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value type( varying_string ) private elemental function concat_string_and_character (lhs, rhs) result(concatenated) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( varying_string ) private elemental function concat_character_and_string (lhs, rhs) result(concatenated) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value type( varying_string )","tags":"","loc":"interface/operator(SLASHSLASH).html","title":"operator(//) – miniFAVOR"},{"text":"public interface operator(/=) Contents Module Procedures string_ne_string character_ne_string string_ne_character Module Procedures private elemental function string_ne_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_ne_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_ne_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(SLASH=).html","title":"operator(/=) – miniFAVOR"},{"text":"public interface operator(<) Contents Module Procedures string_lt_string character_lt_string string_lt_character Module Procedures private elemental function string_lt_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_lt_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_lt_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(lt).html","title":"operator(<) – miniFAVOR"},{"text":"public interface operator(<=) Contents Module Procedures string_le_string character_le_string string_le_character Module Procedures private elemental function string_le_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_le_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_le_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(lt=).html","title":"operator(<=) – miniFAVOR"},{"text":"public interface operator(==) Contents Module Procedures string_eq_string character_eq_string string_eq_character Module Procedures private elemental function string_eq_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_eq_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_eq_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(==).html","title":"operator(==) – miniFAVOR"},{"text":"public interface operator(>) Contents Module Procedures string_gt_string character_gt_string string_gt_character Module Procedures private elemental function string_gt_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_gt_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_gt_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(gt).html","title":"operator(>) – miniFAVOR"},{"text":"public interface operator(>=) Contents Module Procedures string_ge_string character_ge_string string_ge_character Module Procedures private elemental function string_ge_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_ge_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_ge_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(gt=).html","title":"operator(>=) – miniFAVOR"},{"text":"public interface put Contents Module Procedures put_string_default_unit put_string_with_unit put_characters_default_unit put_characters_with_unit Module Procedures private subroutine put_string_default_unit (string, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_string_with_unit (unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_characters_default_unit (string, iostat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_characters_with_unit (unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=*), intent(in) :: string integer, intent(out), optional :: iostat","tags":"","loc":"interface/put.html","title":"put – miniFAVOR"},{"text":"public interface put_line Contents Module Procedures put_line_string_default_unit put_line_string_with_unit put_line_characters_default_unit put_line_characters_with_unit Module Procedures private subroutine put_line_string_default_unit (string, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_line_string_with_unit (unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_line_characters_default_unit (string, iostat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_line_characters_with_unit (unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=*), intent(in) :: string integer, intent(out), optional :: iostat","tags":"","loc":"interface/put_line.html","title":"put_line – miniFAVOR"},{"text":"public interface remove Contents Module Procedures remove_character remove_string Module Procedures private elemental function remove_character (string, start, finish) result(removed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) private elemental function remove_string (string, start, finish) result(removed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string )","tags":"","loc":"interface/remove.html","title":"remove – miniFAVOR"},{"text":"public interface repeat Contents Module Procedures string_repeat Module Procedures private elemental function string_repeat (string, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( varying_string )","tags":"","loc":"interface/repeat.html","title":"repeat – miniFAVOR"},{"text":"public interface replace Contents Module Procedures replace_character_with_character_start replace_string_with_character_start replace_character_with_string_start replace_string_with_string_start replace_character_with_character_range replace_string_with_character_range replace_character_with_string_range replace_string_with_string_range replace_target_character_with_character_in_character replace_target_character_with_character_in_string replace_target_character_with_string_in_character replace_target_character_with_string_in_string replace_target_string_with_character_in_character replace_target_string_with_character_in_string replace_target_string_with_string_in_character replace_target_string_with_string_in_string Module Procedures private elemental function replace_character_with_character_start (string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_string_with_character_start (string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_character_with_string_start (string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_string_with_string_start (string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_character_with_character_range (string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_string_with_character_range (string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_character_with_string_range (string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_string_with_string_range (string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_target_character_with_character_in_character (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_character_with_character_in_string (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_character_with_string_in_character (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_character_with_string_in_string (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_string_with_character_in_character (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_string_with_character_in_string (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_string_with_string_in_character (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_string_with_string_in_string (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string )","tags":"","loc":"interface/replace.html","title":"replace – miniFAVOR"},{"text":"public interface scan Contents Module Procedures string_scan_string string_scan_character character_scan_string Module Procedures private elemental function string_scan_string (string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function string_scan_character (string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function character_scan_string (string, set, back) result(position) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","loc":"interface/scan.html","title":"scan – miniFAVOR"},{"text":"public interface split Contents Module Procedures split_character split_string Module Procedures private elemental subroutine split_character (string, word, set, separator, back) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(inout) :: string type( varying_string ), intent(out) :: word character(len=*), intent(in) :: set type( varying_string ), intent(out), optional :: separator logical, intent(in), optional :: back private elemental subroutine split_string (string, word, set, separator, back) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(inout) :: string type( varying_string ), intent(out) :: word type( varying_string ), intent(in) :: set type( varying_string ), intent(out), optional :: separator logical, intent(in), optional :: back","tags":"","loc":"interface/split.html","title":"split – miniFAVOR"},{"text":"public interface trim Contents Module Procedures trim_string Module Procedures private elemental function trim_string (string) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string )","tags":"","loc":"interface/trim.html","title":"trim – miniFAVOR"},{"text":"public interface verify Contents Module Procedures string_verify_string string_verify_character character_verify_string Module Procedures private elemental function string_verify_string (string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function string_verify_character (string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function character_verify_string (string, set, back) result(position) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","loc":"interface/verify.html","title":"verify – miniFAVOR"},{"text":"private pure function drop_extension(filename) result(without_extension) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename Return Value type( varying_string ) Contents None","tags":"","loc":"proc/drop_extension.html","title":"drop_extension – miniFAVOR"},{"text":"private pure function make_program(driver_name, test_infos) result(program_) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: driver_name type( test_info_t ), intent(in) :: test_infos (:) Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_program.html","title":"make_program – miniFAVOR"},{"text":"private pure function make_use_statement(test_info) result(use_statement) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( test_info_t ), intent(in) :: test_info Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_use_statement.html","title":"make_use_statement – miniFAVOR"},{"text":"private pure function make_use_statements(test_infos) result(use_statements) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( test_info_t ), intent(in) :: test_infos (:) Return Value type( varying_string )\n  (size(test_infos)) Contents None","tags":"","loc":"proc/make_use_statements.html","title":"make_use_statements – miniFAVOR"},{"text":"private pure function parse_alphabet(the_state) result(the_result) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_alphabet.html","title":"parse_alphabet – miniFAVOR"},{"text":"private pure function parse_at_least_one_white_space(the_state) result(the_result) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_at_least_one_white_space.html","title":"parse_at_least_one_white_space – miniFAVOR"},{"text":"private pure function parse_function(the_state) result(the_result) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_function.html","title":"parse_function – miniFAVOR"},{"text":"private elemental function parse_line(line) result(maybe_name) Uses iso_varying_string parff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: line Return Value type( parse_result_t ) Contents None","tags":"","loc":"proc/parse_line.html","title":"parse_line – miniFAVOR"},{"text":"private pure function parse_open_paren(the_state) result(the_result) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_open_paren.html","title":"parse_open_paren – miniFAVOR"},{"text":"private pure function parse_space_or_open_paren(the_state) result(the_result) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_space_or_open_paren.html","title":"parse_space_or_open_paren – miniFAVOR"},{"text":"private pure function parse_test_function_name(the_state) result(the_result) Uses iso_varying_string parff strff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_test_function_name.html","title":"parse_test_function_name – miniFAVOR"},{"text":"private pure function parse_underscore(the_state) result(the_result) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_underscore.html","title":"parse_underscore – miniFAVOR"},{"text":"private pure function parse_valid_first_character(the_state) result(the_result) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_valid_first_character.html","title":"parse_valid_first_character – miniFAVOR"},{"text":"private pure function parse_valid_identifier(the_state) result(the_result) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_valid_identifier.html","title":"parse_valid_identifier – miniFAVOR"},{"text":"private pure function parse_valid_identifier_character(the_state) result(the_result) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_valid_identifier_character.html","title":"parse_valid_identifier_character – miniFAVOR"},{"text":"private pure function parse_white_space(the_state) result(the_result) Uses parff Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) Contents None","tags":"","loc":"proc/parse_white_space.html","title":"parse_white_space – miniFAVOR"},{"text":"private pure function rename_(module_name, function_name) result(renamed) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: module_name type( varying_string ), intent(in) :: function_name Return Value type( varying_string ) Contents None","tags":"","loc":"proc/rename_.html","title":"rename_ – miniFAVOR"},{"text":"private pure function take_file_name(filename) result(just_file) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename Return Value type( varying_string ) Contents None","tags":"","loc":"proc/take_file_name.html","title":"take_file_name – miniFAVOR"},{"text":"public subroutine make_driver(driver_file, test_files) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: driver_file type( varying_string ), intent(in) :: test_files (:) Contents None","tags":"","loc":"proc/make_driver.html","title":"make_driver – miniFAVOR"},{"text":"private subroutine get_individual_test_info(filename, test_info) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename type( test_info_t ), intent(out) :: test_info Contents None","tags":"","loc":"proc/get_individual_test_info.html","title":"get_individual_test_info – miniFAVOR"},{"text":"private subroutine get_test_info(filenames, test_infos) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filenames (:) type( test_info_t ), intent(out) :: test_infos (size(filenames)) Contents None","tags":"","loc":"proc/get_test_info.html","title":"get_test_info – miniFAVOR"},{"text":"private pure subroutine make_test_array(test_infos, test_array) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( test_info_t ), intent(in) :: test_infos (:) type( varying_string ), intent(out), allocatable :: test_array (:) Contents None","tags":"","loc":"proc/make_test_array.html","title":"make_test_array – miniFAVOR"},{"text":"private subroutine scan_test_file(filename, function_names) Uses iso_varying_string parff strff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename type( varying_string ), intent(out), allocatable :: function_names (:) Contents None","tags":"","loc":"proc/scan_test_file.html","title":"scan_test_file – miniFAVOR"},{"text":"public function test_assert_equals_within_relative() result(tests) Uses double_precision_generator_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_assert_equals_within_relative.html","title":"test_assert_equals_within_relative – miniFAVOR"},{"text":"private pure function check_fail_for_different_numbers(the_example) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_fail_for_different_numbers.html","title":"check_fail_for_different_numbers – miniFAVOR"},{"text":"private pure function check_pass_for_close_numbers(the_example) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_pass_for_close_numbers.html","title":"check_pass_for_close_numbers – miniFAVOR"},{"text":"private pure function check_pass_for_same_number(the_example) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_pass_for_same_number.html","title":"check_pass_for_same_number – miniFAVOR"},{"text":"public function test_failing_collection_behaviors() result(tests) Uses example_collections_m helpers_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_failing_collection_behaviors.html","title":"test_failing_collection_behaviors – miniFAVOR"},{"text":"private pure function check_collection_fails(example_results) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_collection_fails.html","title":"check_collection_fails – miniFAVOR"},{"text":"private pure function check_failure_case_description(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure_case_description.html","title":"check_failure_case_description – miniFAVOR"},{"text":"private pure function check_failure_for_message(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure_for_message.html","title":"check_failure_for_message – miniFAVOR"},{"text":"private pure function check_failure_for_top_description(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure_for_top_description.html","title":"check_failure_for_top_description – miniFAVOR"},{"text":"private pure function check_failure_no_blank_lines(example_results) result(result_) Uses helpers_m strff vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure_no_blank_lines.html","title":"check_failure_no_blank_lines – miniFAVOR"},{"text":"private pure function check_failure_no_passing_descriptions(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure_no_passing_descriptions.html","title":"check_failure_no_passing_descriptions – miniFAVOR"},{"text":"private pure function check_failure_no_success_message(example_results) result(result_) Uses example_asserts_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure_no_success_message.html","title":"check_failure_no_success_message – miniFAVOR"},{"text":"private pure function check_num_asserts(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_asserts.html","title":"check_num_asserts – miniFAVOR"},{"text":"private pure function check_num_cases(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_cases.html","title":"check_num_cases – miniFAVOR"},{"text":"private pure function check_num_failing_asserts(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_failing_asserts.html","title":"check_num_failing_asserts – miniFAVOR"},{"text":"private pure function check_num_failing_cases(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_failing_cases.html","title":"check_num_failing_cases – miniFAVOR"},{"text":"private pure function check_verbose_case_descriptions(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verbose_case_descriptions.html","title":"check_verbose_case_descriptions – miniFAVOR"},{"text":"private pure function check_verbose_for_failure_message(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verbose_for_failure_message.html","title":"check_verbose_for_failure_message – miniFAVOR"},{"text":"private pure function check_verbose_for_success_message(example_results) result(result_) Uses example_asserts_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verbose_for_success_message.html","title":"check_verbose_for_success_message – miniFAVOR"},{"text":"private pure function check_verbose_top_description(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verbose_top_description.html","title":"check_verbose_top_description – miniFAVOR"},{"text":"public function test_assert_includes() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_assert_includes.html","title":"test_assert_includes – miniFAVOR"},{"text":"private pure function check_fail_for_same_string(the_example) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_fail_for_same_string.html","title":"check_fail_for_same_string – miniFAVOR"},{"text":"private pure function check_pass_for_different_strings() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_pass_for_different_strings.html","title":"check_pass_for_different_strings – miniFAVOR"},{"text":"public function test_result() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_result.html","title":"test_result – miniFAVOR"},{"text":"private pure function check_failure_includes() result(result_) Uses vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure_includes.html","title":"check_failure_includes – miniFAVOR"},{"text":"private pure function check_num_asserts() result(result_) Uses vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_asserts~2.html","title":"check_num_asserts – miniFAVOR"},{"text":"private pure function check_num_failing_asserts() result(result_) Uses vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_failing_asserts~2.html","title":"check_num_failing_asserts – miniFAVOR"},{"text":"private pure function check_passed() result(result_) Uses vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_passed.html","title":"check_passed – miniFAVOR"},{"text":"private pure function check_verbose_includes() result(result_) Uses vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verbose_includes.html","title":"check_verbose_includes – miniFAVOR"},{"text":"public function example_failing_collection() result(test_collection) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/example_failing_collection.html","title":"example_failing_collection – miniFAVOR"},{"text":"public function example_passing_collection() result(test_collection) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/example_passing_collection.html","title":"example_passing_collection – miniFAVOR"},{"text":"public function example_test_case_1() result(test_case) Uses example_asserts_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/example_test_case_1.html","title":"example_test_case_1 – miniFAVOR"},{"text":"public function example_test_case_2() result(test_case) Uses example_asserts_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/example_test_case_2.html","title":"example_test_case_2 – miniFAVOR"},{"text":"private pure function example_fail() result(result_) Uses vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/example_fail.html","title":"example_fail – miniFAVOR"},{"text":"private function example_failing_test_case() result(test_case) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/example_failing_test_case.html","title":"example_failing_test_case – miniFAVOR"},{"text":"private function middle_collection() result(test_collection) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/middle_collection.html","title":"middle_collection – miniFAVOR"},{"text":"public function test_assert_equals_within_relative() result(tests) Uses double_precision_generator_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_assert_equals_within_relative~2.html","title":"test_assert_equals_within_relative – miniFAVOR"},{"text":"private pure function check_fail_for_different_numbers(the_example) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_fail_for_different_numbers~2.html","title":"check_fail_for_different_numbers – miniFAVOR"},{"text":"private pure function check_pass_for_close_numbers(the_example) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_pass_for_close_numbers~2.html","title":"check_pass_for_close_numbers – miniFAVOR"},{"text":"private pure function check_pass_for_same_number(the_example) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_pass_for_same_number~2.html","title":"check_pass_for_same_number – miniFAVOR"},{"text":"public function test_assert_equals_integers() result(tests) Uses double_precision_generator_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_assert_equals_integers.html","title":"test_assert_equals_integers – miniFAVOR"},{"text":"private pure function check_fail_for_different_numbers() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_fail_for_different_numbers~3.html","title":"check_fail_for_different_numbers – miniFAVOR"},{"text":"private pure function check_pass_for_same_number(the_example) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_pass_for_same_number~3.html","title":"check_pass_for_same_number – miniFAVOR"},{"text":"subroutine run() Uses assert_doesnt_include_test assert_empty_test assert_equals_double_precision_test assert_equals_integers_test assert_equals_strings_test assert_equals_within_absolute_test assert_equals_within_relative_test assert_includes_test collection_properties_test failing_case_test failing_collection_test filter_test passing_case_test passing_collection_test result_test single_case_properties_test vegetables Arguments None Contents None","tags":"","loc":"proc/run~3.html","title":"run – miniFAVOR"},{"text":"public function test_passing_collection_behaviors() result(tests) Uses example_collections_m helpers_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_passing_collection_behaviors.html","title":"test_passing_collection_behaviors – miniFAVOR"},{"text":"private pure function check_collection_passes(example_results) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_collection_passes.html","title":"check_collection_passes – miniFAVOR"},{"text":"private pure function check_failure_description_empty(example_results) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure_description_empty.html","title":"check_failure_description_empty – miniFAVOR"},{"text":"private pure function check_num_asserts(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_asserts~3.html","title":"check_num_asserts – miniFAVOR"},{"text":"private pure function check_num_cases(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_cases~2.html","title":"check_num_cases – miniFAVOR"},{"text":"private pure function check_num_failing_asserts(example_results) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_failing_asserts~3.html","title":"check_num_failing_asserts – miniFAVOR"},{"text":"private pure function check_num_failing_cases(example_results) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_failing_cases~2.html","title":"check_num_failing_cases – miniFAVOR"},{"text":"private pure function check_verbose_case_descriptions(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verbose_case_descriptions~2.html","title":"check_verbose_case_descriptions – miniFAVOR"},{"text":"private pure function check_verbose_description_assertion(example_results) result(result_) Uses example_asserts_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verbose_description_assertion.html","title":"check_verbose_description_assertion – miniFAVOR"},{"text":"private pure function check_werbose_top_description(example_results) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_werbose_top_description.html","title":"check_werbose_top_description – miniFAVOR"},{"text":"public function test_assert_equals_strings() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_assert_equals_strings.html","title":"test_assert_equals_strings – miniFAVOR"},{"text":"private pure function check_fail_for_different_strings() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_fail_for_different_strings.html","title":"check_fail_for_different_strings – miniFAVOR"},{"text":"private pure function check_pass_for_same_strings(the_example) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_pass_for_same_strings.html","title":"check_pass_for_same_strings – miniFAVOR"},{"text":"public function test_passing_case_behaviors() result(test) Uses example_cases_m helpers_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_passing_case_behaviors.html","title":"test_passing_case_behaviors – miniFAVOR"},{"text":"private pure function check_case_passes(example_result) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_case_passes.html","title":"check_case_passes – miniFAVOR"},{"text":"private pure function check_failure_description_empty(example_result) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure_description_empty~2.html","title":"check_failure_description_empty – miniFAVOR"},{"text":"private pure function check_num_asserts(example_result) result(result_) Uses example_asserts_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_asserts~4.html","title":"check_num_asserts – miniFAVOR"},{"text":"private pure function check_num_cases(example_result) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_cases~3.html","title":"check_num_cases – miniFAVOR"},{"text":"private pure function check_num_failing_asserts(example_result) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_failing_asserts~4.html","title":"check_num_failing_asserts – miniFAVOR"},{"text":"private pure function check_num_failing_cases(example_result) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_failing_cases~3.html","title":"check_num_failing_cases – miniFAVOR"},{"text":"private pure function check_verbose_description(example_result) result(result_) Uses example_cases_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verbose_description.html","title":"check_verbose_description – miniFAVOR"},{"text":"private pure function check_verbose_description_assertion(example_result) result(result_) Uses example_asserts_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verbose_description_assertion~2.html","title":"check_verbose_description_assertion – miniFAVOR"},{"text":"private pure function effectively_zero(value_) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: value_ Return Value logical Contents None","tags":"","loc":"proc/effectively_zero.html","title":"effectively_zero – miniFAVOR"},{"text":"private function generate(self) result(random_double) Uses vegetables Arguments Type Intent Optional Attributes Name class( double_precision_generator_t ), intent(in) :: self Return Value type( generated_t ) Contents None","tags":"","loc":"proc/generate.html","title":"generate – miniFAVOR"},{"text":"private pure function shrink(input) result(shrunk) Uses vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t ) Contents None","tags":"","loc":"proc/shrink.html","title":"shrink – miniFAVOR"},{"text":"public function test_case_properties() result(test) Uses example_cases_m helpers_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_case_properties.html","title":"test_case_properties – miniFAVOR"},{"text":"private pure function check_case_description(example_case) result(result_) Uses example_cases_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_case Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_case_description.html","title":"check_case_description – miniFAVOR"},{"text":"private pure function check_num_cases(example_case) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_case Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_cases~4.html","title":"check_num_cases – miniFAVOR"},{"text":"private function check_speed(example_case) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_case Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_speed.html","title":"check_speed – miniFAVOR"},{"text":"public function example_failing_test_case() result(test_case) Uses example_asserts_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/example_failing_test_case~2.html","title":"example_failing_test_case – miniFAVOR"},{"text":"public function example_passing_test_case() result(test_case) Uses example_asserts_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/example_passing_test_case.html","title":"example_passing_test_case – miniFAVOR"},{"text":"public function test_collection_properties() result(test) Uses example_collections_m helpers_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_collection_properties.html","title":"test_collection_properties – miniFAVOR"},{"text":"private pure function checkcollectiondescriptions(example_collection) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( result_t ) Contents None","tags":"","loc":"proc/checkcollectiondescriptions.html","title":"checkcollectiondescriptions – miniFAVOR"},{"text":"private pure function checkcollectiontopdescription(example_collection) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( result_t ) Contents None","tags":"","loc":"proc/checkcollectiontopdescription.html","title":"checkcollectiontopdescription – miniFAVOR"},{"text":"private pure function checknumcases(example_collection) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( result_t ) Contents None","tags":"","loc":"proc/checknumcases.html","title":"checknumcases – miniFAVOR"},{"text":"private function checkspeed(example_collection) result(result_) Uses example_collections_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( result_t ) Contents None","tags":"","loc":"proc/checkspeed.html","title":"checkspeed – miniFAVOR"},{"text":"public function test_filter_case() result(tests) Uses example_cases_m helpers_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_filter_case.html","title":"test_filter_case – miniFAVOR"},{"text":"public function test_filter_collection() result(tests) Uses example_collections_m helpers_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_filter_collection.html","title":"test_filter_collection – miniFAVOR"},{"text":"private pure function check_case_is_same(filtered) result(result_) Uses example_cases_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: filtered Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_case_is_same.html","title":"check_case_is_same – miniFAVOR"},{"text":"private pure function check_case_not_matching(filtered) result(result_) Uses vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: filtered Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_case_not_matching.html","title":"check_case_not_matching – miniFAVOR"},{"text":"private function check_collection_is_same(filtered) result(result_) Uses example_collections_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: filtered Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_collection_is_same.html","title":"check_collection_is_same – miniFAVOR"},{"text":"private pure function check_collection_not_matching(filtered) result(result_) Uses vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: filtered Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_collection_not_matching.html","title":"check_collection_not_matching – miniFAVOR"},{"text":"private pure function check_collection_single_case(filtered) result(result_) Uses vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: filtered Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_collection_single_case.html","title":"check_collection_single_case – miniFAVOR"},{"text":"private pure function filter_case_matching(example_case) result(filtered) Uses example_cases_m helpers_m iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_case Return Value type( transformed_t ) Contents None","tags":"","loc":"proc/filter_case_matching.html","title":"filter_case_matching – miniFAVOR"},{"text":"private pure function filter_case_not_matching(example_case) result(filtered) Uses example_cases_m helpers_m iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_case Return Value type( transformed_t ) Contents None","tags":"","loc":"proc/filter_case_not_matching.html","title":"filter_case_not_matching – miniFAVOR"},{"text":"private pure function filter_collection_matching_case(example_collection) result(filtered) Uses example_collections_m helpers_m iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( transformed_t ) Contents None","tags":"","loc":"proc/filter_collection_matching_case.html","title":"filter_collection_matching_case – miniFAVOR"},{"text":"private pure function filter_collection_matching_description(example_collection) result(filtered) Uses example_collections_m helpers_m iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( transformed_t ) Contents None","tags":"","loc":"proc/filter_collection_matching_description.html","title":"filter_collection_matching_description – miniFAVOR"},{"text":"private pure function filter_collection_not_matching(example_collection) result(filtered) Uses example_collections_m helpers_m iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( transformed_t ) Contents None","tags":"","loc":"proc/filter_collection_not_matching.html","title":"filter_collection_not_matching – miniFAVOR"},{"text":"public function test_assert_empty() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_assert_empty.html","title":"test_assert_empty – miniFAVOR"},{"text":"private pure function check_fails_for_nonempty_chars() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_fails_for_nonempty_chars.html","title":"check_fails_for_nonempty_chars – miniFAVOR"},{"text":"private pure function check_pass_for_empty_chars() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_pass_for_empty_chars.html","title":"check_pass_for_empty_chars – miniFAVOR"},{"text":"public function test_failing_case_behaviors() result(test) Uses example_cases_m helpers_m vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_failing_case_behaviors.html","title":"test_failing_case_behaviors – miniFAVOR"},{"text":"private pure function check_case_fails(example_result) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_case_fails.html","title":"check_case_fails – miniFAVOR"},{"text":"private pure function check_failure_for_failure_message(example_result) result(result_) Uses example_asserts_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure_for_failure_message.html","title":"check_failure_for_failure_message – miniFAVOR"},{"text":"private pure function check_failure_for_given_description(example_result) result(result_) Uses example_cases_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure_for_given_description.html","title":"check_failure_for_given_description – miniFAVOR"},{"text":"private pure function check_failure_no_success_message(example_result) result(result_) Uses example_asserts_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_failure_no_success_message~2.html","title":"check_failure_no_success_message – miniFAVOR"},{"text":"private pure function check_num_asserts(example_result) result(result_) Uses example_asserts_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_asserts~5.html","title":"check_num_asserts – miniFAVOR"},{"text":"private pure function check_num_cases(example_result) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_cases~5.html","title":"check_num_cases – miniFAVOR"},{"text":"private pure function check_num_failing_asserts(example_result) result(result_) Uses example_asserts_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_failing_asserts~5.html","title":"check_num_failing_asserts – miniFAVOR"},{"text":"private pure function check_num_failing_cases(example_result) result(result_) Uses helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_num_failing_cases~4.html","title":"check_num_failing_cases – miniFAVOR"},{"text":"private pure function check_verbose_for_failure_message(example_result) result(result_) Uses example_asserts_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verbose_for_failure_message~2.html","title":"check_verbose_for_failure_message – miniFAVOR"},{"text":"private pure function check_verbose_for_given_description(example_result) result(result_) Uses example_cases_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verbose_for_given_description.html","title":"check_verbose_for_given_description – miniFAVOR"},{"text":"private pure function check_verbose_for_success_message(example_result) result(result_) Uses example_asserts_m helpers_m vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_verbose_for_success_message~2.html","title":"check_verbose_for_success_message – miniFAVOR"},{"text":"public function test_assert_includes() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_assert_includes~2.html","title":"test_assert_includes – miniFAVOR"},{"text":"private pure function check_fail_for_different_strings() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_fail_for_different_strings~2.html","title":"check_fail_for_different_strings – miniFAVOR"},{"text":"private pure function check_pass_for_same_strings(the_example) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_pass_for_same_strings~2.html","title":"check_pass_for_same_strings – miniFAVOR"},{"text":"public pure function example_multiple_asserts() result(result_) Uses vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/example_multiple_asserts.html","title":"example_multiple_asserts – miniFAVOR"},{"text":"public pure function example_multiple_asserts_with_fail() result(result_) Uses vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/example_multiple_asserts_with_fail.html","title":"example_multiple_asserts_with_fail – miniFAVOR"},{"text":"public function test_assert_equals_integers() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_assert_equals_integers~2.html","title":"test_assert_equals_integers – miniFAVOR"},{"text":"private pure function check_fail_for_different_integers() result(result_) Uses iso_varying_string vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_fail_for_different_integers.html","title":"check_fail_for_different_integers – miniFAVOR"},{"text":"private pure function check_pass_for_same_integer(the_input) result(result_) Uses iso_varying_string vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_input Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_pass_for_same_integer.html","title":"check_pass_for_same_integer – miniFAVOR"},{"text":"public function run_test(example_test) result(example_result) Uses vegetables Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_test Return Value type( transformed_t ) Contents None","tags":"","loc":"proc/run_test.html","title":"run_test – miniFAVOR"},{"text":"public pure function example(input) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( example_t ) Contents None","tags":"","loc":"proc/example.html","title":"example – miniFAVOR"},{"text":"public pure function generated(value_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: value_ Return Value type( generated_t ) Contents None","tags":"","loc":"proc/generated.html","title":"generated – miniFAVOR"},{"text":"public function get_random_ascii_character() result(random_character) Arguments None Return Value character(len=1) Contents None","tags":"","loc":"proc/get_random_ascii_character.html","title":"get_random_ascii_character – miniFAVOR"},{"text":"public function get_random_ascii_string() result(random_string) Uses iso_varying_string Arguments None Return Value type( varying_string ) Contents None","tags":"","loc":"proc/get_random_ascii_string.html","title":"get_random_ascii_string – miniFAVOR"},{"text":"public function get_random_ascii_string_with_max_length(max_length) result(random_string) Uses iso_varying_string Arguments Type Intent Optional Attributes Name integer, intent(in) :: max_length Return Value type( varying_string ) Contents None","tags":"","loc":"proc/get_random_ascii_string_with_max_length.html","title":"get_random_ascii_string_with_max_length – miniFAVOR"},{"text":"public function get_random_double_precision_with_magnitude(magnitude) result(random_double) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: magnitude Return Value double precision Contents None","tags":"","loc":"proc/get_random_double_precision_with_magnitude.html","title":"get_random_double_precision_with_magnitude – miniFAVOR"},{"text":"public function get_random_double_precision_with_range(start, end_) result(random_double) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: start double precision, intent(in) :: end_ Return Value double precision Contents None","tags":"","loc":"proc/get_random_double_precision_with_range.html","title":"get_random_double_precision_with_range – miniFAVOR"},{"text":"public function get_random_integer() result(random_integer) Arguments None Return Value integer Contents None","tags":"","loc":"proc/get_random_integer.html","title":"get_random_integer – miniFAVOR"},{"text":"public function get_random_integer_with_range(start, end_) result(random_integer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end_ Return Value integer Contents None","tags":"","loc":"proc/get_random_integer_with_range.html","title":"get_random_integer_with_range – miniFAVOR"},{"text":"public function get_random_logical() result(random_logical) Arguments None Return Value logical Contents None","tags":"","loc":"proc/get_random_logical.html","title":"get_random_logical – miniFAVOR"},{"text":"public pure function shrunk_value(value_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: value_ Return Value type( shrink_result_t ) Contents None","tags":"","loc":"proc/shrunk_value.html","title":"shrunk_value – miniFAVOR"},{"text":"public pure function simplest_value(value_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: value_ Return Value type( shrink_result_t ) Contents None","tags":"","loc":"proc/simplest_value.html","title":"simplest_value – miniFAVOR"},{"text":"public function test_that(tests) result(item) Arguments Type Intent Optional Attributes Name type( test_item_t ) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_that.html","title":"test_that – miniFAVOR"},{"text":"public pure function transformed(input) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( transformed_t ) Contents None","tags":"","loc":"proc/transformed.html","title":"transformed – miniFAVOR"},{"text":"private pure function assert_doesnt_include_basic_cc(search_for, string) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_basic_cc.html","title":"assert_doesnt_include_basic_cc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_basic_cs(search_for, string) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_basic_cs.html","title":"assert_doesnt_include_basic_cs – miniFAVOR"},{"text":"private pure function assert_doesnt_include_basic_sc(search_for, string) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_basic_sc.html","title":"assert_doesnt_include_basic_sc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_basic_ss(search_for, string) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_basic_ss.html","title":"assert_doesnt_include_basic_ss – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_message_ccc(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_message_ccc.html","title":"assert_doesnt_include_with_message_ccc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_message_ccs(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_message_ccs.html","title":"assert_doesnt_include_with_message_ccs – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_message_csc(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_message_csc.html","title":"assert_doesnt_include_with_message_csc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_message_css(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_message_css.html","title":"assert_doesnt_include_with_message_css – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_message_scc(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_message_scc.html","title":"assert_doesnt_include_with_message_scc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_message_scs(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_message_scs.html","title":"assert_doesnt_include_with_message_scs – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_message_ssc(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_message_ssc.html","title":"assert_doesnt_include_with_message_ssc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_message_sss(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_message_sss.html","title":"assert_doesnt_include_with_message_sss – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_cccc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_cccc.html","title":"assert_doesnt_include_with_messages_cccc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_cccs(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_cccs.html","title":"assert_doesnt_include_with_messages_cccs – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_ccsc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_ccsc.html","title":"assert_doesnt_include_with_messages_ccsc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_ccss(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_ccss.html","title":"assert_doesnt_include_with_messages_ccss – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_cscc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_cscc.html","title":"assert_doesnt_include_with_messages_cscc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_cscs(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_cscs.html","title":"assert_doesnt_include_with_messages_cscs – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_cssc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_cssc.html","title":"assert_doesnt_include_with_messages_cssc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_csss(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_csss.html","title":"assert_doesnt_include_with_messages_csss – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_sccc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_sccc.html","title":"assert_doesnt_include_with_messages_sccc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_sccs(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_sccs.html","title":"assert_doesnt_include_with_messages_sccs – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_scsc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_scsc.html","title":"assert_doesnt_include_with_messages_scsc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_scss(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_scss.html","title":"assert_doesnt_include_with_messages_scss – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_sscc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_sscc.html","title":"assert_doesnt_include_with_messages_sscc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_sscs(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_sscs.html","title":"assert_doesnt_include_with_messages_sscs – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_sssc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_sssc.html","title":"assert_doesnt_include_with_messages_sssc – miniFAVOR"},{"text":"private pure function assert_doesnt_include_with_messages_ssss(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_doesnt_include_with_messages_ssss.html","title":"assert_doesnt_include_with_messages_ssss – miniFAVOR"},{"text":"private pure function assert_empty_basic_c(string) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_basic_c.html","title":"assert_empty_basic_c – miniFAVOR"},{"text":"private pure function assert_empty_basic_s(string) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_basic_s.html","title":"assert_empty_basic_s – miniFAVOR"},{"text":"private pure function assert_empty_with_message_cc(string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_with_message_cc.html","title":"assert_empty_with_message_cc – miniFAVOR"},{"text":"private pure function assert_empty_with_message_cs(string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_with_message_cs.html","title":"assert_empty_with_message_cs – miniFAVOR"},{"text":"private pure function assert_empty_with_message_sc(string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_with_message_sc.html","title":"assert_empty_with_message_sc – miniFAVOR"},{"text":"private pure function assert_empty_with_message_ss(string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_with_message_ss.html","title":"assert_empty_with_message_ss – miniFAVOR"},{"text":"private pure function assert_empty_with_messages_ccc(string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_with_messages_ccc.html","title":"assert_empty_with_messages_ccc – miniFAVOR"},{"text":"private pure function assert_empty_with_messages_ccs(string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_with_messages_ccs.html","title":"assert_empty_with_messages_ccs – miniFAVOR"},{"text":"private pure function assert_empty_with_messages_csc(string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_with_messages_csc.html","title":"assert_empty_with_messages_csc – miniFAVOR"},{"text":"private pure function assert_empty_with_messages_css(string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_with_messages_css.html","title":"assert_empty_with_messages_css – miniFAVOR"},{"text":"private pure function assert_empty_with_messages_scc(string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_with_messages_scc.html","title":"assert_empty_with_messages_scc – miniFAVOR"},{"text":"private pure function assert_empty_with_messages_scs(string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_with_messages_scs.html","title":"assert_empty_with_messages_scs – miniFAVOR"},{"text":"private pure function assert_empty_with_messages_ssc(string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_with_messages_ssc.html","title":"assert_empty_with_messages_ssc – miniFAVOR"},{"text":"private pure function assert_empty_with_messages_sss(string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_empty_with_messages_sss.html","title":"assert_empty_with_messages_sss – miniFAVOR"},{"text":"private pure function assert_equals_double_precision(expected, actual) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_double_precision.html","title":"assert_equals_double_precision – miniFAVOR"},{"text":"private pure function assert_equals_double_precision_with_message_c(expected, actual, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_double_precision_with_message_c.html","title":"assert_equals_double_precision_with_message_c – miniFAVOR"},{"text":"private pure function assert_equals_double_precision_with_message_s(expected, actual, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_double_precision_with_message_s.html","title":"assert_equals_double_precision_with_message_s – miniFAVOR"},{"text":"private pure function assert_equals_double_precision_with_messages_cc(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_double_precision_with_messages_cc.html","title":"assert_equals_double_precision_with_messages_cc – miniFAVOR"},{"text":"private pure function assert_equals_double_precision_with_messages_cs(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_double_precision_with_messages_cs.html","title":"assert_equals_double_precision_with_messages_cs – miniFAVOR"},{"text":"private pure function assert_equals_double_precision_with_messages_sc(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_double_precision_with_messages_sc.html","title":"assert_equals_double_precision_with_messages_sc – miniFAVOR"},{"text":"private pure function assert_equals_double_precision_with_messages_ss(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_double_precision_with_messages_ss.html","title":"assert_equals_double_precision_with_messages_ss – miniFAVOR"},{"text":"private pure function assert_equals_integer_basic(expected, actual) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_integer_basic.html","title":"assert_equals_integer_basic – miniFAVOR"},{"text":"private pure function assert_equals_integer_with_message_c(expected, actual, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_integer_with_message_c.html","title":"assert_equals_integer_with_message_c – miniFAVOR"},{"text":"private pure function assert_equals_integer_with_message_s(expected, actual, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_integer_with_message_s.html","title":"assert_equals_integer_with_message_s – miniFAVOR"},{"text":"private pure function assert_equals_integer_with_messages_cc(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_integer_with_messages_cc.html","title":"assert_equals_integer_with_messages_cc – miniFAVOR"},{"text":"private pure function assert_equals_integer_with_messages_cs(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_integer_with_messages_cs.html","title":"assert_equals_integer_with_messages_cs – miniFAVOR"},{"text":"private pure function assert_equals_integer_with_messages_sc(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_integer_with_messages_sc.html","title":"assert_equals_integer_with_messages_sc – miniFAVOR"},{"text":"private pure function assert_equals_integer_with_messages_ss(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_integer_with_messages_ss.html","title":"assert_equals_integer_with_messages_ss – miniFAVOR"},{"text":"private pure function assert_equals_strings_cc(expected, actual) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_cc.html","title":"assert_equals_strings_cc – miniFAVOR"},{"text":"private pure function assert_equals_strings_cs(expected, actual) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_cs.html","title":"assert_equals_strings_cs – miniFAVOR"},{"text":"private pure function assert_equals_strings_sc(expected, actual) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_sc.html","title":"assert_equals_strings_sc – miniFAVOR"},{"text":"private pure function assert_equals_strings_ss(expected, actual) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_ss.html","title":"assert_equals_strings_ss – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_message_ccc(expected, actual, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_message_ccc.html","title":"assert_equals_strings_with_message_ccc – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_message_ccs(expected, actual, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_message_ccs.html","title":"assert_equals_strings_with_message_ccs – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_message_csc(expected, actual, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_message_csc.html","title":"assert_equals_strings_with_message_csc – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_message_css(expected, actual, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_message_css.html","title":"assert_equals_strings_with_message_css – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_message_scc(expected, actual, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_message_scc.html","title":"assert_equals_strings_with_message_scc – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_message_scs(expected, actual, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_message_scs.html","title":"assert_equals_strings_with_message_scs – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_message_ssc(expected, actual, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_message_ssc.html","title":"assert_equals_strings_with_message_ssc – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_message_sss(expected, actual, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_message_sss.html","title":"assert_equals_strings_with_message_sss – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_cccc(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_cccc.html","title":"assert_equals_strings_with_messages_cccc – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_cccs(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_cccs.html","title":"assert_equals_strings_with_messages_cccs – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_ccsc(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_ccsc.html","title":"assert_equals_strings_with_messages_ccsc – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_ccss(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_ccss.html","title":"assert_equals_strings_with_messages_ccss – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_cscc(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_cscc.html","title":"assert_equals_strings_with_messages_cscc – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_cscs(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_cscs.html","title":"assert_equals_strings_with_messages_cscs – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_cssc(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_cssc.html","title":"assert_equals_strings_with_messages_cssc – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_csss(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_csss.html","title":"assert_equals_strings_with_messages_csss – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_sccc(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_sccc.html","title":"assert_equals_strings_with_messages_sccc – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_sccs(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_sccs.html","title":"assert_equals_strings_with_messages_sccs – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_scsc(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_scsc.html","title":"assert_equals_strings_with_messages_scsc – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_scss(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_scss.html","title":"assert_equals_strings_with_messages_scss – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_sscc(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_sscc.html","title":"assert_equals_strings_with_messages_sscc – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_sscs(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_sscs.html","title":"assert_equals_strings_with_messages_sscs – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_sssc(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_sssc.html","title":"assert_equals_strings_with_messages_sssc – miniFAVOR"},{"text":"private pure function assert_equals_strings_with_messages_ssss(expected, actual, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_strings_with_messages_ssss.html","title":"assert_equals_strings_with_messages_ssss – miniFAVOR"},{"text":"private pure function assert_equals_within_absolute_basic(expected, actual, tolerance) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_absolute_basic.html","title":"assert_equals_within_absolute_basic – miniFAVOR"},{"text":"private pure function assert_equals_within_absolute_with_message_c(expected, actual, tolerance, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_absolute_with_message_c.html","title":"assert_equals_within_absolute_with_message_c – miniFAVOR"},{"text":"private pure function assert_equals_within_absolute_with_message_s(expected, actual, tolerance, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_absolute_with_message_s.html","title":"assert_equals_within_absolute_with_message_s – miniFAVOR"},{"text":"private pure function assert_equals_within_absolute_with_messages_cc(expected, actual, tolerance, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_absolute_with_messages_cc.html","title":"assert_equals_within_absolute_with_messages_cc – miniFAVOR"},{"text":"private pure function assert_equals_within_absolute_with_messages_cs(expected, actual, tolerance, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_absolute_with_messages_cs.html","title":"assert_equals_within_absolute_with_messages_cs – miniFAVOR"},{"text":"private pure function assert_equals_within_absolute_with_messages_sc(expected, actual, tolerance, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_absolute_with_messages_sc.html","title":"assert_equals_within_absolute_with_messages_sc – miniFAVOR"},{"text":"private pure function assert_equals_within_absolute_with_messages_ss(expected, actual, tolerance, success_message, failure_message) result(result__) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_absolute_with_messages_ss.html","title":"assert_equals_within_absolute_with_messages_ss – miniFAVOR"},{"text":"private pure function assert_equals_within_relative_basic(expected, actual, tolerance) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_relative_basic.html","title":"assert_equals_within_relative_basic – miniFAVOR"},{"text":"private pure function assert_equals_within_relative_with_message_c(expected, actual, tolerance, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_relative_with_message_c.html","title":"assert_equals_within_relative_with_message_c – miniFAVOR"},{"text":"private pure function assert_equals_within_relative_with_message_s(expected, actual, tolerance, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_relative_with_message_s.html","title":"assert_equals_within_relative_with_message_s – miniFAVOR"},{"text":"private pure function assert_equals_within_relative_with_messages_cc(expected, actual, tolerance, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_relative_with_messages_cc.html","title":"assert_equals_within_relative_with_messages_cc – miniFAVOR"},{"text":"private pure function assert_equals_within_relative_with_messages_cs(expected, actual, tolerance, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_relative_with_messages_cs.html","title":"assert_equals_within_relative_with_messages_cs – miniFAVOR"},{"text":"private pure function assert_equals_within_relative_with_messages_sc(expected, actual, tolerance, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_relative_with_messages_sc.html","title":"assert_equals_within_relative_with_messages_sc – miniFAVOR"},{"text":"private pure function assert_equals_within_relative_with_messages_ss(expected, actual, tolerance, success_message, failure_message) result(result__) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_equals_within_relative_with_messages_ss.html","title":"assert_equals_within_relative_with_messages_ss – miniFAVOR"},{"text":"private function assert_faster_than_absolute_bracketed(reference, before, computation, after, iterations) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_bracketed.html","title":"assert_faster_than_absolute_bracketed – miniFAVOR"},{"text":"private function assert_faster_than_absolute_bracketed_with_message_c(reference, before, computation, after, iterations, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_bracketed_with_message_c.html","title":"assert_faster_than_absolute_bracketed_with_message_c – miniFAVOR"},{"text":"private function assert_faster_than_absolute_bracketed_with_message_s(reference, before, computation, after, iterations, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_bracketed_with_message_s.html","title":"assert_faster_than_absolute_bracketed_with_message_s – miniFAVOR"},{"text":"private function assert_faster_than_absolute_bracketed_with_messages_cc(reference, before, computation, after, iterations, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_bracketed_with_messages_cc.html","title":"assert_faster_than_absolute_bracketed_with_messages_cc – miniFAVOR"},{"text":"private function assert_faster_than_absolute_bracketed_with_messages_cs(reference, before, computation, after, iterations, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_bracketed_with_messages_cs.html","title":"assert_faster_than_absolute_bracketed_with_messages_cs – miniFAVOR"},{"text":"private function assert_faster_than_absolute_bracketed_with_messages_sc(reference, before, computation, after, iterations, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_bracketed_with_messages_sc.html","title":"assert_faster_than_absolute_bracketed_with_messages_sc – miniFAVOR"},{"text":"private function assert_faster_than_absolute_bracketed_with_messages_ss(reference, before, computation, after, iterations, success_message, failure_message) result(result__) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_bracketed_with_messages_ss.html","title":"assert_faster_than_absolute_bracketed_with_messages_ss – miniFAVOR"},{"text":"private function assert_faster_than_absolute_simple(reference, computation, iterations) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_simple.html","title":"assert_faster_than_absolute_simple – miniFAVOR"},{"text":"private function assert_faster_than_absolute_simple_with_message_c(reference, computation, iterations, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_simple_with_message_c.html","title":"assert_faster_than_absolute_simple_with_message_c – miniFAVOR"},{"text":"private function assert_faster_than_absolute_simple_with_message_s(reference, computation, iterations, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_simple_with_message_s.html","title":"assert_faster_than_absolute_simple_with_message_s – miniFAVOR"},{"text":"private function assert_faster_than_absolute_simple_with_messages_cc(reference, computation, iterations, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_simple_with_messages_cc.html","title":"assert_faster_than_absolute_simple_with_messages_cc – miniFAVOR"},{"text":"private function assert_faster_than_absolute_simple_with_messages_cs(reference, computation, iterations, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_simple_with_messages_cs.html","title":"assert_faster_than_absolute_simple_with_messages_cs – miniFAVOR"},{"text":"private function assert_faster_than_absolute_simple_with_messages_sc(reference, computation, iterations, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_simple_with_messages_sc.html","title":"assert_faster_than_absolute_simple_with_messages_sc – miniFAVOR"},{"text":"private function assert_faster_than_absolute_simple_with_messages_ss(reference, computation, iterations, success_message, failure_message) result(result__) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_absolute_simple_with_messages_ss.html","title":"assert_faster_than_absolute_simple_with_messages_ss – miniFAVOR"},{"text":"private function assert_faster_than_relative_bracketed(reference_before, reference, reference_after, before, computation, after, iterations) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_bracketed.html","title":"assert_faster_than_relative_bracketed – miniFAVOR"},{"text":"private function assert_faster_than_relative_bracketed_with_message_c(reference_before, reference, reference_after, before, computation, after, iterations, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_bracketed_with_message_c.html","title":"assert_faster_than_relative_bracketed_with_message_c – miniFAVOR"},{"text":"private function assert_faster_than_relative_bracketed_with_message_s(reference_before, reference, reference_after, before, computation, after, iterations, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_bracketed_with_message_s.html","title":"assert_faster_than_relative_bracketed_with_message_s – miniFAVOR"},{"text":"private function assert_faster_than_relative_bracketed_with_messages_cc(reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_bracketed_with_messages_cc.html","title":"assert_faster_than_relative_bracketed_with_messages_cc – miniFAVOR"},{"text":"private function assert_faster_than_relative_bracketed_with_messages_cs(reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_bracketed_with_messages_cs.html","title":"assert_faster_than_relative_bracketed_with_messages_cs – miniFAVOR"},{"text":"private function assert_faster_than_relative_bracketed_with_messages_sc(reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_bracketed_with_messages_sc.html","title":"assert_faster_than_relative_bracketed_with_messages_sc – miniFAVOR"},{"text":"private function assert_faster_than_relative_bracketed_with_messages_ss(reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_bracketed_with_messages_ss.html","title":"assert_faster_than_relative_bracketed_with_messages_ss – miniFAVOR"},{"text":"private function assert_faster_than_relative_simple(reference, computation, iterations) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_simple.html","title":"assert_faster_than_relative_simple – miniFAVOR"},{"text":"private function assert_faster_than_relative_simple_with_message_c(reference, computation, iterations, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_simple_with_message_c.html","title":"assert_faster_than_relative_simple_with_message_c – miniFAVOR"},{"text":"private function assert_faster_than_relative_simple_with_message_s(reference, computation, iterations, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_simple_with_message_s.html","title":"assert_faster_than_relative_simple_with_message_s – miniFAVOR"},{"text":"private function assert_faster_than_relative_simple_with_messages_cc(reference, computation, iterations, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_simple_with_messages_cc.html","title":"assert_faster_than_relative_simple_with_messages_cc – miniFAVOR"},{"text":"private function assert_faster_than_relative_simple_with_messages_cs(reference, computation, iterations, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_simple_with_messages_cs.html","title":"assert_faster_than_relative_simple_with_messages_cs – miniFAVOR"},{"text":"private function assert_faster_than_relative_simple_with_messages_sc(reference, computation, iterations, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_simple_with_messages_sc.html","title":"assert_faster_than_relative_simple_with_messages_sc – miniFAVOR"},{"text":"private function assert_faster_than_relative_simple_with_messages_ss(reference, computation, iterations, success_message, failure_message) result(result__) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_faster_than_relative_simple_with_messages_ss.html","title":"assert_faster_than_relative_simple_with_messages_ss – miniFAVOR"},{"text":"private pure function assert_includes_cc(search_for, string) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_cc.html","title":"assert_includes_cc – miniFAVOR"},{"text":"private pure function assert_includes_cs(search_for, string) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_cs.html","title":"assert_includes_cs – miniFAVOR"},{"text":"private pure function assert_includes_sc(search_for, string) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_sc.html","title":"assert_includes_sc – miniFAVOR"},{"text":"private pure function assert_includes_ss(search_for, string) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_ss.html","title":"assert_includes_ss – miniFAVOR"},{"text":"private pure function assert_includes_with_message_ccc(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_message_ccc.html","title":"assert_includes_with_message_ccc – miniFAVOR"},{"text":"private pure function assert_includes_with_message_ccs(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_message_ccs.html","title":"assert_includes_with_message_ccs – miniFAVOR"},{"text":"private pure function assert_includes_with_message_csc(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_message_csc.html","title":"assert_includes_with_message_csc – miniFAVOR"},{"text":"private pure function assert_includes_with_message_css(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_message_css.html","title":"assert_includes_with_message_css – miniFAVOR"},{"text":"private pure function assert_includes_with_message_scc(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_message_scc.html","title":"assert_includes_with_message_scc – miniFAVOR"},{"text":"private pure function assert_includes_with_message_scs(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_message_scs.html","title":"assert_includes_with_message_scs – miniFAVOR"},{"text":"private pure function assert_includes_with_message_ssc(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_message_ssc.html","title":"assert_includes_with_message_ssc – miniFAVOR"},{"text":"private pure function assert_includes_with_message_sss(search_for, string, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_message_sss.html","title":"assert_includes_with_message_sss – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_cccc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_cccc.html","title":"assert_includes_with_messages_cccc – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_cccs(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_cccs.html","title":"assert_includes_with_messages_cccs – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_ccsc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_ccsc.html","title":"assert_includes_with_messages_ccsc – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_ccss(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_ccss.html","title":"assert_includes_with_messages_ccss – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_cscc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_cscc.html","title":"assert_includes_with_messages_cscc – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_cscs(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_cscs.html","title":"assert_includes_with_messages_cscs – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_cssc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_cssc.html","title":"assert_includes_with_messages_cssc – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_csss(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_csss.html","title":"assert_includes_with_messages_csss – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_sccc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_sccc.html","title":"assert_includes_with_messages_sccc – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_sccs(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_sccs.html","title":"assert_includes_with_messages_sccs – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_scsc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_scsc.html","title":"assert_includes_with_messages_scsc – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_scss(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_scss.html","title":"assert_includes_with_messages_scss – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_sscc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_sscc.html","title":"assert_includes_with_messages_sscc – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_sscs(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_sscs.html","title":"assert_includes_with_messages_sscs – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_sssc(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_sssc.html","title":"assert_includes_with_messages_sssc – miniFAVOR"},{"text":"private pure function assert_includes_with_messages_ssss(search_for, string, success_message, failure_message) result(result__) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_includes_with_messages_ssss.html","title":"assert_includes_with_messages_ssss – miniFAVOR"},{"text":"private pure function assert_not_basic(condition) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_not_basic.html","title":"assert_not_basic – miniFAVOR"},{"text":"private pure function assert_not_with_message_c(condition, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_not_with_message_c.html","title":"assert_not_with_message_c – miniFAVOR"},{"text":"private pure function assert_not_with_message_s(condition, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_not_with_message_s.html","title":"assert_not_with_message_s – miniFAVOR"},{"text":"private pure function assert_not_with_messages_cc(condition, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_not_with_messages_cc.html","title":"assert_not_with_messages_cc – miniFAVOR"},{"text":"private pure function assert_not_with_messages_cs(condition, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_not_with_messages_cs.html","title":"assert_not_with_messages_cs – miniFAVOR"},{"text":"private pure function assert_not_with_messages_sc(condition, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_not_with_messages_sc.html","title":"assert_not_with_messages_sc – miniFAVOR"},{"text":"private pure function assert_not_with_messages_ss(condition, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_not_with_messages_ss.html","title":"assert_not_with_messages_ss – miniFAVOR"},{"text":"private pure function assert_that_basic(condition) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_that_basic.html","title":"assert_that_basic – miniFAVOR"},{"text":"private pure function assert_that_with_message_c(condition, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_that_with_message_c.html","title":"assert_that_with_message_c – miniFAVOR"},{"text":"private pure function assert_that_with_message_s(condition, message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_that_with_message_s.html","title":"assert_that_with_message_s – miniFAVOR"},{"text":"private pure function assert_that_with_messages_cc(condition, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_that_with_messages_cc.html","title":"assert_that_with_messages_cc – miniFAVOR"},{"text":"private pure function assert_that_with_messages_cs(condition, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_that_with_messages_cs.html","title":"assert_that_with_messages_cs – miniFAVOR"},{"text":"private pure function assert_that_with_messages_sc(condition, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_that_with_messages_sc.html","title":"assert_that_with_messages_sc – miniFAVOR"},{"text":"private pure function assert_that_with_messages_ss(condition, success_message, failure_message) result(result__) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) Contents None","tags":"","loc":"proc/assert_that_with_messages_ss.html","title":"assert_that_with_messages_ss – miniFAVOR"},{"text":"private pure function combine_results(lhs, rhs) result(combined) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: lhs type( result_t ), intent(in) :: rhs Return Value type( result_t ) Contents None","tags":"","loc":"proc/combine_results.html","title":"combine_results – miniFAVOR"},{"text":"private pure function delimit_c(string) result(delimited) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/delimit_c.html","title":"delimit_c – miniFAVOR"},{"text":"private pure function delimit_s(string) result(delimited) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/delimit_s.html","title":"delimit_s – miniFAVOR"},{"text":"private function describe_basic_c(description, tests) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/describe_basic_c.html","title":"describe_basic_c – miniFAVOR"},{"text":"private function describe_basic_s(description, tests) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/describe_basic_s.html","title":"describe_basic_s – miniFAVOR"},{"text":"private function describe_with_input_c(description, input, tests) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/describe_with_input_c.html","title":"describe_with_input_c – miniFAVOR"},{"text":"private function describe_with_input_s(description, input, tests) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/describe_with_input_s.html","title":"describe_with_input_s – miniFAVOR"},{"text":"private pure function equals_within_absolute(expected, actual, tolerance) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance Return Value logical Contents None","tags":"","loc":"proc/equals_within_absolute.html","title":"equals_within_absolute – miniFAVOR"},{"text":"private pure function equals_within_relative(expected, actual, tolerance) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance Return Value logical Contents None","tags":"","loc":"proc/equals_within_relative.html","title":"equals_within_relative – miniFAVOR"},{"text":"private pure function fail_c(message) result(failure) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/fail_c.html","title":"fail_c – miniFAVOR"},{"text":"private pure function fail_s(message) result(failure) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/fail_s.html","title":"fail_s – miniFAVOR"},{"text":"private function generate_ascii_string(self) result(generated_value) Arguments Type Intent Optional Attributes Name class( ascii_string_generator_t ), intent(in) :: self Return Value type( generated_t ) Contents None","tags":"","loc":"proc/generate_ascii_string.html","title":"generate_ascii_string – miniFAVOR"},{"text":"private function generate_integer(self) result(generated_value) Arguments Type Intent Optional Attributes Name class( integer_generator_t ), intent(in) :: self Return Value type( generated_t ) Contents None","tags":"","loc":"proc/generate_integer.html","title":"generate_integer – miniFAVOR"},{"text":"private function get_options() result(options) Uses iso_fortran_env iso_varying_string strff Arguments None Return Value type( options_t ) Contents None","tags":"","loc":"proc/get_options.html","title":"get_options – miniFAVOR"},{"text":"private function given_basic_c(description, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/given_basic_c.html","title":"given_basic_c – miniFAVOR"},{"text":"private function given_basic_s(description, tests) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/given_basic_s.html","title":"given_basic_s – miniFAVOR"},{"text":"private function given_with_input_c(description, input, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/given_with_input_c.html","title":"given_with_input_c – miniFAVOR"},{"text":"private function given_with_input_s(description, input, tests) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/given_with_input_s.html","title":"given_with_input_s – miniFAVOR"},{"text":"private pure function individual_result(message, passed) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message logical, intent(in) :: passed Return Value type( individual_result_t ) Contents None","tags":"","loc":"proc/individual_result.html","title":"individual_result – miniFAVOR"},{"text":"private elemental function individual_result_failure_description(self, colorize) result(description) Uses iso_varying_string Arguments Type Intent Optional Attributes Name class( individual_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) Contents None","tags":"","loc":"proc/individual_result_failure_description.html","title":"individual_result_failure_description – miniFAVOR"},{"text":"private elemental function individual_result_verbose_description(self, colorize) result(description) Uses iso_varying_string Arguments Type Intent Optional Attributes Name class( individual_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) Contents None","tags":"","loc":"proc/individual_result_verbose_description.html","title":"individual_result_verbose_description – miniFAVOR"},{"text":"private function input_test_case(description, test) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( input_test_i ) :: test Return Value type( input_test_case_t ) Contents None","tags":"","loc":"proc/input_test_case.html","title":"input_test_case – miniFAVOR"},{"text":"private function input_test_case_run_with_input(self, input) result(result_) Arguments Type Intent Optional Attributes Name class( input_test_case_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/input_test_case_run_with_input.html","title":"input_test_case_run_with_input – miniFAVOR"},{"text":"private function input_test_case_run_without_input(self) result(result_) Arguments Type Intent Optional Attributes Name class( input_test_case_t ), intent(in) :: self Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/input_test_case_run_without_input.html","title":"input_test_case_run_without_input – miniFAVOR"},{"text":"private function it_basic_c(description, test) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/it_basic_c.html","title":"it_basic_c – miniFAVOR"},{"text":"private function it_basic_s(description, test) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/it_basic_s.html","title":"it_basic_s – miniFAVOR"},{"text":"private function it_input_c(description, test) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/it_input_c.html","title":"it_input_c – miniFAVOR"},{"text":"private function it_input_s(description, test) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/it_input_s.html","title":"it_input_s – miniFAVOR"},{"text":"private function it_with_examples_c(description, examples, test) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( example_t ), intent(in) :: examples (:) procedure( input_test_i ) :: test Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/it_with_examples_c.html","title":"it_with_examples_c – miniFAVOR"},{"text":"private function it_with_examples_s(description, examples, test) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( example_t ), intent(in) :: examples (:) procedure( input_test_i ) :: test Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/it_with_examples_s.html","title":"it_with_examples_s – miniFAVOR"},{"text":"private function it_with_generator_c(description, generator, test) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description class( generator_t ), intent(in) :: generator procedure( input_test_i ) :: test Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/it_with_generator_c.html","title":"it_with_generator_c – miniFAVOR"},{"text":"private function it_with_generator_s(description, generator, test) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( generator_t ), intent(in) :: generator procedure( input_test_i ) :: test Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/it_with_generator_s.html","title":"it_with_generator_s – miniFAVOR"},{"text":"private pure function make_doesnt_include_failure_message_cc(search_for, string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_doesnt_include_failure_message_cc.html","title":"make_doesnt_include_failure_message_cc – miniFAVOR"},{"text":"private pure function make_doesnt_include_failure_message_cs(search_for, string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_doesnt_include_failure_message_cs.html","title":"make_doesnt_include_failure_message_cs – miniFAVOR"},{"text":"private pure function make_doesnt_include_failure_message_sc(search_for, string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_doesnt_include_failure_message_sc.html","title":"make_doesnt_include_failure_message_sc – miniFAVOR"},{"text":"private pure function make_doesnt_include_failure_message_ss(search_for, string) result(message) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_doesnt_include_failure_message_ss.html","title":"make_doesnt_include_failure_message_ss – miniFAVOR"},{"text":"private pure function make_doesnt_include_success_message_cc(search_for, string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_doesnt_include_success_message_cc.html","title":"make_doesnt_include_success_message_cc – miniFAVOR"},{"text":"private pure function make_doesnt_include_success_message_cs(search_for, string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_doesnt_include_success_message_cs.html","title":"make_doesnt_include_success_message_cs – miniFAVOR"},{"text":"private pure function make_doesnt_include_success_message_sc(search_for, string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_doesnt_include_success_message_sc.html","title":"make_doesnt_include_success_message_sc – miniFAVOR"},{"text":"private pure function make_doesnt_include_success_message_ss(search_for, string) result(message) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_doesnt_include_success_message_ss.html","title":"make_doesnt_include_success_message_ss – miniFAVOR"},{"text":"private pure function make_empty_failure_message_c(string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_empty_failure_message_c.html","title":"make_empty_failure_message_c – miniFAVOR"},{"text":"private pure function make_empty_failure_message_s(string) result(message) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_empty_failure_message_s.html","title":"make_empty_failure_message_s – miniFAVOR"},{"text":"private pure function make_equals_failure_message_cc(expected, actual) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_equals_failure_message_cc.html","title":"make_equals_failure_message_cc – miniFAVOR"},{"text":"private pure function make_equals_failure_message_cs(expected, actual) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_equals_failure_message_cs.html","title":"make_equals_failure_message_cs – miniFAVOR"},{"text":"private pure function make_equals_failure_message_sc(expected, actual) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_equals_failure_message_sc.html","title":"make_equals_failure_message_sc – miniFAVOR"},{"text":"private pure function make_equals_failure_message_ss(expected, actual) result(message) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_equals_failure_message_ss.html","title":"make_equals_failure_message_ss – miniFAVOR"},{"text":"private pure function make_equals_success_message_c(expected) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_equals_success_message_c.html","title":"make_equals_success_message_c – miniFAVOR"},{"text":"private pure function make_equals_success_message_s(expected) result(message) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_equals_success_message_s.html","title":"make_equals_success_message_s – miniFAVOR"},{"text":"private pure function make_faster_than_failure_message_ccc(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_failure_message_ccc.html","title":"make_faster_than_failure_message_ccc – miniFAVOR"},{"text":"private pure function make_faster_than_failure_message_ccs(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_failure_message_ccs.html","title":"make_faster_than_failure_message_ccs – miniFAVOR"},{"text":"private pure function make_faster_than_failure_message_csc(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_failure_message_csc.html","title":"make_faster_than_failure_message_csc – miniFAVOR"},{"text":"private pure function make_faster_than_failure_message_css(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_failure_message_css.html","title":"make_faster_than_failure_message_css – miniFAVOR"},{"text":"private pure function make_faster_than_failure_message_scc(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_failure_message_scc.html","title":"make_faster_than_failure_message_scc – miniFAVOR"},{"text":"private pure function make_faster_than_failure_message_scs(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_failure_message_scs.html","title":"make_faster_than_failure_message_scs – miniFAVOR"},{"text":"private pure function make_faster_than_failure_message_ssc(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_failure_message_ssc.html","title":"make_faster_than_failure_message_ssc – miniFAVOR"},{"text":"private pure function make_faster_than_failure_message_sss(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_failure_message_sss.html","title":"make_faster_than_failure_message_sss – miniFAVOR"},{"text":"private pure function make_faster_than_success_message_ccc(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_success_message_ccc.html","title":"make_faster_than_success_message_ccc – miniFAVOR"},{"text":"private pure function make_faster_than_success_message_ccs(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_success_message_ccs.html","title":"make_faster_than_success_message_ccs – miniFAVOR"},{"text":"private pure function make_faster_than_success_message_csc(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_success_message_csc.html","title":"make_faster_than_success_message_csc – miniFAVOR"},{"text":"private pure function make_faster_than_success_message_css(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_success_message_css.html","title":"make_faster_than_success_message_css – miniFAVOR"},{"text":"private pure function make_faster_than_success_message_scc(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_success_message_scc.html","title":"make_faster_than_success_message_scc – miniFAVOR"},{"text":"private pure function make_faster_than_success_message_scs(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_success_message_scs.html","title":"make_faster_than_success_message_scs – miniFAVOR"},{"text":"private pure function make_faster_than_success_message_ssc(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_success_message_ssc.html","title":"make_faster_than_success_message_ssc – miniFAVOR"},{"text":"private pure function make_faster_than_success_message_sss(reference, actual, iterations) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_faster_than_success_message_sss.html","title":"make_faster_than_success_message_sss – miniFAVOR"},{"text":"private pure function make_includes_failure_message_cc(search_for, string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_includes_failure_message_cc.html","title":"make_includes_failure_message_cc – miniFAVOR"},{"text":"private pure function make_includes_failure_message_cs(search_for, string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_includes_failure_message_cs.html","title":"make_includes_failure_message_cs – miniFAVOR"},{"text":"private pure function make_includes_failure_message_sc(search_for, string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_includes_failure_message_sc.html","title":"make_includes_failure_message_sc – miniFAVOR"},{"text":"private pure function make_includes_failure_message_ss(search_for, string) result(message) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_includes_failure_message_ss.html","title":"make_includes_failure_message_ss – miniFAVOR"},{"text":"private pure function make_includes_succes_message_cs(search_for, string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_includes_succes_message_cs.html","title":"make_includes_succes_message_cs – miniFAVOR"},{"text":"private pure function make_includes_succes_message_sc(search_for, string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_includes_succes_message_sc.html","title":"make_includes_succes_message_sc – miniFAVOR"},{"text":"private pure function make_includes_succes_message_ss(search_for, string) result(message) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_includes_succes_message_ss.html","title":"make_includes_succes_message_ss – miniFAVOR"},{"text":"private pure function make_includes_success_message_cc(search_for, string) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_includes_success_message_cc.html","title":"make_includes_success_message_cc – miniFAVOR"},{"text":"private pure function make_within_failure_message_ccc(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_failure_message_ccc.html","title":"make_within_failure_message_ccc – miniFAVOR"},{"text":"private pure function make_within_failure_message_ccs(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_failure_message_ccs.html","title":"make_within_failure_message_ccs – miniFAVOR"},{"text":"private pure function make_within_failure_message_csc(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_failure_message_csc.html","title":"make_within_failure_message_csc – miniFAVOR"},{"text":"private pure function make_within_failure_message_css(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_failure_message_css.html","title":"make_within_failure_message_css – miniFAVOR"},{"text":"private pure function make_within_failure_message_scc(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_failure_message_scc.html","title":"make_within_failure_message_scc – miniFAVOR"},{"text":"private pure function make_within_failure_message_scs(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_failure_message_scs.html","title":"make_within_failure_message_scs – miniFAVOR"},{"text":"private pure function make_within_failure_message_ssc(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_failure_message_ssc.html","title":"make_within_failure_message_ssc – miniFAVOR"},{"text":"private pure function make_within_failure_message_sss(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_failure_message_sss.html","title":"make_within_failure_message_sss – miniFAVOR"},{"text":"private pure function make_within_success_message_ccc(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_success_message_ccc.html","title":"make_within_success_message_ccc – miniFAVOR"},{"text":"private pure function make_within_success_message_ccs(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_success_message_ccs.html","title":"make_within_success_message_ccs – miniFAVOR"},{"text":"private pure function make_within_success_message_csc(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_success_message_csc.html","title":"make_within_success_message_csc – miniFAVOR"},{"text":"private pure function make_within_success_message_css(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_success_message_css.html","title":"make_within_success_message_css – miniFAVOR"},{"text":"private pure function make_within_success_message_scc(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_success_message_scc.html","title":"make_within_success_message_scc – miniFAVOR"},{"text":"private pure function make_within_success_message_scs(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_success_message_scs.html","title":"make_within_success_message_scs – miniFAVOR"},{"text":"private pure function make_within_success_message_ssc(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_success_message_ssc.html","title":"make_within_success_message_ssc – miniFAVOR"},{"text":"private pure function make_within_success_message_sss(expected, actual, tolerance) result(message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) Contents None","tags":"","loc":"proc/make_within_success_message_sss.html","title":"make_within_success_message_sss – miniFAVOR"},{"text":"private pure function result_failure_description(self, colorize) result(description) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) Contents None","tags":"","loc":"proc/result_failure_description.html","title":"result_failure_description – miniFAVOR"},{"text":"private pure function result_num_asserts(self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/result_num_asserts.html","title":"result_num_asserts – miniFAVOR"},{"text":"private pure function result_num_failing_asserts(self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/result_num_failing_asserts.html","title":"result_num_failing_asserts – miniFAVOR"},{"text":"private pure function result_passed(self) result(passed) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self Return Value logical Contents None","tags":"","loc":"proc/result_passed.html","title":"result_passed – miniFAVOR"},{"text":"private pure function result_verbose_description(self, colorize) result(description) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) Contents None","tags":"","loc":"proc/result_verbose_description.html","title":"result_verbose_description – miniFAVOR"},{"text":"private pure function shrink_ascii_string(input) result(shrunk) Uses iso_varying_string Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t ) Contents None","tags":"","loc":"proc/shrink_ascii_string.html","title":"shrink_ascii_string – miniFAVOR"},{"text":"private pure function shrink_integer(input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t ) Contents None","tags":"","loc":"proc/shrink_integer.html","title":"shrink_integer – miniFAVOR"},{"text":"private pure function shrink_result(value_, simplest) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: value_ logical, intent(in) :: simplest Return Value type( shrink_result_t ) Contents None","tags":"","loc":"proc/shrink_result.html","title":"shrink_result – miniFAVOR"},{"text":"private function simple_test_case(description, test) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( simple_test_case_t ) Contents None","tags":"","loc":"proc/simple_test_case.html","title":"simple_test_case – miniFAVOR"},{"text":"private function simple_test_case_run_with_input(self, input) result(result_) Arguments Type Intent Optional Attributes Name class( simple_test_case_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/simple_test_case_run_with_input.html","title":"simple_test_case_run_with_input – miniFAVOR"},{"text":"private function simple_test_case_run_without_input(self) result(result_) Arguments Type Intent Optional Attributes Name class( simple_test_case_t ), intent(in) :: self Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/simple_test_case_run_without_input.html","title":"simple_test_case_run_without_input – miniFAVOR"},{"text":"private function simple_test_collection(description, tests) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( simple_test_collection_t ) Contents None","tags":"","loc":"proc/simple_test_collection.html","title":"simple_test_collection – miniFAVOR"},{"text":"private recursive function simple_test_collection_run_with_input(self, input) result(result_) Arguments Type Intent Optional Attributes Name class( simple_test_collection_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/simple_test_collection_run_with_input.html","title":"simple_test_collection_run_with_input – miniFAVOR"},{"text":"private recursive function simple_test_collection_run_without_input(self) result(result_) Arguments Type Intent Optional Attributes Name class( simple_test_collection_t ), intent(in) :: self Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/simple_test_collection_run_without_input.html","title":"simple_test_collection_run_without_input – miniFAVOR"},{"text":"private pure function succeed_c(message) result(success) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/succeed_c.html","title":"succeed_c – miniFAVOR"},{"text":"private pure function succeed_s(message) result(success) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message Return Value type( result_t ) Contents None","tags":"","loc":"proc/succeed_s.html","title":"succeed_s – miniFAVOR"},{"text":"private pure function test_case_description(self) result(description) Uses iso_varying_string Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value type( varying_string ) Contents None","tags":"","loc":"proc/test_case_description.html","title":"test_case_description – miniFAVOR"},{"text":"private pure function test_case_filter(self, filter_string) result(filter_result) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) Contents None","tags":"","loc":"proc/test_case_filter.html","title":"test_case_filter – miniFAVOR"},{"text":"private pure function test_case_num_cases(self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_case_num_cases.html","title":"test_case_num_cases – miniFAVOR"},{"text":"private pure function test_case_result(description, result_) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( result_t ), intent(in) :: result_ Return Value type( test_case_result_t ) Contents None","tags":"","loc":"proc/test_case_result.html","title":"test_case_result – miniFAVOR"},{"text":"private pure function test_case_result_failure_description(self, colorize) result(description) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) Contents None","tags":"","loc":"proc/test_case_result_failure_description.html","title":"test_case_result_failure_description – miniFAVOR"},{"text":"private pure function test_case_result_num_asserts(self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_case_result_num_asserts.html","title":"test_case_result_num_asserts – miniFAVOR"},{"text":"private pure function test_case_result_num_cases(self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_case_result_num_cases.html","title":"test_case_result_num_cases – miniFAVOR"},{"text":"private pure function test_case_result_num_failing_asserts(self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_case_result_num_failing_asserts.html","title":"test_case_result_num_failing_asserts – miniFAVOR"},{"text":"private pure function test_case_result_num_failing_cases(self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_case_result_num_failing_cases.html","title":"test_case_result_num_failing_cases – miniFAVOR"},{"text":"private pure function test_case_result_passed(self) result(passed) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value logical Contents None","tags":"","loc":"proc/test_case_result_passed.html","title":"test_case_result_passed – miniFAVOR"},{"text":"private pure function test_case_result_verbose_description(self, colorize) result(description) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) Contents None","tags":"","loc":"proc/test_case_result_verbose_description.html","title":"test_case_result_verbose_description – miniFAVOR"},{"text":"private function test_case_with_examples(description, examples, test) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( example_t ), intent(in) :: examples (:) procedure( input_test_i ) :: test Return Value type( test_case_with_examples_t ) Contents None","tags":"","loc":"proc/test_case_with_examples.html","title":"test_case_with_examples – miniFAVOR"},{"text":"private function test_case_with_examples_run_with_input(self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_case_with_examples_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/test_case_with_examples_run_with_input.html","title":"test_case_with_examples_run_with_input – miniFAVOR"},{"text":"private function test_case_with_examples_run_without_input(self) result(result_) Arguments Type Intent Optional Attributes Name class( test_case_with_examples_t ), intent(in) :: self Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/test_case_with_examples_run_without_input.html","title":"test_case_with_examples_run_without_input – miniFAVOR"},{"text":"private function test_case_with_generator(description, generator, test) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( generator_t ), intent(in) :: generator procedure( input_test_i ) :: test Return Value type( test_case_with_generator_t ) Contents None","tags":"","loc":"proc/test_case_with_generator.html","title":"test_case_with_generator – miniFAVOR"},{"text":"private function test_case_with_generator_run_with_input(self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_case_with_generator_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/test_case_with_generator_run_with_input.html","title":"test_case_with_generator_run_with_input – miniFAVOR"},{"text":"private function test_case_with_generator_run_without_input(self) result(result_) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name class( test_case_with_generator_t ), intent(in) :: self Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/test_case_with_generator_run_without_input.html","title":"test_case_with_generator_run_without_input – miniFAVOR"},{"text":"private pure recursive function test_collection_description(self) result(description) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self Return Value type( varying_string ) Contents None","tags":"","loc":"proc/test_collection_description.html","title":"test_collection_description – miniFAVOR"},{"text":"private pure recursive function test_collection_filter(self, filter_string) result(filter_result) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) Contents None","tags":"","loc":"proc/test_collection_filter.html","title":"test_collection_filter – miniFAVOR"},{"text":"private pure recursive function test_collection_num_cases(self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_collection_num_cases.html","title":"test_collection_num_cases – miniFAVOR"},{"text":"private pure function test_collection_result(description, results) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_result_item_t ), intent(in) :: results (:) Return Value type( test_collection_result_t ) Contents None","tags":"","loc":"proc/test_collection_result.html","title":"test_collection_result – miniFAVOR"},{"text":"private pure recursive function test_collection_result_failure_description(self, colorize) result(description) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) Contents None","tags":"","loc":"proc/test_collection_result_failure_description.html","title":"test_collection_result_failure_description – miniFAVOR"},{"text":"private pure recursive function test_collection_result_num_asserts(self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_collection_result_num_asserts.html","title":"test_collection_result_num_asserts – miniFAVOR"},{"text":"private pure recursive function test_collection_result_num_cases(self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_collection_result_num_cases.html","title":"test_collection_result_num_cases – miniFAVOR"},{"text":"private pure recursive function test_collection_result_num_failing_asserts(self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_collection_result_num_failing_asserts.html","title":"test_collection_result_num_failing_asserts – miniFAVOR"},{"text":"private pure recursive function test_collection_result_num_failing_cases(self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_collection_result_num_failing_cases.html","title":"test_collection_result_num_failing_cases – miniFAVOR"},{"text":"private pure recursive function test_collection_result_passed(self) result(passed) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value logical Contents None","tags":"","loc":"proc/test_collection_result_passed.html","title":"test_collection_result_passed – miniFAVOR"},{"text":"private pure recursive function test_collection_result_verbose_description(self, colorize) result(description) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) Contents None","tags":"","loc":"proc/test_collection_result_verbose_description.html","title":"test_collection_result_verbose_description – miniFAVOR"},{"text":"private function test_collection_with_input(description, input, tests) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_collection_with_input_t ) Contents None","tags":"","loc":"proc/test_collection_with_input.html","title":"test_collection_with_input – miniFAVOR"},{"text":"private recursive function test_collection_with_input_run_with_input(self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_collection_with_input_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/test_collection_with_input_run_with_input.html","title":"test_collection_with_input_run_with_input – miniFAVOR"},{"text":"private recursive function test_collection_with_input_run_without_input(self) result(result_) Arguments Type Intent Optional Attributes Name class( test_collection_with_input_t ), intent(in) :: self Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/test_collection_with_input_run_without_input.html","title":"test_collection_with_input_run_without_input – miniFAVOR"},{"text":"private pure recursive function test_item_description(self) result(description) Uses iso_varying_string Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self Return Value type( varying_string ) Contents None","tags":"","loc":"proc/test_item_description.html","title":"test_item_description – miniFAVOR"},{"text":"private pure recursive function test_item_filter(self, filter_string) result(filter_result) Uses iso_varying_string Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_item_result_t ) Contents None","tags":"","loc":"proc/test_item_filter.html","title":"test_item_filter – miniFAVOR"},{"text":"private pure recursive function test_item_num_cases(self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_item_num_cases.html","title":"test_item_num_cases – miniFAVOR"},{"text":"private recursive function test_item_run_with_input(self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/test_item_run_with_input.html","title":"test_item_run_with_input – miniFAVOR"},{"text":"private recursive function test_item_run_without_input(self) result(result_) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/test_item_run_without_input.html","title":"test_item_run_without_input – miniFAVOR"},{"text":"private pure recursive function test_result_item_failure_description(self, colorize) result(description) Uses iso_varying_string Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) Contents None","tags":"","loc":"proc/test_result_item_failure_description.html","title":"test_result_item_failure_description – miniFAVOR"},{"text":"private pure recursive function test_result_item_num_asserts(self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_result_item_num_asserts.html","title":"test_result_item_num_asserts – miniFAVOR"},{"text":"private pure recursive function test_result_item_num_cases(self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_result_item_num_cases.html","title":"test_result_item_num_cases – miniFAVOR"},{"text":"private pure recursive function test_result_item_num_failing_asserts(self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_result_item_num_failing_asserts.html","title":"test_result_item_num_failing_asserts – miniFAVOR"},{"text":"private pure recursive function test_result_item_num_failing_cases(self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/test_result_item_num_failing_cases.html","title":"test_result_item_num_failing_cases – miniFAVOR"},{"text":"private pure recursive function test_result_item_passed(self) result(passed) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value logical Contents None","tags":"","loc":"proc/test_result_item_passed.html","title":"test_result_item_passed – miniFAVOR"},{"text":"private pure recursive function test_result_item_verbose_description(self, colorize) result(description) Uses iso_varying_string Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) Contents None","tags":"","loc":"proc/test_result_item_verbose_description.html","title":"test_result_item_verbose_description – miniFAVOR"},{"text":"private function then_basic_c(description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/then_basic_c.html","title":"then_basic_c – miniFAVOR"},{"text":"private function then_basic_s(description, test) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/then_basic_s.html","title":"then_basic_s – miniFAVOR"},{"text":"private function then_input_c(description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/then_input_c.html","title":"then_input_c – miniFAVOR"},{"text":"private function then_input_s(description, test) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/then_input_s.html","title":"then_input_s – miniFAVOR"},{"text":"private function transforming_test_collection(description, transformer, tests) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( transformer_i ) :: transformer type( test_item_t ), intent(in) :: tests (:) Return Value type( transforming_test_collection_t ) Contents None","tags":"","loc":"proc/transforming_test_collection.html","title":"transforming_test_collection – miniFAVOR"},{"text":"private recursive function transforming_test_collection_run_with_input(self, input) result(result_) Arguments Type Intent Optional Attributes Name class( transforming_test_collection_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/transforming_test_collection_run_with_input.html","title":"transforming_test_collection_run_with_input – miniFAVOR"},{"text":"private function transforming_test_collection_run_without_input(self) result(result_) Arguments Type Intent Optional Attributes Name class( transforming_test_collection_t ), intent(in) :: self Return Value type( test_result_item_t ) Contents None","tags":"","loc":"proc/transforming_test_collection_run_without_input.html","title":"transforming_test_collection_run_without_input – miniFAVOR"},{"text":"private function when_basic_c(description, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/when_basic_c.html","title":"when_basic_c – miniFAVOR"},{"text":"private function when_basic_s(description, tests) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/when_basic_s.html","title":"when_basic_s – miniFAVOR"},{"text":"private function when_with_transformer_c(description, transformer, tests) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( transformer_i ) :: transformer type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/when_with_transformer_c.html","title":"when_with_transformer_c – miniFAVOR"},{"text":"private function when_with_transformer_s(description, transformer, tests) result(item) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( transformer_i ) :: transformer type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/when_with_transformer_s.html","title":"when_with_transformer_s – miniFAVOR"},{"text":"private pure function with_user_message_cc(message, user_message) result(whole_message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message character(len=*), intent(in) :: user_message Return Value type( varying_string ) Contents None","tags":"","loc":"proc/with_user_message_cc.html","title":"with_user_message_cc – miniFAVOR"},{"text":"private pure function with_user_message_cs(message, user_message) result(whole_message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message type( varying_string ), intent(in) :: user_message Return Value type( varying_string ) Contents None","tags":"","loc":"proc/with_user_message_cs.html","title":"with_user_message_cs – miniFAVOR"},{"text":"private pure function with_user_message_sc(message, user_message) result(whole_message) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message character(len=*), intent(in) :: user_message Return Value type( varying_string ) Contents None","tags":"","loc":"proc/with_user_message_sc.html","title":"with_user_message_sc – miniFAVOR"},{"text":"private pure function with_user_message_ss(message, user_message) result(whole_message) Uses iso_varying_string strff Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message type( varying_string ), intent(in) :: user_message Return Value type( varying_string ) Contents None","tags":"","loc":"proc/with_user_message_ss.html","title":"with_user_message_ss – miniFAVOR"},{"text":"public subroutine run_tests(tests) Uses iso_fortran_env iso_varying_string strff Arguments Type Intent Optional Attributes Name type( test_item_t ), intent(in) :: tests Contents None","tags":"","loc":"proc/run_tests.html","title":"run_tests – miniFAVOR"},{"text":"public interface assert_doesnt_include Contents Module Procedures assert_doesnt_include_basic_cc assert_doesnt_include_basic_cs assert_doesnt_include_basic_sc assert_doesnt_include_basic_ss assert_doesnt_include_with_message_ccc assert_doesnt_include_with_message_ccs assert_doesnt_include_with_message_csc assert_doesnt_include_with_message_css assert_doesnt_include_with_message_scc assert_doesnt_include_with_message_scs assert_doesnt_include_with_message_ssc assert_doesnt_include_with_message_sss assert_doesnt_include_with_messages_cccc assert_doesnt_include_with_messages_cccs assert_doesnt_include_with_messages_ccsc assert_doesnt_include_with_messages_ccss assert_doesnt_include_with_messages_cscc assert_doesnt_include_with_messages_cscs assert_doesnt_include_with_messages_cssc assert_doesnt_include_with_messages_csss assert_doesnt_include_with_messages_sccc assert_doesnt_include_with_messages_sccs assert_doesnt_include_with_messages_scsc assert_doesnt_include_with_messages_scss assert_doesnt_include_with_messages_sscc assert_doesnt_include_with_messages_sscs assert_doesnt_include_with_messages_sssc assert_doesnt_include_with_messages_ssss Module Procedures private pure function assert_doesnt_include_basic_cc (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_doesnt_include_basic_cs (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_doesnt_include_basic_sc (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_doesnt_include_basic_ss (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_doesnt_include_with_message_ccc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_ccs (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_csc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_css (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_scc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_scs (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_ssc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_sss (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cccc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cccs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_ccsc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_ccss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cscc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cscs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cssc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_csss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sccc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sccs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_scsc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_scss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sscc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sscs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sssc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_ssss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t )","tags":"","loc":"interface/assert_doesnt_include.html","title":"assert_doesnt_include – miniFAVOR"},{"text":"public interface assert_empty Contents Module Procedures assert_empty_basic_c assert_empty_basic_s assert_empty_with_message_cc assert_empty_with_message_cs assert_empty_with_message_sc assert_empty_with_message_ss assert_empty_with_messages_ccc assert_empty_with_messages_ccs assert_empty_with_messages_csc assert_empty_with_messages_css assert_empty_with_messages_scc assert_empty_with_messages_scs assert_empty_with_messages_ssc assert_empty_with_messages_sss Module Procedures private pure function assert_empty_basic_c (string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_empty_basic_s (string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_empty_with_message_cc (string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_empty_with_message_cs (string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_empty_with_message_sc (string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_empty_with_message_ss (string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_empty_with_messages_ccc (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_ccs (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_csc (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_css (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_scc (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_scs (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_ssc (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_sss (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t )","tags":"","loc":"interface/assert_empty.html","title":"assert_empty – miniFAVOR"},{"text":"public interface assert_equals Contents Module Procedures assert_equals_double_precision assert_equals_double_precision_with_message_c assert_equals_double_precision_with_message_s assert_equals_double_precision_with_messages_cc assert_equals_double_precision_with_messages_cs assert_equals_double_precision_with_messages_sc assert_equals_double_precision_with_messages_ss assert_equals_integer_basic assert_equals_integer_with_message_c assert_equals_integer_with_message_s assert_equals_integer_with_messages_cc assert_equals_integer_with_messages_cs assert_equals_integer_with_messages_sc assert_equals_integer_with_messages_ss assert_equals_strings_cc assert_equals_strings_cs assert_equals_strings_sc assert_equals_strings_ss assert_equals_strings_with_message_ccc assert_equals_strings_with_message_ccs assert_equals_strings_with_message_csc assert_equals_strings_with_message_css assert_equals_strings_with_message_scc assert_equals_strings_with_message_scs assert_equals_strings_with_message_ssc assert_equals_strings_with_message_sss assert_equals_strings_with_messages_cccc assert_equals_strings_with_messages_cccs assert_equals_strings_with_messages_ccsc assert_equals_strings_with_messages_ccss assert_equals_strings_with_messages_cscc assert_equals_strings_with_messages_cscs assert_equals_strings_with_messages_cssc assert_equals_strings_with_messages_csss assert_equals_strings_with_messages_sccc assert_equals_strings_with_messages_sccs assert_equals_strings_with_messages_scsc assert_equals_strings_with_messages_scss assert_equals_strings_with_messages_sscc assert_equals_strings_with_messages_sscs assert_equals_strings_with_messages_sssc assert_equals_strings_with_messages_ssss Module Procedures private pure function assert_equals_double_precision (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_double_precision_with_message_c (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_double_precision_with_message_s (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_double_precision_with_messages_cc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_double_precision_with_messages_cs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_double_precision_with_messages_sc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_double_precision_with_messages_ss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_integer_basic (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_integer_with_message_c (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_integer_with_message_s (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_integer_with_messages_cc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_integer_with_messages_cs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_integer_with_messages_sc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_integer_with_messages_ss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_cc (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_strings_cs (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_strings_sc (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_strings_ss (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_strings_with_message_ccc (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_ccs (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_csc (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_css (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_scc (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_scs (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_ssc (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_sss (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cccc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cccs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_ccsc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_ccss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cscc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cscs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cssc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_csss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sccc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sccs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_scsc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_scss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sscc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sscs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sssc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_ssss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t )","tags":"","loc":"interface/assert_equals.html","title":"assert_equals – miniFAVOR"},{"text":"public interface assert_equals_within_absolute Contents Module Procedures assert_equals_within_absolute_basic assert_equals_within_absolute_with_message_c assert_equals_within_absolute_with_message_s assert_equals_within_absolute_with_messages_cc assert_equals_within_absolute_with_messages_cs assert_equals_within_absolute_with_messages_sc assert_equals_within_absolute_with_messages_ss Module Procedures private pure function assert_equals_within_absolute_basic (expected, actual, tolerance) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance Return Value type( result_t ) private pure function assert_equals_within_absolute_with_message_c (expected, actual, tolerance, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_message_s (expected, actual, tolerance, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_messages_cc (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_messages_cs (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_messages_sc (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_messages_ss (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t )","tags":"","loc":"interface/assert_equals_within_absolute.html","title":"assert_equals_within_absolute – miniFAVOR"},{"text":"public interface assert_equals_within_relative Contents Module Procedures assert_equals_within_relative_basic assert_equals_within_relative_with_message_c assert_equals_within_relative_with_message_s assert_equals_within_relative_with_messages_cc assert_equals_within_relative_with_messages_cs assert_equals_within_relative_with_messages_sc assert_equals_within_relative_with_messages_ss Module Procedures private pure function assert_equals_within_relative_basic (expected, actual, tolerance) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance Return Value type( result_t ) private pure function assert_equals_within_relative_with_message_c (expected, actual, tolerance, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_within_relative_with_message_s (expected, actual, tolerance, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_within_relative_with_messages_cc (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_relative_with_messages_cs (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_relative_with_messages_sc (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_relative_with_messages_ss (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t )","tags":"","loc":"interface/assert_equals_within_relative.html","title":"assert_equals_within_relative – miniFAVOR"},{"text":"public interface assert_faster_than Contents Module Procedures assert_faster_than_absolute_bracketed assert_faster_than_absolute_bracketed_with_message_c assert_faster_than_absolute_bracketed_with_message_s assert_faster_than_absolute_bracketed_with_messages_cc assert_faster_than_absolute_bracketed_with_messages_cs assert_faster_than_absolute_bracketed_with_messages_sc assert_faster_than_absolute_bracketed_with_messages_ss assert_faster_than_absolute_simple assert_faster_than_absolute_simple_with_message_c assert_faster_than_absolute_simple_with_message_s assert_faster_than_absolute_simple_with_messages_cc assert_faster_than_absolute_simple_with_messages_cs assert_faster_than_absolute_simple_with_messages_sc assert_faster_than_absolute_simple_with_messages_ss assert_faster_than_relative_bracketed assert_faster_than_relative_bracketed_with_message_c assert_faster_than_relative_bracketed_with_message_s assert_faster_than_relative_bracketed_with_messages_cc assert_faster_than_relative_bracketed_with_messages_cs assert_faster_than_relative_bracketed_with_messages_sc assert_faster_than_relative_bracketed_with_messages_ss assert_faster_than_relative_simple assert_faster_than_relative_simple_with_message_c assert_faster_than_relative_simple_with_message_s assert_faster_than_relative_simple_with_messages_cc assert_faster_than_relative_simple_with_messages_cs assert_faster_than_relative_simple_with_messages_sc assert_faster_than_relative_simple_with_messages_ss Module Procedures private function assert_faster_than_absolute_bracketed (reference, before, computation, after, iterations) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_message_c (reference, before, computation, after, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_message_s (reference, before, computation, after, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_messages_cc (reference, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_messages_cs (reference, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_messages_sc (reference, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_messages_ss (reference, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_simple (reference, computation, iterations) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_message_c (reference, computation, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_message_s (reference, computation, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_messages_cc (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_messages_cs (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_messages_sc (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_messages_ss (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_bracketed (reference_before, reference, reference_after, before, computation, after, iterations) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_message_c (reference_before, reference, reference_after, before, computation, after, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_message_s (reference_before, reference, reference_after, before, computation, after, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_messages_cc (reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_messages_cs (reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_messages_sc (reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_messages_ss (reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_simple (reference, computation, iterations) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations Return Value type( result_t ) private function assert_faster_than_relative_simple_with_message_c (reference, computation, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_message_s (reference, computation, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_messages_cc (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_messages_cs (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_messages_sc (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_messages_ss (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t )","tags":"","loc":"interface/assert_faster_than.html","title":"assert_faster_than – miniFAVOR"},{"text":"public interface assert_includes Contents Module Procedures assert_includes_cc assert_includes_cs assert_includes_sc assert_includes_ss assert_includes_with_message_ccc assert_includes_with_message_ccs assert_includes_with_message_csc assert_includes_with_message_css assert_includes_with_message_scc assert_includes_with_message_scs assert_includes_with_message_ssc assert_includes_with_message_sss assert_includes_with_messages_cccc assert_includes_with_messages_cccs assert_includes_with_messages_ccsc assert_includes_with_messages_ccss assert_includes_with_messages_cscc assert_includes_with_messages_cscs assert_includes_with_messages_cssc assert_includes_with_messages_csss assert_includes_with_messages_sccc assert_includes_with_messages_sccs assert_includes_with_messages_scsc assert_includes_with_messages_scss assert_includes_with_messages_sscc assert_includes_with_messages_sscs assert_includes_with_messages_sssc assert_includes_with_messages_ssss Module Procedures private pure function assert_includes_cc (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_includes_cs (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_includes_sc (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_includes_ss (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_includes_with_message_ccc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_ccs (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_csc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_css (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_scc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_scs (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_ssc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_sss (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_messages_cccc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_cccs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_ccsc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_ccss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_cscc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_cscs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_cssc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_csss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sccc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sccs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_scsc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_scss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sscc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sscs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sssc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_ssss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t )","tags":"","loc":"interface/assert_includes.html","title":"assert_includes – miniFAVOR"},{"text":"public interface assert_not Contents Module Procedures assert_not_basic assert_not_with_message_c assert_not_with_message_s assert_not_with_messages_cc assert_not_with_messages_cs assert_not_with_messages_sc assert_not_with_messages_ss Module Procedures private pure function assert_not_basic (condition) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition Return Value type( result_t ) private pure function assert_not_with_message_c (condition, message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_not_with_message_s (condition, message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_not_with_messages_cc (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_not_with_messages_cs (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_not_with_messages_sc (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_not_with_messages_ss (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t )","tags":"","loc":"interface/assert_not.html","title":"assert_not – miniFAVOR"},{"text":"public interface assert_that Contents Module Procedures assert_that_basic assert_that_with_message_c assert_that_with_message_s assert_that_with_messages_cc assert_that_with_messages_cs assert_that_with_messages_sc assert_that_with_messages_ss Module Procedures private pure function assert_that_basic (condition) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition Return Value type( result_t ) private pure function assert_that_with_message_c (condition, message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_that_with_message_s (condition, message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_that_with_messages_cc (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_that_with_messages_cs (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_that_with_messages_sc (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_that_with_messages_ss (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t )","tags":"","loc":"interface/assert_that.html","title":"assert_that – miniFAVOR"},{"text":"public interface delimit Contents Module Procedures delimit_c delimit_s Module Procedures private pure function delimit_c (string) result(delimited) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function delimit_s (string) result(delimited) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string )","tags":"","loc":"interface/delimit.html","title":"delimit – miniFAVOR"},{"text":"public interface describe Contents Module Procedures describe_basic_c describe_basic_s describe_with_input_c describe_with_input_s Module Procedures private function describe_basic_c (description, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function describe_basic_s (description, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function describe_with_input_c (description, input, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function describe_with_input_s (description, input, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t )","tags":"","loc":"interface/describe.html","title":"describe – miniFAVOR"},{"text":"public interface fail Contents Module Procedures fail_c fail_s Module Procedures private pure function fail_c (message) result(failure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Return Value type( result_t ) private pure function fail_s (message) result(failure) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message Return Value type( result_t )","tags":"","loc":"interface/fail.html","title":"fail – miniFAVOR"},{"text":"public interface given Contents Module Procedures given_basic_c given_basic_s given_with_input_c given_with_input_s Module Procedures private function given_basic_c (description, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function given_basic_s (description, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function given_with_input_c (description, input, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function given_with_input_s (description, input, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t )","tags":"","loc":"interface/given.html","title":"given – miniFAVOR"},{"text":"public interface it Contents Module Procedures it_basic_c it_basic_s it_with_examples_c it_with_examples_s it_with_generator_c it_with_generator_s Module Procedures private function it_basic_c (description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) private function it_basic_s (description, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) private function it_with_examples_c (description, examples, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( example_t ), intent(in) :: examples (:) procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_with_examples_s (description, examples, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( example_t ), intent(in) :: examples (:) procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_with_generator_c (description, generator, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description class( generator_t ), intent(in) :: generator procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_with_generator_s (description, generator, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( generator_t ), intent(in) :: generator procedure( input_test_i ) :: test Return Value type( test_item_t )","tags":"","loc":"interface/it.html","title":"it – miniFAVOR"},{"text":"public interface it_ Contents Module Procedures it_input_c it_input_s Module Procedures private function it_input_c (description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_input_s (description, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t )","tags":"","loc":"interface/it_.html","title":"it_ – miniFAVOR"},{"text":"public interface make_doesnt_include_failure_message Contents Module Procedures make_doesnt_include_failure_message_cc make_doesnt_include_failure_message_cs make_doesnt_include_failure_message_sc make_doesnt_include_failure_message_ss Module Procedures private pure function make_doesnt_include_failure_message_cc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_failure_message_cs (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_failure_message_sc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_failure_message_ss (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string )","tags":"","loc":"interface/make_doesnt_include_failure_message.html","title":"make_doesnt_include_failure_message – miniFAVOR"},{"text":"public interface make_doesnt_include_success_message Contents Module Procedures make_doesnt_include_success_message_cc make_doesnt_include_success_message_cs make_doesnt_include_success_message_sc make_doesnt_include_success_message_ss Module Procedures private pure function make_doesnt_include_success_message_cc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_success_message_cs (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_success_message_sc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_success_message_ss (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string )","tags":"","loc":"interface/make_doesnt_include_success_message.html","title":"make_doesnt_include_success_message – miniFAVOR"},{"text":"public interface make_empty_failure_message Contents Module Procedures make_empty_failure_message_c make_empty_failure_message_s Module Procedures private pure function make_empty_failure_message_c (string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_empty_failure_message_s (string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string )","tags":"","loc":"interface/make_empty_failure_message.html","title":"make_empty_failure_message – miniFAVOR"},{"text":"public interface make_equals_failure_message Contents Module Procedures make_equals_failure_message_cc make_equals_failure_message_cs make_equals_failure_message_sc make_equals_failure_message_ss Module Procedures private pure function make_equals_failure_message_cc (expected, actual) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( varying_string ) private pure function make_equals_failure_message_cs (expected, actual) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( varying_string ) private pure function make_equals_failure_message_sc (expected, actual) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( varying_string ) private pure function make_equals_failure_message_ss (expected, actual) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( varying_string )","tags":"","loc":"interface/make_equals_failure_message.html","title":"make_equals_failure_message – miniFAVOR"},{"text":"public interface make_equals_success_message Contents Module Procedures make_equals_success_message_c make_equals_success_message_s Module Procedures private pure function make_equals_success_message_c (expected) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected Return Value type( varying_string ) private pure function make_equals_success_message_s (expected) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected Return Value type( varying_string )","tags":"","loc":"interface/make_equals_success_message.html","title":"make_equals_success_message – miniFAVOR"},{"text":"public interface make_faster_than_failure_message Contents Module Procedures make_faster_than_failure_message_ccc make_faster_than_failure_message_ccs make_faster_than_failure_message_csc make_faster_than_failure_message_css make_faster_than_failure_message_scc make_faster_than_failure_message_scs make_faster_than_failure_message_ssc make_faster_than_failure_message_sss Module Procedures private pure function make_faster_than_failure_message_ccc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_ccs (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_csc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_css (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_scc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_scs (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_ssc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_sss (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string )","tags":"","loc":"interface/make_faster_than_failure_message.html","title":"make_faster_than_failure_message – miniFAVOR"},{"text":"public interface make_faster_than_success_message Contents Module Procedures make_faster_than_success_message_ccc make_faster_than_success_message_ccs make_faster_than_success_message_csc make_faster_than_success_message_css make_faster_than_success_message_scc make_faster_than_success_message_scs make_faster_than_success_message_ssc make_faster_than_success_message_sss Module Procedures private pure function make_faster_than_success_message_ccc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_ccs (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_csc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_css (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_scc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_scs (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_ssc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_sss (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string )","tags":"","loc":"interface/make_faster_than_success_message.html","title":"make_faster_than_success_message – miniFAVOR"},{"text":"public interface make_includes_failure_message Contents Module Procedures make_includes_failure_message_cc make_includes_failure_message_cs make_includes_failure_message_sc make_includes_failure_message_ss Module Procedures private pure function make_includes_failure_message_cc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_failure_message_cs (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_failure_message_sc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_failure_message_ss (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string )","tags":"","loc":"interface/make_includes_failure_message.html","title":"make_includes_failure_message – miniFAVOR"},{"text":"public interface make_includes_success_message Contents Module Procedures make_includes_success_message_cc make_includes_succes_message_cs make_includes_succes_message_sc make_includes_succes_message_ss Module Procedures private pure function make_includes_success_message_cc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_succes_message_cs (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_succes_message_sc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_succes_message_ss (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string )","tags":"","loc":"interface/make_includes_success_message.html","title":"make_includes_success_message – miniFAVOR"},{"text":"public interface make_within_failure_message Contents Module Procedures make_within_failure_message_ccc make_within_failure_message_ccs make_within_failure_message_csc make_within_failure_message_css make_within_failure_message_scc make_within_failure_message_scs make_within_failure_message_ssc make_within_failure_message_sss Module Procedures private pure function make_within_failure_message_ccc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_ccs (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_csc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_css (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_scc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_scs (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_ssc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_sss (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string )","tags":"","loc":"interface/make_within_failure_message.html","title":"make_within_failure_message – miniFAVOR"},{"text":"public interface make_within_success_message Contents Module Procedures make_within_success_message_ccc make_within_success_message_ccs make_within_success_message_csc make_within_success_message_css make_within_success_message_scc make_within_success_message_scs make_within_success_message_ssc make_within_success_message_sss Module Procedures private pure function make_within_success_message_ccc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_ccs (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_csc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_css (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_scc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_scs (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_ssc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_sss (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string )","tags":"","loc":"interface/make_within_success_message.html","title":"make_within_success_message – miniFAVOR"},{"text":"public interface succeed Contents Module Procedures succeed_c succeed_s Module Procedures private pure function succeed_c (message) result(success) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Return Value type( result_t ) private pure function succeed_s (message) result(success) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message Return Value type( result_t )","tags":"","loc":"interface/succeed.html","title":"succeed – miniFAVOR"},{"text":"public interface then_ Contents Module Procedures then_basic_c then_basic_s Module Procedures private function then_basic_c (description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) private function then_basic_s (description, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t )","tags":"","loc":"interface/then_.html","title":"then_ – miniFAVOR"},{"text":"public interface then__ Contents Module Procedures then_input_c then_input_s Module Procedures private function then_input_c (description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) private function then_input_s (description, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t )","tags":"","loc":"interface/then__.html","title":"then__ – miniFAVOR"},{"text":"public interface when Contents Module Procedures when_basic_c when_basic_s when_with_transformer_c when_with_transformer_s Module Procedures private function when_basic_c (description, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function when_basic_s (description, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function when_with_transformer_c (description, transformer, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( transformer_i ) :: transformer type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function when_with_transformer_s (description, transformer, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( transformer_i ) :: transformer type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t )","tags":"","loc":"interface/when.html","title":"when – miniFAVOR"},{"text":"public interface with_user_message Contents Module Procedures with_user_message_cc with_user_message_cs with_user_message_sc with_user_message_ss Module Procedures private pure function with_user_message_cc (message, user_message) result(whole_message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message character(len=*), intent(in) :: user_message Return Value type( varying_string ) private pure function with_user_message_cs (message, user_message) result(whole_message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message type( varying_string ), intent(in) :: user_message Return Value type( varying_string ) private pure function with_user_message_sc (message, user_message) result(whole_message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message character(len=*), intent(in) :: user_message Return Value type( varying_string ) private pure function with_user_message_ss (message, user_message) result(whole_message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message type( varying_string ), intent(in) :: user_message Return Value type( varying_string )","tags":"","loc":"interface/with_user_message.html","title":"with_user_message – miniFAVOR"},{"text":"subroutine run() Uses collective_subroutines_test data_partition_test object_interface_test single_image_intrinsics_test vegetables Arguments None Contents None","tags":"","loc":"proc/run~4.html","title":"run – miniFAVOR"},{"text":"public function test_findloc() result(tests) Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_findloc.html","title":"test_findloc – miniFAVOR"},{"text":"private function check_absent_back() result(result_) Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_absent_back.html","title":"check_absent_back – miniFAVOR"},{"text":"private function check_character_array() result(result_) Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_character_array.html","title":"check_character_array – miniFAVOR"},{"text":"private function check_empty_character_array() result(result_) Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_empty_character_array.html","title":"check_empty_character_array – miniFAVOR"},{"text":"private function check_false_back() result(result_) Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_false_back.html","title":"check_false_back – miniFAVOR"},{"text":"private function check_logical_argument() result(result_) Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_logical_argument.html","title":"check_logical_argument – miniFAVOR"},{"text":"private function check_nonexistent_character_value() result(result_) Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_nonexistent_character_value.html","title":"check_nonexistent_character_value – miniFAVOR"},{"text":"private function check_true_back() result(result_) Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_true_back.html","title":"check_true_back – miniFAVOR"},{"text":"private function check_zero_sized_argument() result(result_) Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_zero_sized_argument.html","title":"check_zero_sized_argument – miniFAVOR"},{"text":"public function test_object() result(tests) Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_object.html","title":"test_object – miniFAVOR"},{"text":"private function check_default_initialization() result(result_) Verify that user_defined() is .false. for a default-initialied object Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_default_initialization.html","title":"check_default_initialization – miniFAVOR"},{"text":"private function check_mark_as_defined() result(result_) Verify that mark_as_defined results in user_defined() being .true. Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_mark_as_defined.html","title":"check_mark_as_defined – miniFAVOR"},{"text":"private subroutine write_formatted(self, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( subject ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Contents None","tags":"","loc":"proc/write_formatted~2.html","title":"write_formatted – miniFAVOR"},{"text":"public function test_data_partition() result(tests) Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_data_partition.html","title":"test_data_partition – miniFAVOR"},{"text":"private function verify_all_gather_1d_real_array(unused) result(result_) values to be gathered\n values to be overwritten by the gather\n values to be overwritten by the gather Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: unused Return Value type( result_t ) Contents None","tags":"","loc":"proc/verify_all_gather_1d_real_array.html","title":"verify_all_gather_1d_real_array – miniFAVOR"},{"text":"private function verify_all_gather_2d_real_array(unused) result(result_) values to be gathered\n values to be overwritten by the gather\n values to be overwritten by the gather Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: unused Return Value type( result_t ) Contents None","tags":"","loc":"proc/verify_all_gather_2d_real_array.html","title":"verify_all_gather_2d_real_array – miniFAVOR"},{"text":"private function verify_all_gather_2d_real_array_dim1(unused) result(result_) values to be gathered\n values to be overwritten by the gather\n values to be overwritten by the gather Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: unused Return Value type( result_t ) Contents None","tags":"","loc":"proc/verify_all_gather_2d_real_array_dim1.html","title":"verify_all_gather_2d_real_array_dim1 – miniFAVOR"},{"text":"private function verify_all_particles_partitioned() result(result_) Verify that the number of particles on each image sums to the\n total number of particles distributed. Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/verify_all_particles_partitioned.html","title":"verify_all_particles_partitioned – miniFAVOR"},{"text":"private function verify_block_partitioning() result(result_) Verify that the data is partitioned across images evenly to\n within a difference of one datum between any two images. Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/verify_block_partitioning.html","title":"verify_block_partitioning – miniFAVOR"},{"text":"private function verify_gather_2d_real_array_dim1(unused) result(result_) values to be gathered\n values to be overwritten by the gather\n values to be overwritten by the gather Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: unused Return Value type( result_t ) Contents None","tags":"","loc":"proc/verify_gather_2d_real_array_dim1.html","title":"verify_gather_2d_real_array_dim1 – miniFAVOR"},{"text":"public function test_co_all() result(tests) Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_co_all.html","title":"test_co_all – miniFAVOR"},{"text":"public function test_co_sum() result(tests) Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_co_sum.html","title":"test_co_sum – miniFAVOR"},{"text":"private function check_co_all_with_all_true() result(result_) Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_co_all_with_all_true.html","title":"check_co_all_with_all_true – miniFAVOR"},{"text":"private function check_co_all_with_one_false() result(result_) Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_co_all_with_one_false.html","title":"check_co_all_with_one_false – miniFAVOR"},{"text":"private function check_co_sum_with_result_image() result(result_) Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_co_sum_with_result_image.html","title":"check_co_sum_with_result_image – miniFAVOR"},{"text":"private function check_co_sum_without_result_image() result(result_) Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_co_sum_without_result_image.html","title":"check_co_sum_without_result_image – miniFAVOR"},{"text":"interface public module subroutine co_all(boolean) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(inout) :: boolean","tags":"","loc":"interface/co_all.html","title":"co_all – miniFAVOR"},{"text":"interface public pure module function base_name(file_name) result(base) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),\n  allocatable Description result contains all characters in file_name before the first dot (.)","tags":"","loc":"interface/base_name.html","title":"base_name – miniFAVOR"},{"text":"interface public pure module function file_extension(file_name) result(extension) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),\n  allocatable Description result contains all characters in file_name after the first dot (.)","tags":"","loc":"interface/file_extension.html","title":"file_extension – miniFAVOR"},{"text":"public interface string Contents Module Procedures integer_to_string Module Procedures private interface integer_to_string () Arguments None","tags":"","loc":"interface/string.html","title":"string – miniFAVOR"},{"text":"interface private pure module function integer_to_string(integer_value) result(characters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: integer_value Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/integer_to_string.html","title":"integer_to_string – miniFAVOR"},{"text":"pure function both(lhs, rhs) result(lhs_and_rhs) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lhs logical, intent(in) :: rhs Return Value logical Contents None","tags":"","loc":"proc/both.html","title":"both – miniFAVOR"},{"text":"interface public elemental module subroutine assert(assertion, description, diagnostic_data) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(in) :: assertion Most assertions will be expressions, e.g., call assert( i>0, \"positive i\") character(len=*), intent(in) :: description Brief statement of what is being asserted class(*), intent(in), optional :: diagnostic_data Optional error stop code, which may be of intrinsic type or object class Description If assertion is .false., error-terminate with optional, variable stop code containing diagnostic_data","tags":"","loc":"interface/assert.html","title":"assert – miniFAVOR"},{"text":"interface private pure module subroutine mark_as_defined(this) Implementation → Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: this Description Mark the co_object as user-defined","tags":"","loc":"interface/mark_as_defined.html","title":"mark_as_defined – miniFAVOR"},{"text":"interface private pure module function user_defined(this) result(is_defined) Implementation → Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this Return Value logical Description Return a boolean result indicating whether this co_object has been initialized since its declaration","tags":"","loc":"interface/user_defined.html","title":"user_defined – miniFAVOR"},{"text":"interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private module subroutine define_partitions(cardinality) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: cardinality Description define the range of data identification numbers owned by the executing image","tags":"","loc":"interface/define_partitions.html","title":"define_partitions – miniFAVOR"},{"text":"interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private pure module function first(image_number) result(first_index) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer Description the result is the first identification number owned by the executing image","tags":"","loc":"interface/first.html","title":"first – miniFAVOR"},{"text":"interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private module subroutine gather_real_1d_array(a, result_image, dim) Implementation → Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim Description Gather the elements of an 1D array distributed along dimension dim onto result_image","tags":"","loc":"interface/gather_real_1d_array.html","title":"gather_real_1d_array – miniFAVOR"},{"text":"interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private module subroutine gather_real_2d_array(a, result_image, dim) Implementation → Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim Description Gather the elements of an 2D array distributed along dimension dim onto result_image","tags":"","loc":"interface/gather_real_2d_array.html","title":"gather_real_2d_array – miniFAVOR"},{"text":"interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private pure module function last(image_number) result(last_index) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer Description the result is the last identification number owned by the executing image","tags":"","loc":"interface/last.html","title":"last – miniFAVOR"},{"text":"public interface operator(.catcolumns.) Contents Module Procedures concatenate_columns Module Procedures private interface concatenate_columns () Arguments None","tags":"","loc":"interface/operator(.catcolumns.).html","title":"operator(.catcolumns.) – miniFAVOR"},{"text":"public interface operator(.catrows.) Contents Module Procedures concatenate_rows Module Procedures private interface concatenate_rows () Arguments None","tags":"","loc":"interface/operator(.catrows.).html","title":"operator(.catrows.) – miniFAVOR"},{"text":"public interface operator(.columnvectors.) Contents Module Procedures column_vectors Module Procedures private interface column_vectors () Arguments None","tags":"","loc":"interface/operator(.columnvectors.).html","title":"operator(.columnvectors.) – miniFAVOR"},{"text":"interface private pure module function column_vectors(vector_field) result(array_of_3d_column_vectors) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:,:,:) :: vector_field Return Value real,\n  dimension(:,:),allocatable Description Result is array of 3D column vectors of dimension (space_dim,nx ny nz) reshaped from vector-field argument\n of dimension (nx,ny,nz,space_dim)","tags":"","loc":"interface/column_vectors.html","title":"column_vectors – miniFAVOR"},{"text":"interface private pure module function concatenate_columns(a, b) result(concatenated) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,\n  dimension(:,:),allocatable Description Result contains the concatenation of the columns of argument a with the columns of argument b","tags":"","loc":"interface/concatenate_columns.html","title":"concatenate_columns – miniFAVOR"},{"text":"interface private pure module function concatenate_rows(a, b) result(concatenated) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,\n  dimension(:,:),allocatable Description Result contains the concatenation of the rows of argument a with the rows of argument b","tags":"","loc":"interface/concatenate_rows.html","title":"concatenate_rows – miniFAVOR"},{"text":"interface private pure module subroutine mark_as_defined(this) Implementation → Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this Description Mark the object as user-defined","tags":"","loc":"interface/mark_as_defined~2.html","title":"mark_as_defined – miniFAVOR"},{"text":"interface private pure module function user_defined(this) result(is_defined) Implementation → Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical Description Return a boolean result indicating whether this object has been initialized since its declaration","tags":"","loc":"interface/user_defined~2.html","title":"user_defined – miniFAVOR"},{"text":"pure function overflow(im, excess) result(extra_datum) Arguments Type Intent Optional Attributes Name integer, intent(in) :: im integer, intent(in) :: excess Return Value integer Contents None","tags":"","loc":"proc/overflow.html","title":"overflow – miniFAVOR"},{"text":"subroutine run() Uses hanging_indent_test indent_test join_test read_file_lines_test read_file_test split_at_test starts_with_test to_string_test vegetables Arguments None Contents None","tags":"","loc":"proc/run~5.html","title":"run – miniFAVOR"},{"text":"public function test_join() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents Source Code test_join Source Code function test_join () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( & \"for only one string returns that string\" , check_join_one ) individual_tests ( 2 ) = it ( & \"puts multiple strings together separated by the given string\" , & check_join_multiple ) tests = describe ( \"join\" , individual_tests ) end function test_join","tags":"","loc":"proc/test_join.html","title":"test_join – miniFAVOR"},{"text":"private pure function check_join_multiple() result(result_) Uses iso_varying_string strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_join_multiple.html","title":"check_join_multiple – miniFAVOR"},{"text":"private pure function check_join_one() result(result_) Uses iso_varying_string strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_join_one.html","title":"check_join_one – miniFAVOR"},{"text":"public function test_read_file_lines() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_read_file_lines.html","title":"test_read_file_lines – miniFAVOR"},{"text":"private function alt_read_file_lines(filename) result(lines) Uses iso_fortran_env iso_varying_string strff Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value type( varying_string ),\n  allocatable,(:) Contents None","tags":"","loc":"proc/alt_read_file_lines.html","title":"alt_read_file_lines – miniFAVOR"},{"text":"private function check_read_file_lines() result(result_) Uses iso_varying_string strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_read_file_lines.html","title":"check_read_file_lines – miniFAVOR"},{"text":"private function check_speed() result(result_) Uses iso_varying_string text_m vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_speed~2.html","title":"check_speed – miniFAVOR"},{"text":"public function test_to_string_for_doubles() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_to_string_for_doubles.html","title":"test_to_string_for_doubles – miniFAVOR"},{"text":"public function test_to_string_for_integers() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_to_string_for_integers.html","title":"test_to_string_for_integers – miniFAVOR"},{"text":"private pure function check_handles_extreme_numbers() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_handles_extreme_numbers.html","title":"check_handles_extreme_numbers – miniFAVOR"},{"text":"private pure function check_handles_zero() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_handles_zero.html","title":"check_handles_zero – miniFAVOR"},{"text":"private pure function check_includes_zero_after_decimal() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_includes_zero_after_decimal.html","title":"check_includes_zero_after_decimal – miniFAVOR"},{"text":"private pure function check_negative_numbers() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_negative_numbers.html","title":"check_negative_numbers – miniFAVOR"},{"text":"private pure function check_only_keeps_six_digits() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_only_keeps_six_digits.html","title":"check_only_keeps_six_digits – miniFAVOR"},{"text":"private pure function check_round_numbers() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_round_numbers.html","title":"check_round_numbers – miniFAVOR"},{"text":"private pure function checkto_string_for_integers() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/checkto_string_for_integers.html","title":"checkto_string_for_integers – miniFAVOR"},{"text":"public function test_read_file() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_read_file.html","title":"test_read_file – miniFAVOR"},{"text":"private function check_read_file() result(result_) Uses iso_varying_string strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_read_file.html","title":"check_read_file – miniFAVOR"},{"text":"public function test_indent() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_indent.html","title":"test_indent – miniFAVOR"},{"text":"private pure function check_indents_correctly() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_indents_correctly.html","title":"check_indents_correctly – miniFAVOR"},{"text":"private pure function check_single_line() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_single_line.html","title":"check_single_line – miniFAVOR"},{"text":"public function test_starts_with() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_starts_with.html","title":"test_starts_with – miniFAVOR"},{"text":"private pure function check_false() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_false.html","title":"check_false – miniFAVOR"},{"text":"private pure function check_true() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_true.html","title":"check_true – miniFAVOR"},{"text":"public function test_split_at() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents None","tags":"","loc":"proc/test_split_at.html","title":"test_split_at – miniFAVOR"},{"text":"private pure function check_for_empty_string() result(result_) Uses iso_varying_string strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_for_empty_string.html","title":"check_for_empty_string – miniFAVOR"},{"text":"private pure function check_for_only_split_characters() result(result_) Uses iso_varying_string strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_for_only_split_characters.html","title":"check_for_only_split_characters – miniFAVOR"},{"text":"private pure function check_no_empty_begin() result(result_) Uses iso_varying_string strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_no_empty_begin.html","title":"check_no_empty_begin – miniFAVOR"},{"text":"private pure function check_no_empty_between() result(result_) Uses iso_varying_string strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_no_empty_between.html","title":"check_no_empty_between – miniFAVOR"},{"text":"private pure function check_no_empty_end() result(result_) Uses iso_varying_string strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_no_empty_end.html","title":"check_no_empty_end – miniFAVOR"},{"text":"private pure function check_no_split_characters() result(result_) Uses iso_varying_string strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_no_split_characters.html","title":"check_no_split_characters – miniFAVOR"},{"text":"private pure function check_split_at_something() result(result_) Uses iso_varying_string strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_split_at_something.html","title":"check_split_at_something – miniFAVOR"},{"text":"private pure function check_split_doesnt_contain() result(result_) Uses iso_varying_string strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_split_doesnt_contain.html","title":"check_split_doesnt_contain – miniFAVOR"},{"text":"public function test_hanging_indent() result(tests) Uses vegetables Arguments None Return Value type( test_item_t ) Contents Source Code test_hanging_indent Source Code function test_hanging_indent () result ( tests ) use vegetables , only : test_item_t , describe , it type ( test_item_t ) :: tests type ( test_item_t ) :: individual_tests ( 2 ) individual_tests ( 1 ) = it ( \"does nothing to a single line\" , check_single_line ) individual_tests ( 2 ) = it ( \"indents all but the first line\" , check_indents_correctly ) tests = describe ( \"hanging_indent\" , individual_tests ) end function test_hanging_indent","tags":"","loc":"proc/test_hanging_indent.html","title":"test_hanging_indent – miniFAVOR"},{"text":"private pure function check_indents_correctly() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_indents_correctly~2.html","title":"check_indents_correctly – miniFAVOR"},{"text":"private pure function check_single_line() result(result_) Uses strff vegetables Arguments None Return Value type( result_t ) Contents None","tags":"","loc":"proc/check_single_line~2.html","title":"check_single_line – miniFAVOR"},{"text":"private pure function cover_empty_decimal_c(number) result(fixed) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: number Return Value type( varying_string ) Contents None","tags":"","loc":"proc/cover_empty_decimal_c.html","title":"cover_empty_decimal_c – miniFAVOR"},{"text":"private pure function cover_empty_decimal_s(number) result(fixed) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: number Return Value type( varying_string ) Contents None","tags":"","loc":"proc/cover_empty_decimal_s.html","title":"cover_empty_decimal_s – miniFAVOR"},{"text":"private pure function first_character_c(string) result(char_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=1) Contents None","tags":"","loc":"proc/first_character_c.html","title":"first_character_c – miniFAVOR"},{"text":"private pure function first_character_s(string) result(char_) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value character(len=1) Contents None","tags":"","loc":"proc/first_character_s.html","title":"first_character_s – miniFAVOR"},{"text":"private pure function hanging_indent_c(string, spaces) result(indented) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) Contents None","tags":"","loc":"proc/hanging_indent_c.html","title":"hanging_indent_c – miniFAVOR"},{"text":"private pure function hanging_indent_s(string, spaces) result(indented) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) Contents None","tags":"","loc":"proc/hanging_indent_s.html","title":"hanging_indent_s – miniFAVOR"},{"text":"private pure function includes_cc(within, search_for) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: within character(len=*), intent(in) :: search_for Return Value logical Contents None","tags":"","loc":"proc/includes_cc.html","title":"includes_cc – miniFAVOR"},{"text":"private pure function includes_cs(within, search_for) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: within type( varying_string ), intent(in) :: search_for Return Value logical Contents None","tags":"","loc":"proc/includes_cs.html","title":"includes_cs – miniFAVOR"},{"text":"private pure function includes_sc(within, search_for) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: within character(len=*), intent(in) :: search_for Return Value logical Contents None","tags":"","loc":"proc/includes_sc.html","title":"includes_sc – miniFAVOR"},{"text":"private pure function includes_ss(within, search_for) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: within type( varying_string ), intent(in) :: search_for Return Value logical Contents None","tags":"","loc":"proc/includes_ss.html","title":"includes_ss – miniFAVOR"},{"text":"private pure function indent_c(string, spaces) result(indented) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) Contents None","tags":"","loc":"proc/indent_c.html","title":"indent_c – miniFAVOR"},{"text":"private pure function indent_s(string, spaces) result(indented) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) Contents None","tags":"","loc":"proc/indent_s.html","title":"indent_s – miniFAVOR"},{"text":"private pure function join_c(strings, separator) result(string) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: strings (:) character(len=*), intent(in) :: separator Return Value type( varying_string ) Contents None","tags":"","loc":"proc/join_c.html","title":"join_c – miniFAVOR"},{"text":"private pure recursive function join_s(strings, separator) result(string) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: strings (:) type( varying_string ), intent(in) :: separator Return Value type( varying_string ) Contents None","tags":"","loc":"proc/join_s.html","title":"join_s – miniFAVOR"},{"text":"private pure function last_character_c(string) result(char_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=1) Contents None","tags":"","loc":"proc/last_character_c.html","title":"last_character_c – miniFAVOR"},{"text":"private pure function last_character_s(string) result(char_) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value character(len=1) Contents None","tags":"","loc":"proc/last_character_s.html","title":"last_character_s – miniFAVOR"},{"text":"private function read_file_c(filename) result(contents) Uses iso_fortran_env iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value type( varying_string ) Contents None","tags":"","loc":"proc/read_file_c.html","title":"read_file_c – miniFAVOR"},{"text":"private function read_file_lines_c(filename) result(lines) Uses iso_fortran_env iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value type( varying_string ),\n  allocatable,(:) Contents None","tags":"","loc":"proc/read_file_lines_c.html","title":"read_file_lines_c – miniFAVOR"},{"text":"private function read_file_lines_s(filename) result(lines) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename Return Value type( varying_string ),\n  allocatable,(:) Contents None","tags":"","loc":"proc/read_file_lines_s.html","title":"read_file_lines_s – miniFAVOR"},{"text":"private function read_file_s(filename) result(contents) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename Return Value type( varying_string ) Contents None","tags":"","loc":"proc/read_file_s.html","title":"read_file_s – miniFAVOR"},{"text":"private pure recursive function remove_trailing_zeros_c(number) result(trimmed) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: number Return Value type( varying_string ) Contents None","tags":"","loc":"proc/remove_trailing_zeros_c.html","title":"remove_trailing_zeros_c – miniFAVOR"},{"text":"private pure recursive function remove_trailing_zeros_s(number) result(trimmed) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: number Return Value type( varying_string ) Contents None","tags":"","loc":"proc/remove_trailing_zeros_s.html","title":"remove_trailing_zeros_s – miniFAVOR"},{"text":"private pure recursive function split_at_cc(string, split_characters) result(strings) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable,(:) Contents None","tags":"","loc":"proc/split_at_cc.html","title":"split_at_cc – miniFAVOR"},{"text":"private pure function split_at_cs(string, split_characters) result(strings) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable,(:) Contents None","tags":"","loc":"proc/split_at_cs.html","title":"split_at_cs – miniFAVOR"},{"text":"private pure recursive function split_at_sc(string, split_characters) result(strings) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable,(:) Contents None","tags":"","loc":"proc/split_at_sc.html","title":"split_at_sc – miniFAVOR"},{"text":"private pure function split_at_ss(string, split_characters) result(strings) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable,(:) Contents None","tags":"","loc":"proc/split_at_ss.html","title":"split_at_ss – miniFAVOR"},{"text":"private pure function starts_with_cc(string, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical Contents None","tags":"","loc":"proc/starts_with_cc.html","title":"starts_with_cc – miniFAVOR"},{"text":"private pure function starts_with_cs(string, substring) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: substring Return Value logical Contents None","tags":"","loc":"proc/starts_with_cs.html","title":"starts_with_cs – miniFAVOR"},{"text":"private pure function starts_with_sc(string, substring) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical Contents None","tags":"","loc":"proc/starts_with_sc.html","title":"starts_with_sc – miniFAVOR"},{"text":"private pure function starts_with_ss(string, substring) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: substring Return Value logical Contents None","tags":"","loc":"proc/starts_with_ss.html","title":"starts_with_ss – miniFAVOR"},{"text":"private pure function to_string_int16(number) result(string) Uses iso_fortran_env iso_varying_string Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: number Return Value type( varying_string ) Contents None","tags":"","loc":"proc/to_string_int16.html","title":"to_string_int16 – miniFAVOR"},{"text":"private pure function to_string_int32(number) result(string) Uses iso_fortran_env iso_varying_string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number Return Value type( varying_string ) Contents None","tags":"","loc":"proc/to_string_int32.html","title":"to_string_int32 – miniFAVOR"},{"text":"private pure function to_string_int64(number) result(string) Uses iso_fortran_env iso_varying_string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: number Return Value type( varying_string ) Contents None","tags":"","loc":"proc/to_string_int64.html","title":"to_string_int64 – miniFAVOR"},{"text":"private pure function to_string_int8(number) result(string) Uses iso_fortran_env iso_varying_string Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: number Return Value type( varying_string ) Contents None","tags":"","loc":"proc/to_string_int8.html","title":"to_string_int8 – miniFAVOR"},{"text":"private pure function to_string_logical(logical_) result(string) Uses iso_varying_string Arguments Type Intent Optional Attributes Name logical, intent(in) :: logical_ Return Value type( varying_string ) Contents None","tags":"","loc":"proc/to_string_logical.html","title":"to_string_logical – miniFAVOR"},{"text":"private pure function to_string_real32(number) result(string) Uses iso_fortran_env iso_varying_string Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: number Return Value type( varying_string ) Contents None","tags":"","loc":"proc/to_string_real32.html","title":"to_string_real32 – miniFAVOR"},{"text":"private pure function to_string_real64(number) result(string) Uses iso_fortran_env iso_varying_string Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: number Return Value type( varying_string ) Contents None","tags":"","loc":"proc/to_string_real64.html","title":"to_string_real64 – miniFAVOR"},{"text":"private pure function to_string_with_significant_digits_real32(number, significant_digits) result(string_) Uses iso_fortran_env iso_varying_string Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: number integer, intent(in) :: significant_digits Return Value type( varying_string ) Contents None","tags":"","loc":"proc/to_string_with_significant_digits_real32.html","title":"to_string_with_significant_digits_real32 – miniFAVOR"},{"text":"private pure function to_string_with_significant_digits_real64(number, significant_digits) result(string_) Uses iso_fortran_env iso_varying_string Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: number integer, intent(in) :: significant_digits Return Value type( varying_string ) Contents None","tags":"","loc":"proc/to_string_with_significant_digits_real64.html","title":"to_string_with_significant_digits_real64 – miniFAVOR"},{"text":"private pure function without_first_character_c(string) result(trimmed) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/without_first_character_c.html","title":"without_first_character_c – miniFAVOR"},{"text":"private pure function without_first_character_s(string) result(trimmed) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/without_first_character_s.html","title":"without_first_character_s – miniFAVOR"},{"text":"private pure function without_last_character_c(string) result(trimmed) Uses iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/without_last_character_c.html","title":"without_last_character_c – miniFAVOR"},{"text":"private pure function without_last_character_s(string) result(trimmed) Uses iso_varying_string Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) Contents None","tags":"","loc":"proc/without_last_character_s.html","title":"without_last_character_s – miniFAVOR"},{"text":"public interface cover_empty_decimal Contents Module Procedures cover_empty_decimal_c cover_empty_decimal_s Module Procedures private pure function cover_empty_decimal_c (number) result(fixed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: number Return Value type( varying_string ) private pure function cover_empty_decimal_s (number) result(fixed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: number Return Value type( varying_string )","tags":"","loc":"interface/cover_empty_decimal.html","title":"cover_empty_decimal – miniFAVOR"},{"text":"public interface first_character Contents Module Procedures first_character_c first_character_s Module Procedures private pure function first_character_c (string) result(char_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=1) private pure function first_character_s (string) result(char_) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value character(len=1)","tags":"","loc":"interface/first_character.html","title":"first_character – miniFAVOR"},{"text":"public interface hanging_indent Contents Module Procedures hanging_indent_c hanging_indent_s Module Procedures private pure function hanging_indent_c (string, spaces) result(indented) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) private pure function hanging_indent_s (string, spaces) result(indented) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string )","tags":"","loc":"interface/hanging_indent.html","title":"hanging_indent – miniFAVOR"},{"text":"public interface includes Contents Module Procedures includes_cc includes_cs includes_sc includes_ss Module Procedures private pure function includes_cc (within, search_for) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: within character(len=*), intent(in) :: search_for Return Value logical private pure function includes_cs (within, search_for) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: within type( varying_string ), intent(in) :: search_for Return Value logical private pure function includes_sc (within, search_for) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: within character(len=*), intent(in) :: search_for Return Value logical private pure function includes_ss (within, search_for) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: within type( varying_string ), intent(in) :: search_for Return Value logical","tags":"","loc":"interface/includes.html","title":"includes – miniFAVOR"},{"text":"public interface indent Contents Module Procedures indent_c indent_s Module Procedures private pure function indent_c (string, spaces) result(indented) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) private pure function indent_s (string, spaces) result(indented) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string )","tags":"","loc":"interface/indent.html","title":"indent – miniFAVOR"},{"text":"public interface join Contents Module Procedures join_c join_s Module Procedures private pure function join_c (strings, separator) result(string) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: strings (:) character(len=*), intent(in) :: separator Return Value type( varying_string ) private pure recursive function join_s (strings, separator) result(string) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: strings (:) type( varying_string ), intent(in) :: separator Return Value type( varying_string )","tags":"","loc":"interface/join.html","title":"join – miniFAVOR"},{"text":"public interface last_character Contents Module Procedures last_character_c last_character_s Module Procedures private pure function last_character_c (string) result(char_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=1) private pure function last_character_s (string) result(char_) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value character(len=1)","tags":"","loc":"interface/last_character.html","title":"last_character – miniFAVOR"},{"text":"public interface operator(.includes.) Contents Module Procedures includes_cc includes_cs includes_sc includes_ss Module Procedures private pure function includes_cc (within, search_for) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: within character(len=*), intent(in) :: search_for Return Value logical private pure function includes_cs (within, search_for) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: within type( varying_string ), intent(in) :: search_for Return Value logical private pure function includes_sc (within, search_for) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: within character(len=*), intent(in) :: search_for Return Value logical private pure function includes_ss (within, search_for) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: within type( varying_string ), intent(in) :: search_for Return Value logical","tags":"","loc":"interface/operator(.includes.).html","title":"operator(.includes.) – miniFAVOR"},{"text":"public interface operator(.startswith.) Contents Module Procedures starts_with_cc starts_with_cs starts_with_sc starts_with_ss Module Procedures private pure function starts_with_cc (string, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private pure function starts_with_cs (string, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: substring Return Value logical private pure function starts_with_sc (string, substring) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private pure function starts_with_ss (string, substring) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: substring Return Value logical","tags":"","loc":"interface/operator(.startswith.).html","title":"operator(.startswith.) – miniFAVOR"},{"text":"public interface read_file Contents Module Procedures read_file_c read_file_s Module Procedures private function read_file_c (filename) result(contents) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value type( varying_string ) private function read_file_s (filename) result(contents) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename Return Value type( varying_string )","tags":"","loc":"interface/read_file.html","title":"read_file – miniFAVOR"},{"text":"public interface read_file_lines Contents Module Procedures read_file_lines_c read_file_lines_s Module Procedures private function read_file_lines_c (filename) result(lines) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value type( varying_string ),\n  allocatable, (:) private function read_file_lines_s (filename) result(lines) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename Return Value type( varying_string ),\n  allocatable, (:)","tags":"","loc":"interface/read_file_lines.html","title":"read_file_lines – miniFAVOR"},{"text":"public interface remove_trailing_zeros Contents Module Procedures remove_trailing_zeros_c remove_trailing_zeros_s Module Procedures private pure recursive function remove_trailing_zeros_c (number) result(trimmed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: number Return Value type( varying_string ) private pure recursive function remove_trailing_zeros_s (number) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: number Return Value type( varying_string )","tags":"","loc":"interface/remove_trailing_zeros.html","title":"remove_trailing_zeros – miniFAVOR"},{"text":"public interface split_at Contents Module Procedures split_at_cc split_at_cs split_at_sc split_at_ss Module Procedures private pure recursive function split_at_cc (string, split_characters) result(strings) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable, (:) private pure function split_at_cs (string, split_characters) result(strings) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable, (:) private pure recursive function split_at_sc (string, split_characters) result(strings) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable, (:) private pure function split_at_ss (string, split_characters) result(strings) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable, (:)","tags":"","loc":"interface/split_at.html","title":"split_at – miniFAVOR"},{"text":"public interface to_string Contents Module Procedures to_string_int8 to_string_int16 to_string_int32 to_string_int64 to_string_logical to_string_real32 to_string_real64 to_string_with_significant_digits_real32 to_string_with_significant_digits_real64 Module Procedures private pure function to_string_int8 (number) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: number Return Value type( varying_string ) private pure function to_string_int16 (number) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: number Return Value type( varying_string ) private pure function to_string_int32 (number) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number Return Value type( varying_string ) private pure function to_string_int64 (number) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: number Return Value type( varying_string ) private pure function to_string_logical (logical_) result(string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logical_ Return Value type( varying_string ) private pure function to_string_real32 (number) result(string) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: number Return Value type( varying_string ) private pure function to_string_real64 (number) result(string) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: number Return Value type( varying_string ) private pure function to_string_with_significant_digits_real32 (number, significant_digits) result(string_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: number integer, intent(in) :: significant_digits Return Value type( varying_string ) private pure function to_string_with_significant_digits_real64 (number, significant_digits) result(string_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: number integer, intent(in) :: significant_digits Return Value type( varying_string )","tags":"","loc":"interface/to_string.html","title":"to_string – miniFAVOR"},{"text":"public interface without_first_character Contents Module Procedures without_first_character_c without_first_character_s Module Procedures private pure function without_first_character_c (string) result(trimmed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function without_first_character_s (string) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string )","tags":"","loc":"interface/without_first_character.html","title":"without_first_character – miniFAVOR"},{"text":"public interface without_last_character Contents Module Procedures without_last_character_c without_last_character_s Module Procedures private pure function without_last_character_c (string) result(trimmed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function without_last_character_s (string) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string )","tags":"","loc":"interface/without_last_character.html","title":"without_last_character – miniFAVOR"},{"text":"module procedure cu_local pure module function cu_local(self) result(self_cu_local) Interface → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real Contents None","tags":"","loc":"proc/cu_local.html","title":"cu_local – miniFAVOR"},{"text":"module procedure cu_sig_local pure module function cu_sig_local(self) result(self_cu_sig_local) Interface → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real Contents None","tags":"","loc":"proc/cu_sig_local.html","title":"cu_sig_local – miniFAVOR"},{"text":"module procedure define module subroutine define(self) Interface → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(out) :: self Contents None","tags":"","loc":"proc/define.html","title":"define – miniFAVOR"},{"text":"module procedure ni_local pure module function ni_local(self) result(self_ni_local) Interface → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real Contents None","tags":"","loc":"proc/ni_local.html","title":"ni_local – miniFAVOR"},{"text":"module procedure phi pure module function phi(self) result(self_phi) Interface → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real Contents None","tags":"","loc":"proc/phi.html","title":"phi – miniFAVOR"},{"text":"module procedure write_formatted module subroutine write_formatted(self, unit, iotype, v_list, iostat, iomsg) Interface → Uses iso_fortran_env Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Contents None","tags":"","loc":"proc/write_formatted.html","title":"write_formatted – miniFAVOR"},{"text":"module procedure mark_as_defined pure module subroutine mark_as_defined(this) Interface → Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this Contents None","tags":"","loc":"proc/mark_as_defined.html","title":"mark_as_defined – miniFAVOR"},{"text":"module procedure user_defined pure module function user_defined(this) result(is_defined) Interface → Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/user_defined.html","title":"user_defined – miniFAVOR"},{"text":"module procedure column_vectors pure module function column_vectors(vector_field) result(array_of_3d_column_vectors) Interface → Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:,:,:) :: vector_field Return Value real,\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/column_vectors.html","title":"column_vectors – miniFAVOR"},{"text":"module procedure concatenate_columns pure module function concatenate_columns(a, b) result(concatenated) Interface → Using reshape rather than manipulating array elements directly frees the compiler to decide the particular order of array\n element references that best exploits the given platform.  Alternatively, do concurrent could instead free the compiler\n to order element accesses however is best. Trade-off: reshape requires the creation of temporary array results but reshape\n is likely to have more mature compiler support than do concurrent.  If this code turns out to be a critical performance\n bottleneck, try replacing this implementation with element-by-element copying using do concurrent. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/concatenate_columns.html","title":"concatenate_columns – miniFAVOR"},{"text":"module procedure concatenate_rows pure module function concatenate_rows(a, b) result(concatenated) Interface → For simplicity, this implementation invokes concatenate_columns at the cost of transpose creating additional temporaries.\n If this code turns out to be a critical performance bottleneck, try replacing this implementation with element-by-element\n copying using do concurrent. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/concatenate_rows.html","title":"concatenate_rows – miniFAVOR"},{"text":"module procedure co_all module subroutine co_all(boolean) Interface → Arguments Type Intent Optional Attributes Name logical, intent(inout) :: boolean Contents None","tags":"","loc":"proc/co_all.html","title":"co_all – miniFAVOR"},{"text":"module procedure base_name pure module function base_name(file_name) result(base) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/base_name.html","title":"base_name – miniFAVOR"},{"text":"module procedure file_extension pure module function file_extension(file_name) result(extension) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/file_extension.html","title":"file_extension – miniFAVOR"},{"text":"module procedure integer_to_string pure module function integer_to_string(integer_value) result(characters) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: integer_value Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/integer_to_string.html","title":"integer_to_string – miniFAVOR"},{"text":"module procedure mark_as_defined pure module subroutine mark_as_defined(this) Interface → Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: this Contents None","tags":"","loc":"proc/mark_as_defined~2.html","title":"mark_as_defined – miniFAVOR"},{"text":"module procedure user_defined pure module function user_defined(this) result(is_defined) Interface → Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/user_defined~2.html","title":"user_defined – miniFAVOR"},{"text":"module procedure assert elemental module subroutine assert(assertion, description, diagnostic_data) Interface → Uses iso_fortran_env string_functions_interface object_interface Arguments Type Intent Optional Attributes Name logical, intent(in) :: assertion Most assertions will be expressions, e.g., call assert( i>0, \"positive i\") character(len=*), intent(in) :: description Brief statement of what is being asserted class(*), intent(in), optional :: diagnostic_data Optional error stop code, which may be of intrinsic type or object class Contents None","tags":"","loc":"proc/assert.html","title":"assert – miniFAVOR"},{"text":"module procedure define_partitions module subroutine define_partitions(cardinality) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: cardinality Contents None","tags":"","loc":"proc/define_partitions.html","title":"define_partitions – miniFAVOR"},{"text":"module procedure first pure module function first(image_number) result(first_index) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer Contents None","tags":"","loc":"proc/first.html","title":"first – miniFAVOR"},{"text":"module procedure gather_real_1d_array module subroutine gather_real_1d_array(a, result_image, dim) Interface → Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim Contents None","tags":"","loc":"proc/gather_real_1d_array.html","title":"gather_real_1d_array – miniFAVOR"},{"text":"module procedure gather_real_2d_array module subroutine gather_real_2d_array(a, result_image, dim) Interface → Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim Contents None","tags":"","loc":"proc/gather_real_2d_array.html","title":"gather_real_2d_array – miniFAVOR"},{"text":"module procedure last pure module function last(image_number) result(last_index) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer Contents None","tags":"","loc":"proc/last.html","title":"last – miniFAVOR"},{"text":"Contents Subroutines read_in write_out Subroutines public subroutine read_in (fn_in, n_in, n_echo, a, b, nsim, ntime, details, cu_ave, ni_ave, cu_sig, ni_sig, fsurf, rtndt0, stress, temp) Arguments Type Intent Optional Attributes Name character(len=64), intent(in) :: fn_in integer, intent(in) :: n_in integer, intent(in) :: n_echo real, intent(out) :: a real, intent(out) :: b integer, intent(out) :: nsim integer, intent(out) :: ntime logical, intent(out) :: details real, intent(out) :: cu_ave real, intent(out) :: ni_ave real, intent(out) :: cu_sig real, intent(out) :: ni_sig real, intent(out) :: fsurf real, intent(out) :: rtndt0 real, intent(out), allocatable :: stress (:) real, intent(out), allocatable :: temp (:) public subroutine write_out (fn_in, n_out, n_dat, a, b, nsim, ntime, details, cu_ave, ni_ave, cu_sig, ni_sig, fsurf, rtndt0, r_tndt, cpi, cpi_avg, k_hist, chemistry_content, chemistry_factor) Arguments Type Intent Optional Attributes Name character(len=64), intent(in) :: fn_in integer, intent(in) :: n_out integer, intent(in) :: n_dat real, intent(in) :: a real, intent(in) :: b integer, intent(in) :: nsim integer, intent(in) :: ntime logical, intent(in) :: details real, intent(in) :: cu_ave real, intent(in) :: ni_ave real, intent(in) :: cu_sig real, intent(in) :: ni_sig real, intent(in) :: fsurf real, intent(in) :: rtndt0 real, intent(in) :: r_tndt (:) real, intent(in) :: cpi (:) real, intent(in) :: cpi_avg (:) real, intent(in) :: k_hist (:) real, intent(in) :: chemistry_content (:,:) real, intent(in) :: chemistry_factor (:)","tags":"","loc":"module/i_o.html","title":"i_o – miniFAVOR"},{"text":"Uses object_interface Used by Descendants: randomness_s Contents Interfaces cu_local cu_sig_local define ni_local phi write_formatted Derived Types random_samples_t Interfaces interface private pure module function cu_local(self) result(self_cu_local) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real interface private pure module function cu_sig_local(self) result(self_cu_sig_local) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real interface private module subroutine define(self) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(out) :: self interface private pure module function ni_local(self) result(self_ni_local) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real interface private pure module function phi(self) result(self_phi) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real interface private module subroutine write_formatted(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Derived Types type, public, extends( object ) :: random_samples_t Components Type Visibility Attributes Name Initial real, private :: cu_local_ real, private :: cu_sig_local_ real, private :: ni_local_ real, private :: phi_ Type-Bound Procedures procedure, public :: cu_local procedure, public :: cu_sig_local procedure, public :: define procedure, public :: mark_as_defined procedure, public :: ni_local procedure, public :: phi procedure, public :: user_defined generic, public :: write(formatted) => write_formatted procedure, public :: write_formatted","tags":"","loc":"module/randomness_m.html","title":"randomness_m – miniFAVOR"},{"text":"Contents Variables cf_weld pi Variables Type Visibility Attributes Name Initial real, public, parameter, dimension(0:40,7) :: cf_weld = reshape((/20, 20, 21, 22, 24, 26, 29, 32, 36, 40, 44, 49, 52, 58, 61, 66, 70, 75, 79, 83, 88, 92, 97, 101, 105, 110, 113, 119, 122, 128, 131, 136, 140, 144, 149, 153, 158, 162, 166, 171, 175, 20, 20, 26, 35, 43, 49, 52, 55, 58, 61, 65, 68, 72, 76, 79, 84, 88, 92, 95, 100, 104, 108, 112, 117, 121, 126, 130, 134, 138, 142, 146, 151, 155, 160, 164, 168, 172, 177, 182, 185, 189, 20, 20, 27, 41, 54, 67, 77, 85, 90, 94, 97, 101, 103, 106, 109, 112, 115, 119, 122, 126, 129, 133, 137, 140, 144, 148, 151, 155, 160, 164, 167, 172, 175, 180, 184, 187, 191, 196, 200, 203, 207, 20, 20, 27, 41, 54, 68, 82, 95, 106, 115, 122, 130, 135, 139, 142, 146, 149, 151, 154, 157, 160, 164, 167, 169, 173, 176, 180, 184, 187, 191, 194, 198, 202, 205, 209, 212, 216, 220, 223, 227, 231, 20, 20, 27, 41, 54, 68, 82, 95, 108, 122, 133, 144, 153, 162, 168, 175, 178, 184, 187, 191, 194, 197, 200, 203, 206, 209, 212, 216, 218, 222, 225, 228, 231, 234, 238, 241, 245, 248, 250, 254, 257, 20, 20, 27, 41, 54, 68, 82, 95, 108, 122, 135, 148, 161, 172, 182, 191, 199, 207, 214, 220, 223, 229, 232, 236, 239, 243, 246, 249, 251, 254, 257, 260, 263, 266, 269, 272, 275, 278, 281, 285, 288, 20, 20, 27, 41, 54, 68, 82, 95, 108, 122, 135, 148, 161, 176, 188, 200, 211, 221, 230, 238, 245, 252, 257, 263, 268, 272, 276, 280, 284, 287, 290, 293, 296, 299, 302, 305, 308, 311, 314, 317, 320/), [41, 7]) real, public, parameter :: pi = 4.d0*datan(1.d0)","tags":"","loc":"module/constants_h.html","title":"constants_h – miniFAVOR"},{"text":"Contents Functions cpi_t Functions public function cpi_t (k, rtndt, t) Arguments Type Intent Optional Attributes Name real, intent(in) :: k real, intent(in) :: rtndt real, intent(in) :: t Return Value real","tags":"","loc":"module/calc_cpi.html","title":"calc_cpi – miniFAVOR"},{"text":"Uses assertions_interface Contents Functions cf rtndt Subroutines sample_chem Functions public function cf (cu, ni) Arguments Type Intent Optional Attributes Name real, intent(in) :: cu real, intent(in) :: ni Return Value real public function rtndt (a, cf, fsurf, rtndt0, phi) Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: cf real, intent(in) :: fsurf real, intent(in) :: rtndt0 real, intent(in) :: phi Return Value real Subroutines public subroutine sample_chem (cu_ave, ni_ave, cu_sig, ni_sig, cu_local, ni_local, samples) Arguments Type Intent Optional Attributes Name real, intent(in) :: cu_ave real, intent(in) :: ni_ave real, intent(in) :: cu_sig real, intent(in) :: ni_sig real, intent(out) :: cu_local real, intent(out) :: ni_local type( random_samples_t ), intent(in) :: samples","tags":"","loc":"module/calc_rtndt.html","title":"calc_rtndt – miniFAVOR"},{"text":"Contents Functions ki_t Functions public elemental function ki_t (a, b, stress) Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: b real, intent(in) :: stress Return Value real","tags":"","loc":"module/calc_k.html","title":"calc_k – miniFAVOR"},{"text":"Contents Functions test_many1_with_separator check_many check_many_with_separator check_none check_one check_one_with_separator parse_a parse_comma Functions public function test_many1_with_separator () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_many () result(result_) Arguments None Return Value type( result_t ) private pure function check_many_with_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_none () result(result_) Arguments None Return Value type( result_t ) private pure function check_one () result(result_) Arguments None Return Value type( result_t ) private pure function check_one_with_separator () result(result_) Arguments None Return Value type( result_t ) private pure function parse_a (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure function parse_comma (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"module/many1_with_separator_test.html","title":"many1_with_separator_test – miniFAVOR"},{"text":"Contents Functions test_parse_string check_fail check_pass Functions public function test_parse_string () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_fail () result(result_) Arguments None Return Value type( result_t ) private pure function check_pass () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/parse_string_test.html","title":"parse_string_test – miniFAVOR"},{"text":"Contents Functions test_parse_whitespace check_parse_different_character check_parse_empty_string check_parse_first_character Functions public function test_parse_whitespace () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_parse_different_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_parse_empty_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_parse_first_character () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/parse_whitespace_test.html","title":"parse_whitespace_test – miniFAVOR"},{"text":"Contents Functions test_sequence check_both_pass check_first_fail check_second_fail parse_a then_parse_b Functions public function test_sequence () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_both_pass () result(result_) Arguments None Return Value type( result_t ) private pure function check_first_fail () result(result_) Arguments None Return Value type( result_t ) private pure function check_second_fail () result(result_) Arguments None Return Value type( result_t ) private pure function parse_a (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure function then_parse_b (previous, state_) result(result_) Arguments Type Intent Optional Attributes Name class( parsed_value_t ), intent(in) :: previous type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"module/sequence_test.html","title":"sequence_test – miniFAVOR"},{"text":"Contents Functions test_many1 check_many check_none check_parse_one parse_a Functions public function test_many1 () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_many () result(result_) Arguments None Return Value type( result_t ) private pure function check_none () result(result_) Arguments None Return Value type( result_t ) private pure function check_parse_one () result(result_) Arguments None Return Value type( result_t ) private pure function parse_a (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"module/many1_test.html","title":"many1_test – miniFAVOR"},{"text":"Contents Functions test_many check_many check_none check_one parse_a Functions public function test_many () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_many () result(result_) Arguments None Return Value type( result_t ) private pure function check_none () result(result_) Arguments None Return Value type( result_t ) private pure function check_one () result(result_) Arguments None Return Value type( result_t ) private pure function parse_a (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"module/many_test.html","title":"many_test – miniFAVOR"},{"text":"Contents Functions test_repeat check_not_enough check_repeat parse_a Functions public function test_repeat () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_not_enough () result(result_) Arguments None Return Value type( result_t ) private pure function check_repeat () result(result_) Arguments None Return Value type( result_t ) private pure function parse_a (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"module/repeat_test.html","title":"repeat_test – miniFAVOR"},{"text":"Uses iso_varying_string vegetables Contents Derived Types invalid_input_t number_input_t Functions test_parse_rational check_parse_empty check_parse_invalid check_parse_rational Derived Types type, private, extends( input_t ) :: invalid_input_t Components Type Visibility Attributes Name Initial type( varying_string ), public :: string type, private, extends( input_t ) :: number_input_t Components Type Visibility Attributes Name Initial type( varying_string ), public :: string double precision, public :: value_ Functions public function test_parse_rational () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_parse_empty () result(result_) Arguments None Return Value type( result_t ) private pure function check_parse_invalid (input) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( result_t ) private pure function check_parse_rational (input) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( result_t )","tags":"","loc":"module/parse_rational_test.html","title":"parse_rational_test – miniFAVOR"},{"text":"Contents Functions test_drop_then check_both_pass check_first_fail check_second_fail parse_a parse_b Functions public function test_drop_then () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_both_pass () result(result_) Arguments None Return Value type( result_t ) private pure function check_first_fail () result(result_) Arguments None Return Value type( result_t ) private pure function check_second_fail () result(result_) Arguments None Return Value type( result_t ) private pure function parse_a (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure function parse_b (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"module/drop_then_test.html","title":"drop_then_test – miniFAVOR"},{"text":"Contents Functions test_parse_with check_failure check_successful the_parser Functions public function test_parse_with () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_failure () result(result_) Arguments None Return Value type( result_t ) private pure function check_successful () result(result_) Arguments None Return Value type( result_t ) private pure function the_parser (state) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state Return Value type( parser_output_t )","tags":"","loc":"module/parse_with_test.html","title":"parse_with_test – miniFAVOR"},{"text":"Contents Functions test_then_drop check_both_pass check_first_fail check_second_fail parse_a parse_b Functions public function test_then_drop () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_both_pass () result(result_) Arguments None Return Value type( result_t ) private pure function check_first_fail () result(result_) Arguments None Return Value type( result_t ) private pure function check_second_fail () result(result_) Arguments None Return Value type( result_t ) private pure function parse_a (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure function parse_b (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"module/then_drop_test.html","title":"then_drop_test – miniFAVOR"},{"text":"Contents Functions test_either check_both_fail check_first_pass check_second_pass parse_a parse_f Functions public function test_either () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_both_fail () result(result_) Arguments None Return Value type( result_t ) private pure function check_first_pass () result(result_) Arguments None Return Value type( result_t ) private pure function check_second_pass () result(result_) Arguments None Return Value type( result_t ) private pure function parse_a (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure function parse_f (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"module/either_test.html","title":"either_test – miniFAVOR"},{"text":"Contents Functions test_parse_character check_parse_different_character check_parse_empty_string check_parse_first_character Functions public function test_parse_character () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_parse_different_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_parse_empty_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_parse_first_character () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/parse_character_test.html","title":"parse_character_test – miniFAVOR"},{"text":"Contents Functions test_optionally check_parse_empty check_parse_fails check_parse_succeed parse_a Functions public function test_optionally () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_parse_empty () result(result_) Arguments None Return Value type( result_t ) private pure function check_parse_fails () result(result_) Arguments None Return Value type( result_t ) private pure function check_parse_succeed () result(result_) Arguments None Return Value type( result_t ) private pure function parse_a (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"module/optionally_test.html","title":"optionally_test – miniFAVOR"},{"text":"Contents Functions test_many_with_separator check_many check_many_with_separator check_none check_one check_one_with_separator parse_a parse_comma Functions public function test_many_with_separator () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_many () result(result_) Arguments None Return Value type( result_t ) private pure function check_many_with_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_none () result(result_) Arguments None Return Value type( result_t ) private pure function check_one () result(result_) Arguments None Return Value type( result_t ) private pure function check_one_with_separator () result(result_) Arguments None Return Value type( result_t ) private pure function parse_a (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure function parse_comma (state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"module/many_with_separator_test.html","title":"many_with_separator_test – miniFAVOR"},{"text":"Contents Functions test_parse_digit check_parse_different_character check_parse_empty_string check_parse_first_character Functions public function test_parse_digit () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_parse_different_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_parse_empty_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_parse_first_character () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/parse_digit_test.html","title":"parse_digit_test – miniFAVOR"},{"text":"Uses iso_varying_string vegetables Contents Derived Types invalid_input_t number_input_t Functions test_parse_integer check_parse_empty check_parse_integer check_parse_invalid Derived Types type, private, extends( input_t ) :: invalid_input_t Components Type Visibility Attributes Name Initial type( varying_string ), public :: string type, private, extends( input_t ) :: number_input_t Components Type Visibility Attributes Name Initial type( varying_string ), public :: string integer, public :: value_ Functions public function test_parse_integer () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_parse_empty () result(result_) Arguments None Return Value type( result_t ) private pure function check_parse_integer (input) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( result_t ) private pure function check_parse_invalid (input) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( result_t )","tags":"","loc":"module/parse_integer_test.html","title":"parse_integer_test – miniFAVOR"},{"text":"Uses iso_varying_string Contents Variables parsed_nothing Interfaces drop_then parse_string parse_with sequence then_drop with_label Abstract Interfaces match_i parser_i then_parser_i Derived Types intermediate_parsed_string_t intermediate_repeat_t message_t parse_result_t parsed_character_t parsed_integer_t parsed_item_t parsed_items_t parsed_nothing_t parsed_rational_t parsed_string_t parsed_value_t parser_output_t position_t state_t Functions consumed_ok either empty_error empty_ok many many1 many1_with_separator many_with_separator message new_state optionally parse_char parse_digit parse_integer parse_nothing parse_rational parse_whitespace repeat_ return_ satisfy drop_then_parser drop_then_result expect merge_ merge_error merge_ok message_to_string new_position next_position parse_string_c parse_string_s parse_with_c parse_with_s sequence_parser sequence_result state then_drop_parser then_drop_result with_label_c with_label_s Variables Type Visibility Attributes Name Initial type( parsed_nothing_t ), private, parameter :: parsed_nothing = parsed_nothing_t() Interfaces public interface drop_then private pure recursive function drop_then_parser (parser1, parser2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser1 procedure( parser_i ) :: parser2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure recursive function drop_then_result (previous, parser) result(result_) Arguments Type Intent Optional Attributes Name type( parser_output_t ), intent(in) :: previous procedure( parser_i ) :: parser Return Value type( parser_output_t ) public interface parse_string private pure function parse_string_c (string, the_state) result(the_result) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_string_s (string, the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public interface parse_with private pure function parse_with_c (parser, string) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser character(len=*), intent(in) :: string Return Value type( parse_result_t ) private pure function parse_with_s (parser, string) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser type( varying_string ), intent(in) :: string Return Value type( parse_result_t ) public interface sequence private pure recursive function sequence_parser (parser1, parser2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser1 procedure( then_parser_i ) :: parser2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure recursive function sequence_result (previous, parser) result(result_) Arguments Type Intent Optional Attributes Name type( parser_output_t ), intent(in) :: previous procedure( then_parser_i ) :: parser Return Value type( parser_output_t ) public interface then_drop private pure function then_drop_parser (parser1, parser2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser1 procedure( parser_i ) :: parser2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure function then_drop_result (previous, parser) result(result_) Arguments Type Intent Optional Attributes Name type( parser_output_t ), intent(in) :: previous procedure( parser_i ) :: parser Return Value type( parser_output_t ) public interface with_label private pure recursive function with_label_c (label, parse, state_) result(result_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label procedure( parser_i ) :: parse type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure recursive function with_label_s (label, parse, state_) result(result_) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: label procedure( parser_i ) :: parse type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Abstract Interfaces abstract interface private pure function match_i(char_) result(matches) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char_ Return Value logical abstract interface private pure function parser_i(state_) result(result_) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) abstract interface private pure function then_parser_i(previous, state_) result(result_) Arguments Type Intent Optional Attributes Name class( parsed_value_t ), intent(in) :: previous type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) Derived Types type, public, extends( parsed_value_t ) :: intermediate_parsed_string_t Components Type Visibility Attributes Name Initial type( varying_string ), public :: left_to_parse type( varying_string ), public :: parsed_so_far type, public, extends( parsed_value_t ) :: intermediate_repeat_t Components Type Visibility Attributes Name Initial type( parsed_items_t ), public :: parsed_so_far integer, public :: remaining type, public :: message_t Components Type Visibility Attributes Name Initial type( varying_string ), public, allocatable :: expected (:) type( varying_string ), public :: found type( position_t ), public :: position Type-Bound Procedures procedure, public :: to_string => message_to_string type, public :: parse_result_t Components Type Visibility Attributes Name Initial type( varying_string ), public :: message logical, public :: ok class( parsed_value_t ), public, allocatable :: parsed type, public, extends( parsed_value_t ) :: parsed_character_t Components Type Visibility Attributes Name Initial character(len=1), public :: value_ type, public, extends( parsed_value_t ) :: parsed_integer_t Components Type Visibility Attributes Name Initial integer, public :: value_ type, public :: parsed_item_t Components Type Visibility Attributes Name Initial class( parsed_value_t ), public, allocatable :: item type, public, extends( parsed_value_t ) :: parsed_items_t Components Type Visibility Attributes Name Initial type( parsed_item_t ), public, allocatable :: items (:) type, public, extends( parsed_value_t ) :: parsed_nothing_t type, public, extends( parsed_value_t ) :: parsed_rational_t Components Type Visibility Attributes Name Initial double precision, public :: value_ type, public, extends( parsed_value_t ) :: parsed_string_t Components Type Visibility Attributes Name Initial type( varying_string ), public :: value_ type, public, abstract :: parsed_value_t type, public :: parser_output_t Components Type Visibility Attributes Name Initial logical, public :: empty type( message_t ), public :: message logical, public :: ok class( parsed_value_t ), public, allocatable :: parsed type( position_t ), public :: position type( varying_string ), public :: remaining type, public :: position_t Components Type Visibility Attributes Name Initial integer, public :: column integer, public :: line type, public :: state_t Components Type Visibility Attributes Name Initial type( varying_string ), public :: input type( position_t ), public :: position Functions public pure function consumed_ok (parsed, remaining, position, message_) Arguments Type Intent Optional Attributes Name class( parsed_value_t ), intent(in) :: parsed type( varying_string ), intent(in) :: remaining type( position_t ), intent(in) :: position type( message_t ), intent(in) :: message_ Return Value type( parser_output_t ) public pure recursive function either (parse1, parse2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parse1 procedure( parser_i ) :: parse2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) public pure function empty_error (message_) Arguments Type Intent Optional Attributes Name type( message_t ), intent(in) :: message_ Return Value type( parser_output_t ) public pure function empty_ok (parsed, remaining, position, message_) Arguments Type Intent Optional Attributes Name class( parsed_value_t ), intent(in) :: parsed type( varying_string ), intent(in) :: remaining type( position_t ), intent(in) :: position type( message_t ), intent(in) :: message_ Return Value type( parser_output_t ) public pure function many (the_parser, the_state) result(the_result) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: the_parser type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public pure function many1 (the_parser, the_state) result(the_result) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: the_parser type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public pure function many1_with_separator (the_parser, the_separator, the_state) result(the_result) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: the_parser procedure( parser_i ) :: the_separator type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public pure function many_with_separator (the_parser, the_separator, the_state) result(the_result) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: the_parser procedure( parser_i ) :: the_separator type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public pure function message (position, found, expected) Arguments Type Intent Optional Attributes Name type( position_t ), intent(in) :: position type( varying_string ), intent(in) :: found type( varying_string ), intent(in) :: expected (:) Return Value type( message_t ) public pure function new_state (input) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: input Return Value type( state_t ) public pure function optionally (parser, the_state) result(the_result) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public pure function parse_char (the_char, the_state) result(the_result) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: the_char type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public pure function parse_digit (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public pure function parse_integer (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public pure function parse_nothing (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public pure function parse_rational (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public pure function parse_whitespace (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public pure function repeat_ (the_parser, times, the_state) result(the_result) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: the_parser integer, intent(in) :: times type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) public pure function return_ (parsed, state_) result(result_) Arguments Type Intent Optional Attributes Name class( parsed_value_t ), intent(in) :: parsed type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) public pure function satisfy (matches, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( match_i ) :: matches type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure recursive function drop_then_parser (parser1, parser2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser1 procedure( parser_i ) :: parser2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure recursive function drop_then_result (previous, parser) result(result_) Arguments Type Intent Optional Attributes Name type( parser_output_t ), intent(in) :: previous procedure( parser_i ) :: parser Return Value type( parser_output_t ) private pure function expect (message_, label) result(new_message) Arguments Type Intent Optional Attributes Name type( message_t ), intent(in) :: message_ type( varying_string ), intent(in) :: label Return Value type( message_t ) private pure function merge_ (message1, message2) result(merged) Arguments Type Intent Optional Attributes Name type( message_t ), intent(in) :: message1 type( message_t ), intent(in) :: message2 Return Value type( message_t ) private pure function merge_error (message1, message2) result(result_) Arguments Type Intent Optional Attributes Name type( message_t ), intent(in) :: message1 type( message_t ), intent(in) :: message2 Return Value type( parser_output_t ) private pure function merge_ok (parsed, remaining, position, message1, message2) result(result_) Arguments Type Intent Optional Attributes Name class( parsed_value_t ), intent(in) :: parsed type( varying_string ), intent(in) :: remaining type( position_t ), intent(in) :: position type( message_t ), intent(in) :: message1 type( message_t ), intent(in) :: message2 Return Value type( parser_output_t ) private pure function message_to_string (self) result(string) Arguments Type Intent Optional Attributes Name class( message_t ), intent(in) :: self Return Value type( varying_string ) private pure function new_position () Arguments None Return Value type( position_t ) private pure function next_position (char_, position) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char_ type( position_t ), intent(in) :: position Return Value type( position_t ) private pure function parse_string_c (string, the_state) result(the_result) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_string_s (string, the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_with_c (parser, string) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser character(len=*), intent(in) :: string Return Value type( parse_result_t ) private pure function parse_with_s (parser, string) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser type( varying_string ), intent(in) :: string Return Value type( parse_result_t ) private pure recursive function sequence_parser (parser1, parser2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser1 procedure( then_parser_i ) :: parser2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure recursive function sequence_result (previous, parser) result(result_) Arguments Type Intent Optional Attributes Name type( parser_output_t ), intent(in) :: previous procedure( then_parser_i ) :: parser Return Value type( parser_output_t ) private pure function state (input, position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: input type( position_t ), intent(in) :: position Return Value type( state_t ) private pure function then_drop_parser (parser1, parser2, state_) result(result_) Arguments Type Intent Optional Attributes Name procedure( parser_i ) :: parser1 procedure( parser_i ) :: parser2 type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure function then_drop_result (previous, parser) result(result_) Arguments Type Intent Optional Attributes Name type( parser_output_t ), intent(in) :: previous procedure( parser_i ) :: parser Return Value type( parser_output_t ) private pure recursive function with_label_c (label, parse, state_) result(result_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label procedure( parser_i ) :: parse type( state_t ), intent(in) :: state_ Return Value type( parser_output_t ) private pure recursive function with_label_s (label, parse, state_) result(result_) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: label procedure( parser_i ) :: parse type( state_t ), intent(in) :: state_ Return Value type( parser_output_t )","tags":"","loc":"module/parff.html","title":"parff – miniFAVOR"},{"text":"Contents Functions test_split_character check_backward_no_separator check_backward_no_separator_empty_set check_backward_no_separator_not_found check_backward_with_separator check_backward_with_separator_empty_set check_backward_with_separator_not_found check_forward_no_separator check_forward_no_separator_empty_set check_forward_no_separator_not_found check_forward_with_separator check_forward_with_separator_empty_set check_forward_with_separator_not_found check_not_backward_no_separator check_not_backward_no_separator_empty_set check_not_backward_no_separator_not_found check_not_backward_with_separator check_not_backward_with_separator_empty_set check_not_backward_with_separator_not_found Functions public function test_split_character () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_backward_no_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_backward_no_separator_empty_set () result(result_) Arguments None Return Value type( result_t ) private pure function check_backward_no_separator_not_found () result(result_) Arguments None Return Value type( result_t ) private pure function check_backward_with_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_backward_with_separator_empty_set () result(result_) Arguments None Return Value type( result_t ) private pure function check_backward_with_separator_not_found () result(result_) Arguments None Return Value type( result_t ) private pure function check_forward_no_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_forward_no_separator_empty_set () result(result_) Arguments None Return Value type( result_t ) private pure function check_forward_no_separator_not_found () result(result_) Arguments None Return Value type( result_t ) private pure function check_forward_with_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_forward_with_separator_empty_set () result(result_) Arguments None Return Value type( result_t ) private pure function check_forward_with_separator_not_found () result(result_) Arguments None Return Value type( result_t ) private pure function check_not_backward_no_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_not_backward_no_separator_empty_set () result(result_) Arguments None Return Value type( result_t ) private pure function check_not_backward_no_separator_not_found () result(result_) Arguments None Return Value type( result_t ) private pure function check_not_backward_with_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_not_backward_with_separator_empty_set () result(result_) Arguments None Return Value type( result_t ) private pure function check_not_backward_with_separator_not_found () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/split_character_set_test.html","title":"split_character_set_test – miniFAVOR"},{"text":"Contents Functions test_llt check_character_llt_string check_string_llt_character check_string_llt_string Functions public function test_llt () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_character_llt_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_llt_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_llt_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/llt_test.html","title":"llt_test – miniFAVOR"},{"text":"Uses iso_varying_string vegetables Contents Variables ascii_character_generator ascii_string_and_integer_generator ascii_string_pair_generator Derived Types ascii_character_generator_t ascii_string_and_integer_generator_t ascii_string_pair_generator_t character_input_t string_and_integer_input_t string_pair_input_t Functions generate_character generate_string_and_integer generate_string_pair shrink_character shrink_string_and_integer shrink_string_pair Variables Type Visibility Attributes Name Initial type( ascii_character_generator_t ), public, parameter :: ascii_character_generator = ascii_character_generator_t() type( ascii_string_and_integer_generator_t ), public, parameter :: ascii_string_and_integer_generator = ascii_string_and_integer_generator_t() type( ascii_string_pair_generator_t ), public, parameter :: ascii_string_pair_generator = ascii_string_pair_generator_t() Derived Types type, public, extends( generator_t ) :: ascii_character_generator_t Type-Bound Procedures procedure, public :: generate => generate_character procedure, public, nopass :: shrink => shrink_character type, public, extends( generator_t ) :: ascii_string_and_integer_generator_t Type-Bound Procedures procedure, public :: generate => generate_string_and_integer procedure, public, nopass :: shrink => shrink_string_and_integer type, public, extends( generator_t ) :: ascii_string_pair_generator_t Type-Bound Procedures procedure, public :: generate => generate_string_pair procedure, public, nopass :: shrink => shrink_string_pair type, public, extends( input_t ) :: character_input_t Components Type Visibility Attributes Name Initial character(len=1), public :: value_ type, public, extends( input_t ) :: string_and_integer_input_t Components Type Visibility Attributes Name Initial integer, public :: integer_ type( varying_string ), public :: string type, public, extends( input_t ) :: string_pair_input_t Components Type Visibility Attributes Name Initial type( varying_string ), public :: first type( varying_string ), public :: second Functions private function generate_character (self) result(generated_value) Arguments Type Intent Optional Attributes Name class( ascii_character_generator_t ), intent(in) :: self Return Value type( generated_t ) private function generate_string_and_integer (self) result(generated_value) Arguments Type Intent Optional Attributes Name class( ascii_string_and_integer_generator_t ), intent(in) :: self Return Value type( generated_t ) private function generate_string_pair (self) result(generated_value) Arguments Type Intent Optional Attributes Name class( ascii_string_pair_generator_t ), intent(in) :: self Return Value type( generated_t ) private pure function shrink_character (input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t ) private pure function shrink_string_and_integer (input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t ) private pure function shrink_string_pair (input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t )","tags":"","loc":"module/custom_generator.html","title":"custom_generator – miniFAVOR"},{"text":"Contents Functions test_adjustr check_adjustr Functions public function test_adjustr () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_adjustr (string) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t )","tags":"","loc":"module/adjustr_test.html","title":"adjustr_test – miniFAVOR"},{"text":"Contents Functions test_not_equals check_character_not_equal_string check_string_not_equal_character check_string_not_equal_string Functions public function test_not_equals () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_character_not_equal_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_not_equal_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_not_equal_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/not_equal_test.html","title":"not_equal_test – miniFAVOR"},{"text":"Contents Functions test_split_character check_backward_no_separator check_backward_no_separator_empty_set check_backward_no_separator_not_found check_backward_with_separator check_backward_with_separator_empty_set check_backward_with_separator_not_found check_forward_no_separator check_forward_no_separator_empty_set check_forward_no_separator_not_found check_forward_with_separator check_forward_with_separator_empty_set check_forward_with_separator_not_found check_not_backward_no_separator check_not_backward_no_separator_empty_set check_not_backward_no_separator_not_found check_not_backward_with_separator check_not_backward_with_separator_empty_set check_not_backward_with_separator_not_found Functions public function test_split_character () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_backward_no_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_backward_no_separator_empty_set () result(result_) Arguments None Return Value type( result_t ) private pure function check_backward_no_separator_not_found () result(result_) Arguments None Return Value type( result_t ) private pure function check_backward_with_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_backward_with_separator_empty_set () result(result_) Arguments None Return Value type( result_t ) private pure function check_backward_with_separator_not_found () result(result_) Arguments None Return Value type( result_t ) private pure function check_forward_no_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_forward_no_separator_empty_set () result(result_) Arguments None Return Value type( result_t ) private pure function check_forward_no_separator_not_found () result(result_) Arguments None Return Value type( result_t ) private pure function check_forward_with_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_forward_with_separator_empty_set () result(result_) Arguments None Return Value type( result_t ) private pure function check_forward_with_separator_not_found () result(result_) Arguments None Return Value type( result_t ) private pure function check_not_backward_no_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_not_backward_no_separator_empty_set () result(result_) Arguments None Return Value type( result_t ) private pure function check_not_backward_no_separator_not_found () result(result_) Arguments None Return Value type( result_t ) private pure function check_not_backward_with_separator () result(result_) Arguments None Return Value type( result_t ) private pure function check_not_backward_with_separator_empty_set () result(result_) Arguments None Return Value type( result_t ) private pure function check_not_backward_with_separator_not_found () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/split_string_set_test.html","title":"split_string_set_test – miniFAVOR"},{"text":"Contents Functions test_lge check_character_lge_string check_string_lge_character check_string_lge_string Functions public function test_lge () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_character_lge_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_lge_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_lge_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/lge_test.html","title":"lge_test – miniFAVOR"},{"text":"Contents Functions test_index check_index_character_and_string check_index_string_and_character check_index_strings Functions public function test_index () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_index_character_and_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_index_string_and_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_index_strings (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/index_test.html","title":"index_test – miniFAVOR"},{"text":"Contents Functions test_lgt check_character_lgt_string check_string_lgt_character check_string_lgt_string Functions public function test_lgt () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_character_lgt_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_lgt_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_lgt_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/lgt_test.html","title":"lgt_test – miniFAVOR"},{"text":"Contents Functions test_iachar check_iachar Functions public function test_iachar () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_iachar (char_) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: char_ Return Value type( result_t )","tags":"","loc":"module/iachar_test.html","title":"iachar_test – miniFAVOR"},{"text":"Contents Functions test_char check_char_with_longer_length check_char_with_negative_length check_char_with_shorter_length check_char_with_zero_length check_char_without_length Functions public function test_char () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_char_with_longer_length () result(result_) Arguments None Return Value type( result_t ) private pure function check_char_with_negative_length () result(result_) Arguments None Return Value type( result_t ) private pure function check_char_with_shorter_length () result(result_) Arguments None Return Value type( result_t ) private pure function check_char_with_zero_length () result(result_) Arguments None Return Value type( result_t ) private pure function check_char_without_length (example) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example Return Value type( result_t )","tags":"","loc":"module/char_test.html","title":"char_test – miniFAVOR"},{"text":"Contents Functions test_repeat check_repeat Functions public function test_repeat () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_repeat (example) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example Return Value type( result_t )","tags":"","loc":"module/repeat_test~2.html","title":"repeat_test – miniFAVOR"},{"text":"Contents Functions test_extract_character test_extract_string check_extract_character check_extract_character_with_finish_gt_len_string check_extract_character_with_start_lt_one check_extract_character_without_finish check_extract_character_without_start check_extract_character_zero_length check_extract_string check_extract_string_with_finish_gt_len_string check_extract_string_with_start_lt_one check_extract_string_without_finish check_extract_string_without_start check_extract_string_zero_length Functions public function test_extract_character () result(tests) Arguments None Return Value type( test_item_t ) public function test_extract_string () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_extract_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_extract_character_with_finish_gt_len_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_extract_character_with_start_lt_one () result(result_) Arguments None Return Value type( result_t ) private pure function check_extract_character_without_finish () result(result_) Arguments None Return Value type( result_t ) private pure function check_extract_character_without_start () result(result_) Arguments None Return Value type( result_t ) private pure function check_extract_character_zero_length () result(result_) Arguments None Return Value type( result_t ) private pure function check_extract_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_extract_string_with_finish_gt_len_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_extract_string_with_start_lt_one () result(result_) Arguments None Return Value type( result_t ) private pure function check_extract_string_without_finish () result(result_) Arguments None Return Value type( result_t ) private pure function check_extract_string_without_start () result(result_) Arguments None Return Value type( result_t ) private pure function check_extract_string_zero_length () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/extract_test.html","title":"extract_test – miniFAVOR"},{"text":"Contents Functions test_len check_len Functions public function test_len () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_len (string) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t )","tags":"","loc":"module/len_test.html","title":"len_test – miniFAVOR"},{"text":"Contents Functions test_replace_character_in_character_start test_replace_character_in_string_start test_replace_string_in_character_start test_replace_string_in_string_start check_replace_character_in_character check_replace_character_in_character_after check_replace_character_in_character_before check_replace_character_in_character_overrun check_replace_character_in_string check_replace_character_in_string_after check_replace_character_in_string_before check_replace_character_in_string_overrun check_replace_string_in_character check_replace_string_in_character_after check_replace_string_in_character_before check_replace_string_in_character_overrun check_replace_string_in_string check_replace_string_in_string_after check_replace_string_in_string_before check_replace_string_in_string_overrun Functions public function test_replace_character_in_character_start () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_character_in_string_start () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_string_in_character_start () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_string_in_string_start () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_replace_character_in_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_character_after () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_character_before () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_character_overrun () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_string_after () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_string_before () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_string_overrun () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_character_after () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_character_before () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_character_overrun () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_string_after () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_string_before () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_string_overrun () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/replace_start_test.html","title":"replace_start_test – miniFAVOR"},{"text":"Contents Functions test_replace_character_with_character_in_character test_replace_character_with_character_in_string test_replace_character_with_string_in_character test_replace_character_with_string_in_string test_replace_string_with_character_in_character test_replace_string_with_character_in_string test_replace_string_with_string_in_character test_replace_string_with_string_in_string check_replace_character_with_character_in_character check_replace_character_with_character_in_character_backward check_replace_character_with_character_in_character_every check_replace_character_with_character_in_string check_replace_character_with_character_in_string_backward check_replace_character_with_character_in_string_every check_replace_character_with_string_in_character check_replace_character_with_string_in_character_backward check_replace_character_with_string_in_character_every check_replace_character_with_string_in_string check_replace_character_with_string_in_string_backward check_replace_character_with_string_in_string_every check_replace_string_with_character_in_character check_replace_string_with_character_in_character_backward check_replace_string_with_character_in_character_every check_replace_string_with_character_in_string check_replace_string_with_character_in_string_backward check_replace_string_with_character_in_string_every check_replace_string_with_string_in_character check_replace_string_with_string_in_character_backward check_replace_string_with_string_in_character_every check_replace_string_with_string_in_string check_replace_string_with_string_in_string_backward check_replace_string_with_string_in_string_every Functions public function test_replace_character_with_character_in_character () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_character_with_character_in_string () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_character_with_string_in_character () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_character_with_string_in_string () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_string_with_character_in_character () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_string_with_character_in_string () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_string_with_string_in_character () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_string_with_string_in_string () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_replace_character_with_character_in_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_with_character_in_character_backward () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_with_character_in_character_every () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_with_character_in_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_with_character_in_string_backward () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_with_character_in_string_every () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_with_string_in_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_with_string_in_character_backward () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_with_string_in_character_every () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_with_string_in_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_with_string_in_string_backward () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_with_string_in_string_every () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_with_character_in_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_with_character_in_character_backward () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_with_character_in_character_every () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_with_character_in_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_with_character_in_string_backward () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_with_character_in_string_every () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_with_string_in_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_with_string_in_character_backward () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_with_string_in_character_every () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_with_string_in_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_with_string_in_string_backward () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_with_string_in_string_every () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/replace_target_test.html","title":"replace_target_test – miniFAVOR"},{"text":"Contents Functions test_greater_than_equals check_character_greater_than_equal_string check_string_greater_than_equal_character check_string_greater_than_equal_string Functions public function test_greater_than_equals () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_character_greater_than_equal_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_greater_than_equal_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_greater_than_equal_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/greater_than_equal_test.html","title":"greater_than_equal_test – miniFAVOR"},{"text":"Contents Functions test_greater_than check_character_greater_than_string check_string_greater_than_character check_string_greater_than_string Functions public function test_greater_than () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_character_greater_than_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_greater_than_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_greater_than_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/greater_than_test.html","title":"greater_than_test – miniFAVOR"},{"text":"Contents Functions test_concat check_concat_character_and_string check_concat_string_and_character check_concat_strings Functions public function test_concat () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_concat_character_and_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_concat_string_and_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_concat_strings (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/concat_test.html","title":"concat_test – miniFAVOR"},{"text":"Contents Functions test_trim check_trim Functions public function test_trim () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_trim (string) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t )","tags":"","loc":"module/trim_test.html","title":"trim_test – miniFAVOR"},{"text":"Contents Functions test_len_trim check_len_trim Functions public function test_len_trim () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_len_trim (string) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t )","tags":"","loc":"module/len_trim_test.html","title":"len_trim_test – miniFAVOR"},{"text":"Contents Functions test_insert_character_into_character test_insert_character_into_string test_insert_string_into_character test_insert_string_into_string check_insert_character_into_character check_insert_character_into_character_at_beginning check_insert_character_into_character_at_end check_insert_character_into_string check_insert_character_into_string_at_beginning check_insert_character_into_string_at_end check_insert_string_into_character check_insert_string_into_character_at_beginning check_insert_string_into_character_at_end check_insert_string_into_string check_insert_string_into_string_at_beginning check_insert_string_into_string_at_end Functions public function test_insert_character_into_character () result(tests) Arguments None Return Value type( test_item_t ) public function test_insert_character_into_string () result(tests) Arguments None Return Value type( test_item_t ) public function test_insert_string_into_character () result(tests) Arguments None Return Value type( test_item_t ) public function test_insert_string_into_string () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_insert_character_into_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_insert_character_into_character_at_beginning () result(result_) Arguments None Return Value type( result_t ) private pure function check_insert_character_into_character_at_end () result(result_) Arguments None Return Value type( result_t ) private pure function check_insert_character_into_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_insert_character_into_string_at_beginning () result(result_) Arguments None Return Value type( result_t ) private pure function check_insert_character_into_string_at_end () result(result_) Arguments None Return Value type( result_t ) private pure function check_insert_string_into_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_insert_string_into_character_at_beginning () result(result_) Arguments None Return Value type( result_t ) private pure function check_insert_string_into_character_at_end () result(result_) Arguments None Return Value type( result_t ) private pure function check_insert_string_into_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_insert_string_into_string_at_beginning () result(result_) Arguments None Return Value type( result_t ) private pure function check_insert_string_into_string_at_end () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/insert_test.html","title":"insert_test – miniFAVOR"},{"text":"Contents Functions test_scan check_scan_character_and_string check_scan_string_and_character check_scan_strings Functions public function test_scan () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_scan_character_and_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_scan_string_and_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_scan_strings (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/scan_test.html","title":"scan_test – miniFAVOR"},{"text":"Contents Functions test_less_than_equals check_character_less_than_equal_string check_string_less_than_equal_character check_string_less_than_equal_string Functions public function test_less_than_equals () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_character_less_than_equal_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_less_than_equal_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_less_than_equal_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/less_than_equal_test.html","title":"less_than_equal_test – miniFAVOR"},{"text":"Contents Functions test_assignment check_assign_character_to_string check_assign_string_to_string check_assign_to_longer_character check_assign_to_shorter_character Functions public function test_assignment () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_assign_character_to_string (string) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t ) private pure function check_assign_string_to_string (string) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t ) private pure function check_assign_to_longer_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_assign_to_shorter_character () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/assignment_test.html","title":"assignment_test – miniFAVOR"},{"text":"Contents Functions test_ichar check_ichar Functions public function test_ichar () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_ichar (char_) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: char_ Return Value type( result_t )","tags":"","loc":"module/ichar_test.html","title":"ichar_test – miniFAVOR"},{"text":"Contents Functions test_lle check_character_lle_string check_string_lle_character check_string_lle_string Functions public function test_lle () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_character_lle_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_lle_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_lle_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/lle_test.html","title":"lle_test – miniFAVOR"},{"text":"Contents Functions test_less_than check_character_less_than_string check_string_less_than_character check_string_less_than_string Functions public function test_less_than () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_character_less_than_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_less_than_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_less_than_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/less_than_test.html","title":"less_than_test – miniFAVOR"},{"text":"Contents Functions test_remove_character test_remove_string check_remove_character check_remove_character_with_finish_gt_len_string check_remove_character_with_start_lt_one check_remove_character_without_finish check_remove_character_without_start check_remove_character_zero_length check_remove_string check_remove_string_with_finish_gt_len_string check_remove_string_with_start_lt_one check_remove_string_without_finish check_remove_string_without_start check_remove_string_zero_length Functions public function test_remove_character () result(tests) Arguments None Return Value type( test_item_t ) public function test_remove_string () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_remove_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_remove_character_with_finish_gt_len_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_remove_character_with_start_lt_one () result(result_) Arguments None Return Value type( result_t ) private pure function check_remove_character_without_finish () result(result_) Arguments None Return Value type( result_t ) private pure function check_remove_character_without_start () result(result_) Arguments None Return Value type( result_t ) private pure function check_remove_character_zero_length () result(result_) Arguments None Return Value type( result_t ) private pure function check_remove_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_remove_string_with_finish_gt_len_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_remove_string_with_start_lt_one () result(result_) Arguments None Return Value type( result_t ) private pure function check_remove_string_without_finish () result(result_) Arguments None Return Value type( result_t ) private pure function check_remove_string_without_start () result(result_) Arguments None Return Value type( result_t ) private pure function check_remove_string_zero_length () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/remove_test.html","title":"remove_test – miniFAVOR"},{"text":"Contents Functions test_verify check_verify_character_and_string check_verify_string_and_character check_verify_strings Functions public function test_verify () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_verify_character_and_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_verify_string_and_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_verify_strings (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/verify_test.html","title":"verify_test – miniFAVOR"},{"text":"Contents Functions test_equals check_character_equal_string check_string_equal_character check_string_equal_string Functions public function test_equals () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_character_equal_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_equal_character (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t ) private pure function check_string_equal_string (strings) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: strings Return Value type( result_t )","tags":"","loc":"module/equal_test.html","title":"equal_test – miniFAVOR"},{"text":"Contents Functions test_replace_character_in_character_range test_replace_character_in_string_range test_replace_string_in_character_range test_replace_string_in_string_range check_replace_character_in_character check_replace_character_in_character_start_gt_end check_replace_character_in_character_start_gt_finish check_replace_character_in_character_start_lt_one check_replace_character_in_string check_replace_character_in_string_start_gt_end check_replace_character_in_string_start_gt_finish check_replace_character_in_string_start_lt_one check_replace_string_in_character check_replace_string_in_character_start_gt_end check_replace_string_in_character_start_gt_finish check_replace_string_in_character_start_lt_one check_replace_string_in_string check_replace_string_in_string_start_gt_end check_replace_string_in_string_start_gt_finish check_replace_string_in_string_start_lt_one Functions public function test_replace_character_in_character_range () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_character_in_string_range () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_string_in_character_range () result(tests) Arguments None Return Value type( test_item_t ) public function test_replace_string_in_string_range () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_replace_character_in_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_character_start_gt_end () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_character_start_gt_finish () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_character_start_lt_one () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_string_start_gt_end () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_string_start_gt_finish () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_character_in_string_start_lt_one () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_character () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_character_start_gt_end () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_character_start_gt_finish () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_character_start_lt_one () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_string_start_gt_end () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_string_start_gt_finish () result(result_) Arguments None Return Value type( result_t ) private pure function check_replace_string_in_string_start_lt_one () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/replace_range_test.html","title":"replace_range_test – miniFAVOR"},{"text":"Contents Functions test_var_str check_var_str Functions public function test_var_str () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_var_str (string) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t )","tags":"","loc":"module/var_str_test.html","title":"var_str_test – miniFAVOR"},{"text":"Contents Functions test_adjustl check_adjustl Functions public function test_adjustl () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_adjustl (string) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: string Return Value type( result_t )","tags":"","loc":"module/adjustl_test.html","title":"adjustl_test – miniFAVOR"},{"text":"Contents Interfaces adjustl adjustr assignment(=) char extract get iachar ichar index insert len len_trim lge lgt lle llt operator(//) operator(/=) operator(<) operator(<=) operator(==) operator(>) operator(>=) put put_line remove repeat replace scan split trim verify Derived Types varying_string Functions var_str character_eq_string character_ge_string character_gt_string character_index_string character_le_string character_lge_string character_lgt_string character_lle_string character_llt_string character_lt_string character_ne_string character_scan_string character_verify_string concat_character_and_string concat_string_and_character concat_strings extract_character extract_string insert_character_into_character insert_character_into_string insert_string_into_character insert_string_into_string len_string len_trim_string remove_character remove_string replace_character_with_character_range replace_character_with_character_start replace_character_with_string_range replace_character_with_string_start replace_string_with_character_range replace_string_with_character_start replace_string_with_string_range replace_string_with_string_start replace_target_character_with_character_in_character replace_target_character_with_character_in_string replace_target_character_with_string_in_character replace_target_character_with_string_in_string replace_target_string_with_character_in_character replace_target_string_with_character_in_string replace_target_string_with_string_in_character replace_target_string_with_string_in_string string_adjustl string_adjustr string_eq_character string_eq_string string_ge_character string_ge_string string_gt_character string_gt_string string_iachar string_ichar string_index_character string_index_string string_le_character string_le_string string_lge_character string_lge_string string_lgt_character string_lgt_string string_lle_character string_lle_string string_llt_character string_llt_string string_lt_character string_lt_string string_ne_character string_ne_string string_repeat string_scan_character string_scan_string string_to_char string_to_char_with_length string_verify_character string_verify_string trim_string Subroutines assign_character_to_string assign_string_to_character get_default_unit_to_end_of_record get_default_unit_to_terminator_characters get_default_unit_to_terminator_string get_with_unit_to_end_of_record get_with_unit_to_terminator_characters get_with_unit_to_terminator_string put_characters_default_unit put_characters_with_unit put_line_characters_default_unit put_line_characters_with_unit put_line_string_default_unit put_line_string_with_unit put_string_default_unit put_string_with_unit split_character split_string Interfaces public interface adjustl private elemental function string_adjustl (string) result(adjusted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) public interface adjustr private elemental function string_adjustr (string) result(adjusted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) public interface assignment(=) private elemental subroutine assign_character_to_string (lhs, rhs) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: lhs character(len=*), intent(in) :: rhs private elemental subroutine assign_string_to_character (lhs, rhs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: lhs type( varying_string ), intent(in) :: rhs public interface char private pure function string_to_char (string) result(chars) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value character(len=:),\n  allocatable private pure function string_to_char_with_length (string, length) result(chars) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: length Return Value character(len=length) public interface extract private elemental function extract_character (string, start, finish) result(extracted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) private elemental function extract_string (string, start, finish) result(extracted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) public interface get private subroutine get_default_unit_to_end_of_record (string, maxlen, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: string integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_with_unit_to_end_of_record (unit, string, maxlen, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(out) :: string integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_default_unit_to_terminator_string (string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: string type( varying_string ), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_with_unit_to_terminator_string (unit, string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(out) :: string type( varying_string ), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_default_unit_to_terminator_characters (string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: string character(len=*), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_with_unit_to_terminator_characters (unit, string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(out) :: string character(len=*), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat public interface iachar private elemental function string_iachar (c) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: c Return Value integer public interface ichar private elemental function string_ichar (c) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: c Return Value integer public interface index private elemental function string_index_string (string, substring, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function string_index_character (string, substring, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function character_index_string (string, substring, back) result(position) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public interface insert private elemental function insert_character_into_character (string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function insert_character_into_string (string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function insert_string_into_character (string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function insert_string_into_string (string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) public interface len private elemental function len_string (string) result(length) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value integer public interface len_trim private elemental function len_trim_string (string) result(length) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value integer public interface lge private elemental function string_lge_string (string_a, string_b) result(greater_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function character_lge_string (string_a, string_b) result(greater_than_or_equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function string_lge_character (string_a, string_b) result(greater_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical public interface lgt private elemental function string_lgt_string (string_a, string_b) result(greater_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function character_lgt_string (string_a, string_b) result(greater_than) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function string_lgt_character (string_a, string_b) result(greater_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical public interface lle private elemental function string_lle_string (string_a, string_b) result(less_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function character_lle_string (string_a, string_b) result(less_than_or_equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function string_lle_character (string_a, string_b) result(less_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical public interface llt private elemental function string_llt_string (string_a, string_b) result(less_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function character_llt_string (string_a, string_b) result(less_than) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function string_llt_character (string_a, string_b) result(less_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical public interface operator(//) private elemental function concat_strings (lhs, rhs) result(concatenated) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value type( varying_string ) private elemental function concat_string_and_character (lhs, rhs) result(concatenated) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( varying_string ) private elemental function concat_character_and_string (lhs, rhs) result(concatenated) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value type( varying_string ) public interface operator(/=) private elemental function string_ne_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_ne_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_ne_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical public interface operator(<) private elemental function string_lt_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_lt_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_lt_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical public interface operator(<=) private elemental function string_le_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_le_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_le_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical public interface operator(==) private elemental function string_eq_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_eq_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_eq_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical public interface operator(>) private elemental function string_gt_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_gt_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_gt_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical public interface operator(>=) private elemental function string_ge_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_ge_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_ge_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical public interface put private subroutine put_string_default_unit (string, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_string_with_unit (unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_characters_default_unit (string, iostat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_characters_with_unit (unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=*), intent(in) :: string integer, intent(out), optional :: iostat public interface put_line private subroutine put_line_string_default_unit (string, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_line_string_with_unit (unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_line_characters_default_unit (string, iostat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_line_characters_with_unit (unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=*), intent(in) :: string integer, intent(out), optional :: iostat public interface remove private elemental function remove_character (string, start, finish) result(removed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) private elemental function remove_string (string, start, finish) result(removed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) public interface repeat private elemental function string_repeat (string, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( varying_string ) public interface replace private elemental function replace_character_with_character_start (string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_string_with_character_start (string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_character_with_string_start (string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_string_with_string_start (string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_character_with_character_range (string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_string_with_character_range (string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_character_with_string_range (string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_string_with_string_range (string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_target_character_with_character_in_character (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_character_with_character_in_string (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_character_with_string_in_character (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_character_with_string_in_string (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_string_with_character_in_character (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_string_with_character_in_string (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_string_with_string_in_character (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_string_with_string_in_string (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) public interface scan private elemental function string_scan_string (string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function string_scan_character (string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function character_scan_string (string, set, back) result(position) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public interface split private elemental subroutine split_character (string, word, set, separator, back) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(inout) :: string type( varying_string ), intent(out) :: word character(len=*), intent(in) :: set type( varying_string ), intent(out), optional :: separator logical, intent(in), optional :: back private elemental subroutine split_string (string, word, set, separator, back) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(inout) :: string type( varying_string ), intent(out) :: word type( varying_string ), intent(in) :: set type( varying_string ), intent(out), optional :: separator logical, intent(in), optional :: back public interface trim private elemental function trim_string (string) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) public interface verify private elemental function string_verify_string (string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function string_verify_character (string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function character_verify_string (string, set, back) result(position) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Derived Types type, public :: varying_string Components Type Visibility Attributes Name Initial character(len=1), private, allocatable :: characters (:) Functions public elemental function var_str (char) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: char Return Value type( varying_string ) private elemental function character_eq_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_ge_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_gt_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_index_string (string, substring, back) result(position) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function character_le_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_lge_string (string_a, string_b) result(greater_than_or_equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function character_lgt_string (string_a, string_b) result(greater_than) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function character_lle_string (string_a, string_b) result(less_than_or_equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function character_llt_string (string_a, string_b) result(less_than) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function character_lt_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_ne_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function character_scan_string (string, set, back) result(position) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function character_verify_string (string, set, back) result(position) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function concat_character_and_string (lhs, rhs) result(concatenated) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value type( varying_string ) private elemental function concat_string_and_character (lhs, rhs) result(concatenated) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( varying_string ) private elemental function concat_strings (lhs, rhs) result(concatenated) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value type( varying_string ) private elemental function extract_character (string, start, finish) result(extracted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) private elemental function extract_string (string, start, finish) result(extracted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) private elemental function insert_character_into_character (string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function insert_character_into_string (string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function insert_string_into_character (string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function insert_string_into_string (string, start, substring) result(inserted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function len_string (string) result(length) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value integer private elemental function len_trim_string (string) result(length) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value integer private elemental function remove_character (string, start, finish) result(removed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) private elemental function remove_string (string, start, finish) result(removed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in), optional :: start integer, intent(in), optional :: finish Return Value type( varying_string ) private elemental function replace_character_with_character_range (string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_character_with_character_start (string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_character_with_string_range (string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_character_with_string_start (string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_string_with_character_range (string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_string_with_character_start (string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start character(len=*), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_string_with_string_range (string, start, finish, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: finish type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_string_with_string_start (string, start, substring) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: start type( varying_string ), intent(in) :: substring Return Value type( varying_string ) private elemental function replace_target_character_with_character_in_character (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_character_with_character_in_string (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_character_with_string_in_character (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_character_with_string_in_string (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_string_with_character_in_character (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_string_with_character_in_string (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: target character(len=*), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_string_with_string_in_character (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function replace_target_string_with_string_in_string (string, target, substring, every, back) result(replaced) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: target type( varying_string ), intent(in) :: substring logical, intent(in), optional :: every logical, intent(in), optional :: back Return Value type( varying_string ) private elemental function string_adjustl (string) result(adjusted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) private elemental function string_adjustr (string) result(adjusted) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) private elemental function string_eq_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function string_eq_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_ge_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function string_ge_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_gt_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function string_gt_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_iachar (c) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: c Return Value integer private elemental function string_ichar (c) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: c Return Value integer private elemental function string_index_character (string, substring, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function string_index_string (string, substring, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function string_le_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function string_le_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_lge_character (string_a, string_b) result(greater_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical private elemental function string_lge_string (string_a, string_b) result(greater_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function string_lgt_character (string_a, string_b) result(greater_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical private elemental function string_lgt_string (string_a, string_b) result(greater_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function string_lle_character (string_a, string_b) result(less_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical private elemental function string_lle_string (string_a, string_b) result(less_than_or_equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function string_llt_character (string_a, string_b) result(less_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a character(len=*), intent(in) :: string_b Return Value logical private elemental function string_llt_string (string_a, string_b) result(less_than) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string_a type( varying_string ), intent(in) :: string_b Return Value logical private elemental function string_lt_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function string_lt_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_ne_character (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function string_ne_string (lhs, rhs) result(equals) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: lhs type( varying_string ), intent(in) :: rhs Return Value logical private elemental function string_repeat (string, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( varying_string ) private elemental function string_scan_character (string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function string_scan_string (string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private pure function string_to_char (string) result(chars) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value character(len=:),\n  allocatable private pure function string_to_char_with_length (string, length) result(chars) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: length Return Value character(len=length) private elemental function string_verify_character (string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function string_verify_string (string, set, back) result(position) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function trim_string (string) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) Subroutines private elemental subroutine assign_character_to_string (lhs, rhs) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: lhs character(len=*), intent(in) :: rhs private elemental subroutine assign_string_to_character (lhs, rhs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: lhs type( varying_string ), intent(in) :: rhs private subroutine get_default_unit_to_end_of_record (string, maxlen, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: string integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_default_unit_to_terminator_characters (string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: string character(len=*), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_default_unit_to_terminator_string (string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(out) :: string type( varying_string ), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_with_unit_to_end_of_record (unit, string, maxlen, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(out) :: string integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_with_unit_to_terminator_characters (unit, string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(out) :: string character(len=*), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine get_with_unit_to_terminator_string (unit, string, set, separator, maxlen, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(out) :: string type( varying_string ), intent(in) :: set type( varying_string ), intent(out), optional :: separator integer, intent(in), optional :: maxlen integer, intent(out), optional :: iostat private subroutine put_characters_default_unit (string, iostat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_characters_with_unit (unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=*), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_line_characters_default_unit (string, iostat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_line_characters_with_unit (unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=*), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_line_string_default_unit (string, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_line_string_with_unit (unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_string_default_unit (string, iostat) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat private subroutine put_string_with_unit (unit, string, iostat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( varying_string ), intent(in) :: string integer, intent(out), optional :: iostat private elemental subroutine split_character (string, word, set, separator, back) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(inout) :: string type( varying_string ), intent(out) :: word character(len=*), intent(in) :: set type( varying_string ), intent(out), optional :: separator logical, intent(in), optional :: back private elemental subroutine split_string (string, word, set, separator, back) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(inout) :: string type( varying_string ), intent(out) :: word type( varying_string ), intent(in) :: set type( varying_string ), intent(out), optional :: separator logical, intent(in), optional :: back","tags":"","loc":"module/iso_varying_string.html","title":"iso_varying_string – miniFAVOR"},{"text":"Uses iso_varying_string Contents Derived Types test_info_t Functions drop_extension make_program make_use_statement make_use_statements parse_alphabet parse_at_least_one_white_space parse_function parse_line parse_open_paren parse_space_or_open_paren parse_test_function_name parse_underscore parse_valid_first_character parse_valid_identifier parse_valid_identifier_character parse_white_space rename_ take_file_name Subroutines make_driver get_individual_test_info get_test_info make_test_array scan_test_file Derived Types type, private :: test_info_t Components Type Visibility Attributes Name Initial type( varying_string ), public, allocatable :: function_names (:) type( varying_string ), public :: module_name Functions private pure function drop_extension (filename) result(without_extension) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename Return Value type( varying_string ) private pure function make_program (driver_name, test_infos) result(program_) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: driver_name type( test_info_t ), intent(in) :: test_infos (:) Return Value type( varying_string ) private pure function make_use_statement (test_info) result(use_statement) Arguments Type Intent Optional Attributes Name type( test_info_t ), intent(in) :: test_info Return Value type( varying_string ) private pure function make_use_statements (test_infos) result(use_statements) Arguments Type Intent Optional Attributes Name type( test_info_t ), intent(in) :: test_infos (:) Return Value type( varying_string )\n  (size(test_infos)) private pure function parse_alphabet (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_at_least_one_white_space (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_function (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private elemental function parse_line (line) result(maybe_name) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: line Return Value type( parse_result_t ) private pure function parse_open_paren (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_space_or_open_paren (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_test_function_name (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_underscore (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_valid_first_character (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_valid_identifier (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_valid_identifier_character (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function parse_white_space (the_state) result(the_result) Arguments Type Intent Optional Attributes Name type( state_t ), intent(in) :: the_state Return Value type( parser_output_t ) private pure function rename_ (module_name, function_name) result(renamed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: module_name type( varying_string ), intent(in) :: function_name Return Value type( varying_string ) private pure function take_file_name (filename) result(just_file) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename Return Value type( varying_string ) Subroutines public subroutine make_driver (driver_file, test_files) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: driver_file type( varying_string ), intent(in) :: test_files (:) private subroutine get_individual_test_info (filename, test_info) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename type( test_info_t ), intent(out) :: test_info private subroutine get_test_info (filenames, test_infos) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filenames (:) type( test_info_t ), intent(out) :: test_infos (size(filenames)) private pure subroutine make_test_array (test_infos, test_array) Arguments Type Intent Optional Attributes Name type( test_info_t ), intent(in) :: test_infos (:) type( varying_string ), intent(out), allocatable :: test_array (:) private subroutine scan_test_file (filename, function_names) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename type( varying_string ), intent(out), allocatable :: function_names (:)","tags":"","loc":"module/make_driver_m.html","title":"make_driver_m – miniFAVOR"},{"text":"Contents Variables both_message failure_message success_message Functions test_assert_equals_within_relative check_fail_for_different_numbers check_pass_for_close_numbers check_pass_for_same_number Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: both_message = \"Both Message\" character(len=*), private, parameter :: failure_message = \"Failure Message\" character(len=*), private, parameter :: success_message = \"Success Message\" Functions public function test_assert_equals_within_relative () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_fail_for_different_numbers (the_example) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) private pure function check_pass_for_close_numbers (the_example) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) private pure function check_pass_for_same_number (the_example) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t )","tags":"","loc":"module/assert_equals_within_absolute_test.html","title":"assert_equals_within_absolute_test – miniFAVOR"},{"text":"Contents Functions test_failing_collection_behaviors check_collection_fails check_failure_case_description check_failure_for_message check_failure_for_top_description check_failure_no_blank_lines check_failure_no_passing_descriptions check_failure_no_success_message check_num_asserts check_num_cases check_num_failing_asserts check_num_failing_cases check_verbose_case_descriptions check_verbose_for_failure_message check_verbose_for_success_message check_verbose_top_description Functions public function test_failing_collection_behaviors () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_collection_fails (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_failure_case_description (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_failure_for_message (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_failure_for_top_description (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_failure_no_blank_lines (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_failure_no_passing_descriptions (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_failure_no_success_message (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_num_asserts (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_num_cases (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_num_failing_asserts (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_num_failing_cases (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_verbose_case_descriptions (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_verbose_for_failure_message (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_verbose_for_success_message (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_verbose_top_description (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t )","tags":"","loc":"module/failing_collection_test.html","title":"failing_collection_test – miniFAVOR"},{"text":"Contents Variables both_message failure_message success_message Functions test_assert_includes check_fail_for_same_string check_pass_for_different_strings Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: both_message = \"Both Message\" character(len=*), private, parameter :: failure_message = \"Failure Message\" character(len=*), private, parameter :: success_message = \"Success Message\" Functions public function test_assert_includes () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_fail_for_same_string (the_example) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) private pure function check_pass_for_different_strings () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/assert_doesnt_include_test.html","title":"assert_doesnt_include_test – miniFAVOR"},{"text":"Contents Functions test_result check_failure_includes check_num_asserts check_num_failing_asserts check_passed check_verbose_includes Functions public function test_result () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_failure_includes () result(result_) Arguments None Return Value type( result_t ) private pure function check_num_asserts () result(result_) Arguments None Return Value type( result_t ) private pure function check_num_failing_asserts () result(result_) Arguments None Return Value type( result_t ) private pure function check_passed () result(result_) Arguments None Return Value type( result_t ) private pure function check_verbose_includes () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/result_test.html","title":"result_test – miniFAVOR"},{"text":"Uses example_asserts_m Contents Variables example_case_description_1 example_case_description_2 example_collection_description example_failing_case_description failure_message middle_collection_description not_in_descriptions num_asserts_in_failing num_asserts_in_passing num_cases_in_failing num_cases_in_passing num_failing_asserts num_failing_cases Functions example_failing_collection example_passing_collection example_test_case_1 example_test_case_2 example_fail example_failing_test_case middle_collection Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: example_case_description_1 = \"Example Case Description 1\" character(len=*), public, parameter :: example_case_description_2 = \"Example Case Description 2\" character(len=*), public, parameter :: example_collection_description = \"Example Collection Description\" character(len=*), public, parameter :: example_failing_case_description = \"Example Failing Case Description\" character(len=*), public, parameter :: failure_message = \"Failure Message\" character(len=*), public, parameter :: middle_collection_description = \"Middle Collection Description\" character(len=*), public, parameter :: not_in_descriptions = \"NOT IN DESCRIPTION\" integer, public, parameter :: num_asserts_in_failing = num_passing_from_example*2+1 integer, public, parameter :: num_asserts_in_passing = num_passing_from_example*3 integer, public, parameter :: num_cases_in_failing = 3 integer, public, parameter :: num_cases_in_passing = 3 integer, public, parameter :: num_failing_asserts = 1 integer, public, parameter :: num_failing_cases = 1 Functions public function example_failing_collection () result(test_collection) Arguments None Return Value type( test_item_t ) public function example_passing_collection () result(test_collection) Arguments None Return Value type( test_item_t ) public function example_test_case_1 () result(test_case) Arguments None Return Value type( test_item_t ) public function example_test_case_2 () result(test_case) Arguments None Return Value type( test_item_t ) private pure function example_fail () result(result_) Arguments None Return Value type( result_t ) private function example_failing_test_case () result(test_case) Arguments None Return Value type( test_item_t ) private function middle_collection () result(test_collection) Arguments None Return Value type( test_item_t )","tags":"","loc":"module/example_collections_m.html","title":"example_collections_m – miniFAVOR"},{"text":"Contents Variables both_message failure_message success_message Functions test_assert_equals_within_relative check_fail_for_different_numbers check_pass_for_close_numbers check_pass_for_same_number Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: both_message = \"Both Message\" character(len=*), private, parameter :: failure_message = \"Failure Message\" character(len=*), private, parameter :: success_message = \"Success Message\" Functions public function test_assert_equals_within_relative () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_fail_for_different_numbers (the_example) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) private pure function check_pass_for_close_numbers (the_example) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t ) private pure function check_pass_for_same_number (the_example) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t )","tags":"","loc":"module/assert_equals_within_relative_test.html","title":"assert_equals_within_relative_test – miniFAVOR"},{"text":"Contents Variables both_message failure_message success_message Functions test_assert_equals_integers check_fail_for_different_numbers check_pass_for_same_number Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: both_message = \"Both Message\" character(len=*), private, parameter :: failure_message = \"Failure Message\" character(len=*), private, parameter :: success_message = \"Success Message\" Functions public function test_assert_equals_integers () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_fail_for_different_numbers () result(result_) Arguments None Return Value type( result_t ) private pure function check_pass_for_same_number (the_example) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t )","tags":"","loc":"module/assert_equals_double_precision_test.html","title":"assert_equals_double_precision_test – miniFAVOR"},{"text":"Contents Functions test_passing_collection_behaviors check_collection_passes check_failure_description_empty check_num_asserts check_num_cases check_num_failing_asserts check_num_failing_cases check_verbose_case_descriptions check_verbose_description_assertion check_werbose_top_description Functions public function test_passing_collection_behaviors () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_collection_passes (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_failure_description_empty (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_num_asserts (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_num_cases (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_num_failing_asserts (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_num_failing_cases (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_verbose_case_descriptions (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_verbose_description_assertion (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t ) private pure function check_werbose_top_description (example_results) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_results Return Value type( result_t )","tags":"","loc":"module/passing_collection_test.html","title":"passing_collection_test – miniFAVOR"},{"text":"Contents Variables both_message failure_message success_message Functions test_assert_equals_strings check_fail_for_different_strings check_pass_for_same_strings Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: both_message = \"Both Message\" character(len=*), private, parameter :: failure_message = \"Failure Message\" character(len=*), private, parameter :: success_message = \"Success Message\" Functions public function test_assert_equals_strings () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_fail_for_different_strings () result(result_) Arguments None Return Value type( result_t ) private pure function check_pass_for_same_strings (the_example) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t )","tags":"","loc":"module/assert_equals_strings_test.html","title":"assert_equals_strings_test – miniFAVOR"},{"text":"Contents Functions test_passing_case_behaviors check_case_passes check_failure_description_empty check_num_asserts check_num_cases check_num_failing_asserts check_num_failing_cases check_verbose_description check_verbose_description_assertion Functions public function test_passing_case_behaviors () result(test) Arguments None Return Value type( test_item_t ) private pure function check_case_passes (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_failure_description_empty (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_num_asserts (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_num_cases (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_num_failing_asserts (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_num_failing_cases (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_verbose_description (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_verbose_description_assertion (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t )","tags":"","loc":"module/passing_case_test.html","title":"passing_case_test – miniFAVOR"},{"text":"Uses vegetables Contents Variables double_precision_generator Derived Types double_precision_generator_t Functions effectively_zero generate shrink Variables Type Visibility Attributes Name Initial type( double_precision_generator_t ), public :: double_precision_generator = double_precision_generator_t() Derived Types type, private, extends( generator_t ) :: double_precision_generator_t Type-Bound Procedures procedure, public :: generate procedure, public, nopass :: shrink Functions private pure function effectively_zero (value_) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: value_ Return Value logical private function generate (self) result(random_double) Arguments Type Intent Optional Attributes Name class( double_precision_generator_t ), intent(in) :: self Return Value type( generated_t ) private pure function shrink (input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t )","tags":"","loc":"module/double_precision_generator_m.html","title":"double_precision_generator_m – miniFAVOR"},{"text":"Contents Functions test_case_properties check_case_description check_num_cases check_speed Functions public function test_case_properties () result(test) Arguments None Return Value type( test_item_t ) private pure function check_case_description (example_case) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_case Return Value type( result_t ) private pure function check_num_cases (example_case) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_case Return Value type( result_t ) private function check_speed (example_case) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_case Return Value type( result_t )","tags":"","loc":"module/single_case_properties_test.html","title":"single_case_properties_test – miniFAVOR"},{"text":"Contents Variables example_description not_in_description Functions example_failing_test_case example_passing_test_case Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: example_description = \"Example Description\" character(len=*), public, parameter :: not_in_description = \"NOT\" Functions public function example_failing_test_case () result(test_case) Arguments None Return Value type( test_item_t ) public function example_passing_test_case () result(test_case) Arguments None Return Value type( test_item_t )","tags":"","loc":"module/example_cases_m.html","title":"example_cases_m – miniFAVOR"},{"text":"Contents Functions test_collection_properties checkcollectiondescriptions checkcollectiontopdescription checknumcases checkspeed Functions public function test_collection_properties () result(test) Arguments None Return Value type( test_item_t ) private pure function checkcollectiondescriptions (example_collection) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( result_t ) private pure function checkcollectiontopdescription (example_collection) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( result_t ) private pure function checknumcases (example_collection) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( result_t ) private function checkspeed (example_collection) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( result_t )","tags":"","loc":"module/collection_properties_test.html","title":"collection_properties_test – miniFAVOR"},{"text":"Uses vegetables Contents Derived Types filter_item_result_input_t Functions test_filter_case test_filter_collection check_case_is_same check_case_not_matching check_collection_is_same check_collection_not_matching check_collection_single_case filter_case_matching filter_case_not_matching filter_collection_matching_case filter_collection_matching_description filter_collection_not_matching Derived Types type, private, extends( input_t ) :: filter_item_result_input_t Components Type Visibility Attributes Name Initial type( filter_item_result_t ), public :: input Functions public function test_filter_case () result(tests) Arguments None Return Value type( test_item_t ) public function test_filter_collection () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_case_is_same (filtered) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: filtered Return Value type( result_t ) private pure function check_case_not_matching (filtered) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: filtered Return Value type( result_t ) private function check_collection_is_same (filtered) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: filtered Return Value type( result_t ) private pure function check_collection_not_matching (filtered) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: filtered Return Value type( result_t ) private pure function check_collection_single_case (filtered) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: filtered Return Value type( result_t ) private pure function filter_case_matching (example_case) result(filtered) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_case Return Value type( transformed_t ) private pure function filter_case_not_matching (example_case) result(filtered) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_case Return Value type( transformed_t ) private pure function filter_collection_matching_case (example_collection) result(filtered) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( transformed_t ) private pure function filter_collection_matching_description (example_collection) result(filtered) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( transformed_t ) private pure function filter_collection_not_matching (example_collection) result(filtered) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_collection Return Value type( transformed_t )","tags":"","loc":"module/filter_test.html","title":"filter_test – miniFAVOR"},{"text":"Contents Variables both_message failure_message success_message Functions test_assert_empty check_fails_for_nonempty_chars check_pass_for_empty_chars Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: both_message = \"Both Message\" character(len=*), private, parameter :: failure_message = \"Failure Message\" character(len=*), private, parameter :: success_message = \"Success Message\" Functions public function test_assert_empty () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_fails_for_nonempty_chars () result(result_) Arguments None Return Value type( result_t ) private pure function check_pass_for_empty_chars () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/assert_empty_test.html","title":"assert_empty_test – miniFAVOR"},{"text":"Contents Functions test_failing_case_behaviors check_case_fails check_failure_for_failure_message check_failure_for_given_description check_failure_no_success_message check_num_asserts check_num_cases check_num_failing_asserts check_num_failing_cases check_verbose_for_failure_message check_verbose_for_given_description check_verbose_for_success_message Functions public function test_failing_case_behaviors () result(test) Arguments None Return Value type( test_item_t ) private pure function check_case_fails (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_failure_for_failure_message (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_failure_for_given_description (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_failure_no_success_message (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_num_asserts (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_num_cases (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_num_failing_asserts (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_num_failing_cases (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_verbose_for_failure_message (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_verbose_for_given_description (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t ) private pure function check_verbose_for_success_message (example_result) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_result Return Value type( result_t )","tags":"","loc":"module/failing_case_test.html","title":"failing_case_test – miniFAVOR"},{"text":"Contents Variables both_message failure_message success_message Functions test_assert_includes check_fail_for_different_strings check_pass_for_same_strings Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: both_message = \"Both Message\" character(len=*), private, parameter :: failure_message = \"Failure Message\" character(len=*), private, parameter :: success_message = \"Success Message\" Functions public function test_assert_includes () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_fail_for_different_strings () result(result_) Arguments None Return Value type( result_t ) private pure function check_pass_for_same_strings (the_example) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_example Return Value type( result_t )","tags":"","loc":"module/assert_includes_test.html","title":"assert_includes_test – miniFAVOR"},{"text":"Contents Variables failure_message num_asserts_in_failing num_asserts_in_passing num_failing_asserts_in_failing num_passing_asserts_in_failing success_message Functions example_multiple_asserts example_multiple_asserts_with_fail Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: failure_message = \"Failure Message\" integer, public, parameter :: num_asserts_in_failing = num_failing_asserts_in_failing+num_passing_asserts_in_failing integer, public, parameter :: num_asserts_in_passing = 2 integer, public, parameter :: num_failing_asserts_in_failing = 1 integer, public, parameter :: num_passing_asserts_in_failing = 1 character(len=*), public, parameter :: success_message = \"Success Message\" Functions public pure function example_multiple_asserts () result(result_) Arguments None Return Value type( result_t ) public pure function example_multiple_asserts_with_fail () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/example_asserts_m.html","title":"example_asserts_m – miniFAVOR"},{"text":"Contents Variables both_message failure_message success_message Functions test_assert_equals_integers check_fail_for_different_integers check_pass_for_same_integer Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: both_message = \"Both Message\" character(len=*), private, parameter :: failure_message = \"Failure Message\" character(len=*), private, parameter :: success_message = \"Success Message\" Functions public function test_assert_equals_integers () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_fail_for_different_integers () result(result_) Arguments None Return Value type( result_t ) private pure function check_pass_for_same_integer (the_input) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: the_input Return Value type( result_t )","tags":"","loc":"module/assert_equals_integers_test.html","title":"assert_equals_integers_test – miniFAVOR"},{"text":"Uses vegetables Contents Derived Types test_item_input_t test_result_item_input_t Functions run_test Derived Types type, public, extends( input_t ) :: test_item_input_t Components Type Visibility Attributes Name Initial type( test_item_t ), public :: input type, public, extends( input_t ) :: test_result_item_input_t Components Type Visibility Attributes Name Initial type( test_result_item_t ), public :: input Functions public function run_test (example_test) result(example_result) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: example_test Return Value type( transformed_t )","tags":"","loc":"module/helpers_m.html","title":"helpers_m – miniFAVOR"},{"text":"Uses iso_varying_string Contents Variables ascii_string_generator empty_success_message integer_generator not_failure_message not_success_message that_failure_message that_success_message indentation machine_epsilon machine_tiny max_int num_generator_tests Interfaces assert_doesnt_include assert_empty assert_equals assert_equals_within_absolute assert_equals_within_relative assert_faster_than assert_includes assert_not assert_that delimit describe fail given it it_ make_doesnt_include_failure_message make_doesnt_include_success_message make_empty_failure_message make_equals_failure_message make_equals_success_message make_faster_than_failure_message make_faster_than_success_message make_includes_failure_message make_includes_success_message make_within_failure_message make_within_success_message succeed then_ then__ when with_user_message Abstract Interfaces computation_i filter_i generate_i input_test_i run_with_input_i run_without_input_i shrink_i simple_test_i test_count_i test_description_i test_result_colorized_description_i test_result_count_i test_result_passed_i transformer_i Derived Types ascii_string_generator_t double_precision_input_t example_t filter_item_result_t generated_t generator_t input_t input_test_case_t integer_generator_t integer_input_t result_t shrink_result_t simple_test_case_t simple_test_collection_t string_input_t test_case_result_t test_case_t test_case_with_examples_t test_case_with_generator_t test_collection_result_t test_collection_t test_collection_with_input_t test_item_t test_result_item_t transformation_failure_t transformed_t transforming_test_collection_t filter_result_t individual_result_t options_t test_result_t test_t Functions example generated get_random_ascii_character get_random_ascii_string get_random_ascii_string_with_max_length get_random_double_precision_with_magnitude get_random_double_precision_with_range get_random_integer get_random_integer_with_range get_random_logical shrunk_value simplest_value test_that transformed assert_doesnt_include_basic_cc assert_doesnt_include_basic_cs assert_doesnt_include_basic_sc assert_doesnt_include_basic_ss assert_doesnt_include_with_message_ccc assert_doesnt_include_with_message_ccs assert_doesnt_include_with_message_csc assert_doesnt_include_with_message_css assert_doesnt_include_with_message_scc assert_doesnt_include_with_message_scs assert_doesnt_include_with_message_ssc assert_doesnt_include_with_message_sss assert_doesnt_include_with_messages_cccc assert_doesnt_include_with_messages_cccs assert_doesnt_include_with_messages_ccsc assert_doesnt_include_with_messages_ccss assert_doesnt_include_with_messages_cscc assert_doesnt_include_with_messages_cscs assert_doesnt_include_with_messages_cssc assert_doesnt_include_with_messages_csss assert_doesnt_include_with_messages_sccc assert_doesnt_include_with_messages_sccs assert_doesnt_include_with_messages_scsc assert_doesnt_include_with_messages_scss assert_doesnt_include_with_messages_sscc assert_doesnt_include_with_messages_sscs assert_doesnt_include_with_messages_sssc assert_doesnt_include_with_messages_ssss assert_empty_basic_c assert_empty_basic_s assert_empty_with_message_cc assert_empty_with_message_cs assert_empty_with_message_sc assert_empty_with_message_ss assert_empty_with_messages_ccc assert_empty_with_messages_ccs assert_empty_with_messages_csc assert_empty_with_messages_css assert_empty_with_messages_scc assert_empty_with_messages_scs assert_empty_with_messages_ssc assert_empty_with_messages_sss assert_equals_double_precision assert_equals_double_precision_with_message_c assert_equals_double_precision_with_message_s assert_equals_double_precision_with_messages_cc assert_equals_double_precision_with_messages_cs assert_equals_double_precision_with_messages_sc assert_equals_double_precision_with_messages_ss assert_equals_integer_basic assert_equals_integer_with_message_c assert_equals_integer_with_message_s assert_equals_integer_with_messages_cc assert_equals_integer_with_messages_cs assert_equals_integer_with_messages_sc assert_equals_integer_with_messages_ss assert_equals_strings_cc assert_equals_strings_cs assert_equals_strings_sc assert_equals_strings_ss assert_equals_strings_with_message_ccc assert_equals_strings_with_message_ccs assert_equals_strings_with_message_csc assert_equals_strings_with_message_css assert_equals_strings_with_message_scc assert_equals_strings_with_message_scs assert_equals_strings_with_message_ssc assert_equals_strings_with_message_sss assert_equals_strings_with_messages_cccc assert_equals_strings_with_messages_cccs assert_equals_strings_with_messages_ccsc assert_equals_strings_with_messages_ccss assert_equals_strings_with_messages_cscc assert_equals_strings_with_messages_cscs assert_equals_strings_with_messages_cssc assert_equals_strings_with_messages_csss assert_equals_strings_with_messages_sccc assert_equals_strings_with_messages_sccs assert_equals_strings_with_messages_scsc assert_equals_strings_with_messages_scss assert_equals_strings_with_messages_sscc assert_equals_strings_with_messages_sscs assert_equals_strings_with_messages_sssc assert_equals_strings_with_messages_ssss assert_equals_within_absolute_basic assert_equals_within_absolute_with_message_c assert_equals_within_absolute_with_message_s assert_equals_within_absolute_with_messages_cc assert_equals_within_absolute_with_messages_cs assert_equals_within_absolute_with_messages_sc assert_equals_within_absolute_with_messages_ss assert_equals_within_relative_basic assert_equals_within_relative_with_message_c assert_equals_within_relative_with_message_s assert_equals_within_relative_with_messages_cc assert_equals_within_relative_with_messages_cs assert_equals_within_relative_with_messages_sc assert_equals_within_relative_with_messages_ss assert_faster_than_absolute_bracketed assert_faster_than_absolute_bracketed_with_message_c assert_faster_than_absolute_bracketed_with_message_s assert_faster_than_absolute_bracketed_with_messages_cc assert_faster_than_absolute_bracketed_with_messages_cs assert_faster_than_absolute_bracketed_with_messages_sc assert_faster_than_absolute_bracketed_with_messages_ss assert_faster_than_absolute_simple assert_faster_than_absolute_simple_with_message_c assert_faster_than_absolute_simple_with_message_s assert_faster_than_absolute_simple_with_messages_cc assert_faster_than_absolute_simple_with_messages_cs assert_faster_than_absolute_simple_with_messages_sc assert_faster_than_absolute_simple_with_messages_ss assert_faster_than_relative_bracketed assert_faster_than_relative_bracketed_with_message_c assert_faster_than_relative_bracketed_with_message_s assert_faster_than_relative_bracketed_with_messages_cc assert_faster_than_relative_bracketed_with_messages_cs assert_faster_than_relative_bracketed_with_messages_sc assert_faster_than_relative_bracketed_with_messages_ss assert_faster_than_relative_simple assert_faster_than_relative_simple_with_message_c assert_faster_than_relative_simple_with_message_s assert_faster_than_relative_simple_with_messages_cc assert_faster_than_relative_simple_with_messages_cs assert_faster_than_relative_simple_with_messages_sc assert_faster_than_relative_simple_with_messages_ss assert_includes_cc assert_includes_cs assert_includes_sc assert_includes_ss assert_includes_with_message_ccc assert_includes_with_message_ccs assert_includes_with_message_csc assert_includes_with_message_css assert_includes_with_message_scc assert_includes_with_message_scs assert_includes_with_message_ssc assert_includes_with_message_sss assert_includes_with_messages_cccc assert_includes_with_messages_cccs assert_includes_with_messages_ccsc assert_includes_with_messages_ccss assert_includes_with_messages_cscc assert_includes_with_messages_cscs assert_includes_with_messages_cssc assert_includes_with_messages_csss assert_includes_with_messages_sccc assert_includes_with_messages_sccs assert_includes_with_messages_scsc assert_includes_with_messages_scss assert_includes_with_messages_sscc assert_includes_with_messages_sscs assert_includes_with_messages_sssc assert_includes_with_messages_ssss assert_not_basic assert_not_with_message_c assert_not_with_message_s assert_not_with_messages_cc assert_not_with_messages_cs assert_not_with_messages_sc assert_not_with_messages_ss assert_that_basic assert_that_with_message_c assert_that_with_message_s assert_that_with_messages_cc assert_that_with_messages_cs assert_that_with_messages_sc assert_that_with_messages_ss combine_results delimit_c delimit_s describe_basic_c describe_basic_s describe_with_input_c describe_with_input_s equals_within_absolute equals_within_relative fail_c fail_s generate_ascii_string generate_integer get_options given_basic_c given_basic_s given_with_input_c given_with_input_s individual_result individual_result_failure_description individual_result_verbose_description input_test_case input_test_case_run_with_input input_test_case_run_without_input it_basic_c it_basic_s it_input_c it_input_s it_with_examples_c it_with_examples_s it_with_generator_c it_with_generator_s make_doesnt_include_failure_message_cc make_doesnt_include_failure_message_cs make_doesnt_include_failure_message_sc make_doesnt_include_failure_message_ss make_doesnt_include_success_message_cc make_doesnt_include_success_message_cs make_doesnt_include_success_message_sc make_doesnt_include_success_message_ss make_empty_failure_message_c make_empty_failure_message_s make_equals_failure_message_cc make_equals_failure_message_cs make_equals_failure_message_sc make_equals_failure_message_ss make_equals_success_message_c make_equals_success_message_s make_faster_than_failure_message_ccc make_faster_than_failure_message_ccs make_faster_than_failure_message_csc make_faster_than_failure_message_css make_faster_than_failure_message_scc make_faster_than_failure_message_scs make_faster_than_failure_message_ssc make_faster_than_failure_message_sss make_faster_than_success_message_ccc make_faster_than_success_message_ccs make_faster_than_success_message_csc make_faster_than_success_message_css make_faster_than_success_message_scc make_faster_than_success_message_scs make_faster_than_success_message_ssc make_faster_than_success_message_sss make_includes_failure_message_cc make_includes_failure_message_cs make_includes_failure_message_sc make_includes_failure_message_ss make_includes_succes_message_cs make_includes_succes_message_sc make_includes_succes_message_ss make_includes_success_message_cc make_within_failure_message_ccc make_within_failure_message_ccs make_within_failure_message_csc make_within_failure_message_css make_within_failure_message_scc make_within_failure_message_scs make_within_failure_message_ssc make_within_failure_message_sss make_within_success_message_ccc make_within_success_message_ccs make_within_success_message_csc make_within_success_message_css make_within_success_message_scc make_within_success_message_scs make_within_success_message_ssc make_within_success_message_sss result_failure_description result_num_asserts result_num_failing_asserts result_passed result_verbose_description shrink_ascii_string shrink_integer shrink_result simple_test_case simple_test_case_run_with_input simple_test_case_run_without_input simple_test_collection simple_test_collection_run_with_input simple_test_collection_run_without_input succeed_c succeed_s test_case_description test_case_filter test_case_num_cases test_case_result test_case_result_failure_description test_case_result_num_asserts test_case_result_num_cases test_case_result_num_failing_asserts test_case_result_num_failing_cases test_case_result_passed test_case_result_verbose_description test_case_with_examples test_case_with_examples_run_with_input test_case_with_examples_run_without_input test_case_with_generator test_case_with_generator_run_with_input test_case_with_generator_run_without_input test_collection_description test_collection_filter test_collection_num_cases test_collection_result test_collection_result_failure_description test_collection_result_num_asserts test_collection_result_num_cases test_collection_result_num_failing_asserts test_collection_result_num_failing_cases test_collection_result_passed test_collection_result_verbose_description test_collection_with_input test_collection_with_input_run_with_input test_collection_with_input_run_without_input test_item_description test_item_filter test_item_num_cases test_item_run_with_input test_item_run_without_input test_result_item_failure_description test_result_item_num_asserts test_result_item_num_cases test_result_item_num_failing_asserts test_result_item_num_failing_cases test_result_item_passed test_result_item_verbose_description then_basic_c then_basic_s then_input_c then_input_s transforming_test_collection transforming_test_collection_run_with_input transforming_test_collection_run_without_input when_basic_c when_basic_s when_with_transformer_c when_with_transformer_s with_user_message_cc with_user_message_cs with_user_message_sc with_user_message_ss Subroutines run_tests Variables Type Visibility Attributes Name Initial type( ascii_string_generator_t ), public, parameter :: ascii_string_generator = ascii_string_generator_t() character(len=*), public, parameter :: empty_success_message = \"String was empty\" type( integer_generator_t ), public, parameter :: integer_generator = integer_generator_t() character(len=*), public, parameter :: not_failure_message = \"Expected to not be true\" character(len=*), public, parameter :: not_success_message = \"Was not true\" character(len=*), public, parameter :: that_failure_message = \"Expected to be true\" character(len=*), public, parameter :: that_success_message = \"Was true\" integer, private, parameter :: indentation = 4 double precision, private, parameter :: machine_epsilon = epsilon(0.0d0) double precision, private, parameter :: machine_tiny = tiny(0.0d0) integer, private, parameter :: max_int = huge(1) integer, private :: num_generator_tests = 100 Interfaces public interface assert_doesnt_include private pure function assert_doesnt_include_basic_cc (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_doesnt_include_basic_cs (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_doesnt_include_basic_sc (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_doesnt_include_basic_ss (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_doesnt_include_with_message_ccc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_ccs (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_csc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_css (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_scc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_scs (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_ssc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_sss (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cccc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cccs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_ccsc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_ccss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cscc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cscs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cssc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_csss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sccc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sccs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_scsc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_scss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sscc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sscs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sssc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_ssss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) public interface assert_empty private pure function assert_empty_basic_c (string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_empty_basic_s (string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_empty_with_message_cc (string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_empty_with_message_cs (string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_empty_with_message_sc (string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_empty_with_message_ss (string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_empty_with_messages_ccc (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_ccs (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_csc (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_css (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_scc (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_scs (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_ssc (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_sss (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) public interface assert_equals private pure function assert_equals_double_precision (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_double_precision_with_message_c (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_double_precision_with_message_s (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_double_precision_with_messages_cc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_double_precision_with_messages_cs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_double_precision_with_messages_sc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_double_precision_with_messages_ss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_integer_basic (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_integer_with_message_c (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_integer_with_message_s (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_integer_with_messages_cc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_integer_with_messages_cs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_integer_with_messages_sc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_integer_with_messages_ss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_cc (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_strings_cs (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_strings_sc (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_strings_ss (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_strings_with_message_ccc (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_ccs (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_csc (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_css (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_scc (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_scs (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_ssc (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_sss (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cccc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cccs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_ccsc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_ccss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cscc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cscs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cssc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_csss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sccc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sccs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_scsc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_scss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sscc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sscs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sssc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_ssss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) public interface assert_equals_within_absolute private pure function assert_equals_within_absolute_basic (expected, actual, tolerance) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance Return Value type( result_t ) private pure function assert_equals_within_absolute_with_message_c (expected, actual, tolerance, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_message_s (expected, actual, tolerance, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_messages_cc (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_messages_cs (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_messages_sc (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_messages_ss (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) public interface assert_equals_within_relative private pure function assert_equals_within_relative_basic (expected, actual, tolerance) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance Return Value type( result_t ) private pure function assert_equals_within_relative_with_message_c (expected, actual, tolerance, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_within_relative_with_message_s (expected, actual, tolerance, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_within_relative_with_messages_cc (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_relative_with_messages_cs (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_relative_with_messages_sc (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_relative_with_messages_ss (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) public interface assert_faster_than private function assert_faster_than_absolute_bracketed (reference, before, computation, after, iterations) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_message_c (reference, before, computation, after, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_message_s (reference, before, computation, after, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_messages_cc (reference, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_messages_cs (reference, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_messages_sc (reference, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_messages_ss (reference, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_simple (reference, computation, iterations) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_message_c (reference, computation, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_message_s (reference, computation, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_messages_cc (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_messages_cs (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_messages_sc (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_messages_ss (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_bracketed (reference_before, reference, reference_after, before, computation, after, iterations) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_message_c (reference_before, reference, reference_after, before, computation, after, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_message_s (reference_before, reference, reference_after, before, computation, after, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_messages_cc (reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_messages_cs (reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_messages_sc (reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_messages_ss (reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_simple (reference, computation, iterations) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations Return Value type( result_t ) private function assert_faster_than_relative_simple_with_message_c (reference, computation, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_message_s (reference, computation, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_messages_cc (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_messages_cs (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_messages_sc (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_messages_ss (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) public interface assert_includes private pure function assert_includes_cc (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_includes_cs (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_includes_sc (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_includes_ss (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_includes_with_message_ccc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_ccs (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_csc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_css (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_scc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_scs (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_ssc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_sss (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_messages_cccc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_cccs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_ccsc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_ccss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_cscc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_cscs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_cssc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_csss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sccc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sccs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_scsc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_scss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sscc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sscs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sssc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_ssss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) public interface assert_not private pure function assert_not_basic (condition) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition Return Value type( result_t ) private pure function assert_not_with_message_c (condition, message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_not_with_message_s (condition, message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_not_with_messages_cc (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_not_with_messages_cs (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_not_with_messages_sc (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_not_with_messages_ss (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) public interface assert_that private pure function assert_that_basic (condition) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition Return Value type( result_t ) private pure function assert_that_with_message_c (condition, message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_that_with_message_s (condition, message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_that_with_messages_cc (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_that_with_messages_cs (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_that_with_messages_sc (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_that_with_messages_ss (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) public interface delimit private pure function delimit_c (string) result(delimited) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function delimit_s (string) result(delimited) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) public interface describe private function describe_basic_c (description, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function describe_basic_s (description, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function describe_with_input_c (description, input, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function describe_with_input_s (description, input, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) public interface fail private pure function fail_c (message) result(failure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Return Value type( result_t ) private pure function fail_s (message) result(failure) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message Return Value type( result_t ) public interface given private function given_basic_c (description, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function given_basic_s (description, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function given_with_input_c (description, input, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function given_with_input_s (description, input, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) public interface it private function it_basic_c (description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) private function it_basic_s (description, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) private function it_with_examples_c (description, examples, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( example_t ), intent(in) :: examples (:) procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_with_examples_s (description, examples, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( example_t ), intent(in) :: examples (:) procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_with_generator_c (description, generator, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description class( generator_t ), intent(in) :: generator procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_with_generator_s (description, generator, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( generator_t ), intent(in) :: generator procedure( input_test_i ) :: test Return Value type( test_item_t ) public interface it_ private function it_input_c (description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_input_s (description, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) public interface make_doesnt_include_failure_message private pure function make_doesnt_include_failure_message_cc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_failure_message_cs (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_failure_message_sc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_failure_message_ss (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) public interface make_doesnt_include_success_message private pure function make_doesnt_include_success_message_cc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_success_message_cs (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_success_message_sc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_success_message_ss (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) public interface make_empty_failure_message private pure function make_empty_failure_message_c (string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_empty_failure_message_s (string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) public interface make_equals_failure_message private pure function make_equals_failure_message_cc (expected, actual) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( varying_string ) private pure function make_equals_failure_message_cs (expected, actual) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( varying_string ) private pure function make_equals_failure_message_sc (expected, actual) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( varying_string ) private pure function make_equals_failure_message_ss (expected, actual) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( varying_string ) public interface make_equals_success_message private pure function make_equals_success_message_c (expected) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected Return Value type( varying_string ) private pure function make_equals_success_message_s (expected) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected Return Value type( varying_string ) public interface make_faster_than_failure_message private pure function make_faster_than_failure_message_ccc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_ccs (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_csc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_css (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_scc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_scs (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_ssc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_sss (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) public interface make_faster_than_success_message private pure function make_faster_than_success_message_ccc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_ccs (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_csc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_css (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_scc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_scs (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_ssc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_sss (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) public interface make_includes_failure_message private pure function make_includes_failure_message_cc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_failure_message_cs (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_failure_message_sc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_failure_message_ss (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) public interface make_includes_success_message private pure function make_includes_success_message_cc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_succes_message_cs (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_succes_message_sc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_succes_message_ss (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) public interface make_within_failure_message private pure function make_within_failure_message_ccc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_ccs (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_csc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_css (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_scc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_scs (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_ssc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_sss (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) public interface make_within_success_message private pure function make_within_success_message_ccc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_ccs (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_csc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_css (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_scc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_scs (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_ssc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_sss (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) public interface succeed private pure function succeed_c (message) result(success) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Return Value type( result_t ) private pure function succeed_s (message) result(success) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message Return Value type( result_t ) public interface then_ private function then_basic_c (description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) private function then_basic_s (description, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) public interface then__ private function then_input_c (description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) private function then_input_s (description, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) public interface when private function when_basic_c (description, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function when_basic_s (description, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function when_with_transformer_c (description, transformer, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( transformer_i ) :: transformer type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function when_with_transformer_s (description, transformer, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( transformer_i ) :: transformer type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) public interface with_user_message private pure function with_user_message_cc (message, user_message) result(whole_message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message character(len=*), intent(in) :: user_message Return Value type( varying_string ) private pure function with_user_message_cs (message, user_message) result(whole_message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message type( varying_string ), intent(in) :: user_message Return Value type( varying_string ) private pure function with_user_message_sc (message, user_message) result(whole_message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message character(len=*), intent(in) :: user_message Return Value type( varying_string ) private pure function with_user_message_ss (message, user_message) result(whole_message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message type( varying_string ), intent(in) :: user_message Return Value type( varying_string ) Abstract Interfaces abstract interface private subroutine computation_i() Arguments None abstract interface private pure function filter_i(self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) abstract interface private function generate_i(self) result(generated_value) Arguments Type Intent Optional Attributes Name class( generator_t ), intent(in) :: self Return Value type( generated_t ) abstract interface private function input_test_i(input) result(result_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( result_t ) abstract interface private function run_with_input_i(self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) abstract interface private function run_without_input_i(self) result(result_) Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self Return Value type( test_result_item_t ) abstract interface private function shrink_i(input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t ) abstract interface private function simple_test_i() result(result_) Arguments None Return Value type( result_t ) abstract interface private pure function test_count_i(self) result(num) Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self Return Value integer abstract interface private pure function test_description_i(self) result(description) Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: self Return Value type( varying_string ) abstract interface private pure function test_result_colorized_description_i(self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) abstract interface private pure function test_result_count_i(self) result(num) Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value integer abstract interface private pure function test_result_passed_i(self) result(passed) Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value logical abstract interface private function transformer_i(input) result(output) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( transformed_t ) Derived Types type, public, extends( generator_t ) :: ascii_string_generator_t Type-Bound Procedures procedure, public :: generate => generate_ascii_string procedure, public, nopass :: shrink => shrink_ascii_string type, public, extends( input_t ) :: double_precision_input_t Components Type Visibility Attributes Name Initial double precision, public :: value_ type, public :: example_t Components Type Visibility Attributes Name Initial class( input_t ), private, allocatable :: input type, public :: filter_item_result_t Components Type Visibility Attributes Name Initial logical, public :: matched type( test_item_t ), public :: test type, public :: generated_t Components Type Visibility Attributes Name Initial class( input_t ), private, allocatable :: input type, public, abstract :: generator_t Type-Bound Procedures procedure(generate_i), public :: generate procedure(shrink_i), public, nopass :: shrink type, public, abstract :: input_t type, public, extends( test_case_t ) :: input_test_case_t Components Type Visibility Attributes Name Initial procedure( input_test_i ), private, nopass, pointer :: test Type-Bound Procedures procedure, public :: description => test_case_description procedure, public :: filter => test_case_filter procedure, public :: num_cases => test_case_num_cases procedure, private :: run_with_input => input_test_case_run_with_input procedure, private :: run_without_input => input_test_case_run_without_input type, public, extends( generator_t ) :: integer_generator_t Type-Bound Procedures procedure, public :: generate => generate_integer procedure, public, nopass :: shrink => shrink_integer type, public, extends( input_t ) :: integer_input_t Components Type Visibility Attributes Name Initial integer, public :: value_ type, public :: result_t Components Type Visibility Attributes Name Initial type( individual_result_t ), private, allocatable :: results (:) Type-Bound Procedures procedure, public :: failure_description => result_failure_description procedure, public :: num_asserts => result_num_asserts procedure, public :: num_failing_asserts => result_num_failing_asserts generic, public :: operator(.and.) => combine_results procedure, public :: passed => result_passed procedure, public :: verbose_description => result_verbose_description procedure, private :: combine_results type, public :: shrink_result_t Components Type Visibility Attributes Name Initial class( input_t ), private, allocatable :: input logical, private :: simplest type, public, extends( test_case_t ) :: simple_test_case_t Components Type Visibility Attributes Name Initial procedure( simple_test_i ), private, nopass, pointer :: test Type-Bound Procedures procedure, public :: description => test_case_description procedure, public :: filter => test_case_filter procedure, public :: num_cases => test_case_num_cases procedure, private :: run_with_input => simple_test_case_run_with_input procedure, private :: run_without_input => simple_test_case_run_without_input type, public, extends( test_collection_t ) :: simple_test_collection_t Type-Bound Procedures procedure, public :: description => test_collection_description procedure, public :: filter => test_collection_filter procedure, public :: num_cases => test_collection_num_cases procedure, private :: run_with_input => simple_test_collection_run_with_input procedure, private :: run_without_input => simple_test_collection_run_without_input type, public, extends( input_t ) :: string_input_t Components Type Visibility Attributes Name Initial type( varying_string ), public :: value_ type, public, extends( test_result_t ) :: test_case_result_t Components Type Visibility Attributes Name Initial type( result_t ), private :: result_ Type-Bound Procedures procedure, public :: failure_description => test_case_result_failure_description procedure, public :: num_asserts => test_case_result_num_asserts procedure, public :: num_cases => test_case_result_num_cases procedure, public :: num_failing_asserts => test_case_result_num_failing_asserts procedure, public :: num_failing_cases => test_case_result_num_failing_cases procedure, public :: passed => test_case_result_passed procedure, public :: verbose_description => test_case_result_verbose_description type, public, abstract, extends( test_t ) :: test_case_t Type-Bound Procedures procedure, public :: description => test_case_description procedure, public :: filter => test_case_filter procedure, public :: num_cases => test_case_num_cases type, public, extends( test_case_t ) :: test_case_with_examples_t Components Type Visibility Attributes Name Initial type( example_t ), private, allocatable :: examples (:) procedure( input_test_i ), private, nopass, pointer :: test Type-Bound Procedures procedure, public :: description => test_case_description procedure, public :: filter => test_case_filter procedure, public :: num_cases => test_case_num_cases procedure, private :: run_with_input => test_case_with_examples_run_with_input procedure, private :: run_without_input => test_case_with_examples_run_without_input type, public, extends( test_case_t ) :: test_case_with_generator_t Components Type Visibility Attributes Name Initial class( generator_t ), private, allocatable :: generator procedure( input_test_i ), private, nopass, pointer :: test Type-Bound Procedures procedure, public :: description => test_case_description procedure, public :: filter => test_case_filter procedure, public :: num_cases => test_case_num_cases procedure, private :: run_with_input => test_case_with_generator_run_with_input procedure, private :: run_without_input => test_case_with_generator_run_without_input type, public, extends( test_result_t ) :: test_collection_result_t Components Type Visibility Attributes Name Initial type( test_result_item_t ), private, allocatable :: results (:) Type-Bound Procedures procedure, public :: failure_description => test_collection_result_failure_description procedure, public :: num_asserts => test_collection_result_num_asserts procedure, public :: num_cases => test_collection_result_num_cases procedure, public :: num_failing_asserts => test_collection_result_num_failing_asserts procedure, public :: num_failing_cases => test_collection_result_num_failing_cases procedure, public :: passed => test_collection_result_passed procedure, public :: verbose_description => test_collection_result_verbose_description type, public, abstract, extends( test_t ) :: test_collection_t Components Type Visibility Attributes Name Initial type( test_item_t ), private, allocatable :: tests (:) Type-Bound Procedures procedure, public :: description => test_collection_description procedure, public :: filter => test_collection_filter procedure, public :: num_cases => test_collection_num_cases type, public, extends( test_collection_t ) :: test_collection_with_input_t Components Type Visibility Attributes Name Initial class( input_t ), private, allocatable :: input Type-Bound Procedures procedure, public :: description => test_collection_description procedure, public :: filter => test_collection_filter procedure, public :: num_cases => test_collection_num_cases procedure, private :: run_with_input => test_collection_with_input_run_with_input procedure, private :: run_without_input => test_collection_with_input_run_without_input type, public :: test_item_t Components Type Visibility Attributes Name Initial class( test_t ), private, allocatable :: test Type-Bound Procedures procedure, public :: description => test_item_description procedure, public :: filter => test_item_filter procedure, public :: num_cases => test_item_num_cases generic, public :: run => run_with_input, run_without_input procedure, private :: run_with_input => test_item_run_with_input procedure, private :: run_without_input => test_item_run_without_input type, public :: test_result_item_t Components Type Visibility Attributes Name Initial class( test_result_t ), private, allocatable :: result_ Type-Bound Procedures procedure, public :: failure_description => test_result_item_failure_description procedure, public :: num_asserts => test_result_item_num_asserts procedure, public :: num_cases => test_result_item_num_cases procedure, public :: num_failing_asserts => test_result_item_num_failing_asserts procedure, public :: num_failing_cases => test_result_item_num_failing_cases procedure, public :: passed => test_result_item_passed procedure, public :: verbose_description => test_result_item_verbose_description type, public, extends( input_t ) :: transformation_failure_t Components Type Visibility Attributes Name Initial type( result_t ), public :: result_ type, public :: transformed_t Components Type Visibility Attributes Name Initial class( input_t ), private, allocatable :: input type, public, extends( test_collection_t ) :: transforming_test_collection_t Components Type Visibility Attributes Name Initial procedure( transformer_i ), private, nopass, pointer :: transformer Type-Bound Procedures procedure, public :: description => test_collection_description procedure, public :: filter => test_collection_filter procedure, public :: num_cases => test_collection_num_cases procedure, private :: run_with_input => transforming_test_collection_run_with_input procedure, private :: run_without_input => transforming_test_collection_run_without_input type, private :: filter_result_t Components Type Visibility Attributes Name Initial logical, public :: matched class( test_t ), public, allocatable :: test type, private :: individual_result_t Components Type Visibility Attributes Name Initial type( varying_string ), private :: message logical, private :: passed_ Type-Bound Procedures procedure, private :: failure_description => individual_result_failure_description procedure, private :: verbose_description => individual_result_verbose_description type, private :: options_t Components Type Visibility Attributes Name Initial logical, private :: colorize type( varying_string ), private :: filter_string logical, private :: filter_tests logical, private :: quiet logical, private :: verbose type, private, abstract :: test_result_t Components Type Visibility Attributes Name Initial type( varying_string ), private :: description Type-Bound Procedures procedure(test_result_colorized_description_i), public :: failure_description procedure(test_result_count_i), public :: num_asserts procedure(test_result_count_i), public :: num_cases procedure(test_result_count_i), public :: num_failing_asserts procedure(test_result_count_i), public :: num_failing_cases procedure(test_result_passed_i), public :: passed procedure(test_result_colorized_description_i), public :: verbose_description type, private, abstract :: test_t Components Type Visibility Attributes Name Initial type( varying_string ), private :: description_ Type-Bound Procedures procedure(test_description_i), public :: description procedure(filter_i), public :: filter procedure(test_count_i), public :: num_cases generic, private :: run => run_with_input, run_without_input procedure(run_with_input_i), private :: run_with_input procedure(run_without_input_i), private :: run_without_input Functions public pure function example (input) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( example_t ) public pure function generated (value_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: value_ Return Value type( generated_t ) public function get_random_ascii_character () result(random_character) Arguments None Return Value character(len=1) public function get_random_ascii_string () result(random_string) Arguments None Return Value type( varying_string ) public function get_random_ascii_string_with_max_length (max_length) result(random_string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: max_length Return Value type( varying_string ) public function get_random_double_precision_with_magnitude (magnitude) result(random_double) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: magnitude Return Value double precision public function get_random_double_precision_with_range (start, end_) result(random_double) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: start double precision, intent(in) :: end_ Return Value double precision public function get_random_integer () result(random_integer) Arguments None Return Value integer public function get_random_integer_with_range (start, end_) result(random_integer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: end_ Return Value integer public function get_random_logical () result(random_logical) Arguments None Return Value logical public pure function shrunk_value (value_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: value_ Return Value type( shrink_result_t ) public pure function simplest_value (value_) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: value_ Return Value type( shrink_result_t ) public function test_that (tests) result(item) Arguments Type Intent Optional Attributes Name type( test_item_t ) :: tests (:) Return Value type( test_item_t ) public pure function transformed (input) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( transformed_t ) private pure function assert_doesnt_include_basic_cc (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_doesnt_include_basic_cs (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_doesnt_include_basic_sc (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_doesnt_include_basic_ss (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_doesnt_include_with_message_ccc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_ccs (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_csc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_css (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_scc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_scs (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_ssc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_message_sss (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cccc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cccs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_ccsc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_ccss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cscc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cscs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_cssc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_csss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sccc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sccs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_scsc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_scss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sscc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sscs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_sssc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_doesnt_include_with_messages_ssss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_basic_c (string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_empty_basic_s (string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_empty_with_message_cc (string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_empty_with_message_cs (string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_empty_with_message_sc (string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_empty_with_message_ss (string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_empty_with_messages_ccc (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_ccs (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_csc (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_css (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_scc (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_scs (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_ssc (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_empty_with_messages_sss (string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_double_precision (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_double_precision_with_message_c (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_double_precision_with_message_s (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_double_precision_with_messages_cc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_double_precision_with_messages_cs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_double_precision_with_messages_sc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_double_precision_with_messages_ss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_integer_basic (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_integer_with_message_c (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_integer_with_message_s (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_integer_with_messages_cc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_integer_with_messages_cs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_integer_with_messages_sc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_integer_with_messages_ss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name integer, intent(in) :: expected integer, intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_cc (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_strings_cs (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_strings_sc (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_strings_ss (expected, actual) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( result_t ) private pure function assert_equals_strings_with_message_ccc (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_ccs (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_csc (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_css (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_scc (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_scs (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_ssc (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_message_sss (expected, actual, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cccc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cccs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_ccsc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_ccss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cscc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cscs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_cssc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_csss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sccc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sccs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_scsc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_scss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sscc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sscs (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_sssc (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_strings_with_messages_ssss (expected, actual, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_absolute_basic (expected, actual, tolerance) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance Return Value type( result_t ) private pure function assert_equals_within_absolute_with_message_c (expected, actual, tolerance, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_message_s (expected, actual, tolerance, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_messages_cc (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_messages_cs (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_messages_sc (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_absolute_with_messages_ss (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_relative_basic (expected, actual, tolerance) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance Return Value type( result_t ) private pure function assert_equals_within_relative_with_message_c (expected, actual, tolerance, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_within_relative_with_message_s (expected, actual, tolerance, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_equals_within_relative_with_messages_cc (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_relative_with_messages_cs (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_relative_with_messages_sc (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_equals_within_relative_with_messages_ss (expected, actual, tolerance, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed (reference, before, computation, after, iterations) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_message_c (reference, before, computation, after, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_message_s (reference, before, computation, after, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_messages_cc (reference, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_messages_cs (reference, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_messages_sc (reference, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_bracketed_with_messages_ss (reference, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_simple (reference, computation, iterations) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_message_c (reference, computation, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_message_s (reference, computation, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_messages_cc (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_messages_cs (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_messages_sc (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_absolute_simple_with_messages_ss (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_bracketed (reference_before, reference, reference_after, before, computation, after, iterations) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_message_c (reference_before, reference, reference_after, before, computation, after, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_message_s (reference_before, reference, reference_after, before, computation, after, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_messages_cc (reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_messages_cs (reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_messages_sc (reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_bracketed_with_messages_ss (reference_before, reference, reference_after, before, computation, after, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference_before procedure( computation_i ) :: reference procedure( computation_i ) :: reference_after procedure( computation_i ) :: before procedure( computation_i ) :: computation procedure( computation_i ) :: after integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_simple (reference, computation, iterations) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations Return Value type( result_t ) private function assert_faster_than_relative_simple_with_message_c (reference, computation, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_message_s (reference, computation, iterations, message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_messages_cc (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_messages_cs (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_messages_sc (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private function assert_faster_than_relative_simple_with_messages_ss (reference, computation, iterations, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name procedure( computation_i ) :: reference procedure( computation_i ) :: computation integer, intent(in) :: iterations type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_cc (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_includes_cs (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_includes_sc (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( result_t ) private pure function assert_includes_ss (search_for, string) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( result_t ) private pure function assert_includes_with_message_ccc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_ccs (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_csc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_css (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_scc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_scs (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_ssc (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_message_sss (search_for, string, message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_includes_with_messages_cccc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_cccs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_ccsc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_ccss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_cscc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_cscs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_cssc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_csss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sccc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sccs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_scsc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_scss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sscc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sscs (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_sssc (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_includes_with_messages_ssss (search_for, string, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_not_basic (condition) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition Return Value type( result_t ) private pure function assert_not_with_message_c (condition, message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_not_with_message_s (condition, message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_not_with_messages_cc (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_not_with_messages_cs (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_not_with_messages_sc (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_not_with_messages_ss (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_that_basic (condition) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition Return Value type( result_t ) private pure function assert_that_with_message_c (condition, message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: message Return Value type( result_t ) private pure function assert_that_with_message_s (condition, message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function assert_that_with_messages_cc (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_that_with_messages_cs (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_that_with_messages_sc (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message character(len=*), intent(in) :: failure_message Return Value type( result_t ) private pure function assert_that_with_messages_ss (condition, success_message, failure_message) result(result__) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition type( varying_string ), intent(in) :: success_message type( varying_string ), intent(in) :: failure_message Return Value type( result_t ) private pure function combine_results (lhs, rhs) result(combined) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: lhs type( result_t ), intent(in) :: rhs Return Value type( result_t ) private pure function delimit_c (string) result(delimited) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function delimit_s (string) result(delimited) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) private function describe_basic_c (description, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function describe_basic_s (description, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function describe_with_input_c (description, input, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function describe_with_input_s (description, input, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private pure function equals_within_absolute (expected, actual, tolerance) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance Return Value logical private pure function equals_within_relative (expected, actual, tolerance) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: expected double precision, intent(in) :: actual double precision, intent(in) :: tolerance Return Value logical private pure function fail_c (message) result(failure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Return Value type( result_t ) private pure function fail_s (message) result(failure) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message Return Value type( result_t ) private function generate_ascii_string (self) result(generated_value) Arguments Type Intent Optional Attributes Name class( ascii_string_generator_t ), intent(in) :: self Return Value type( generated_t ) private function generate_integer (self) result(generated_value) Arguments Type Intent Optional Attributes Name class( integer_generator_t ), intent(in) :: self Return Value type( generated_t ) private function get_options () result(options) Arguments None Return Value type( options_t ) private function given_basic_c (description, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function given_basic_s (description, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function given_with_input_c (description, input, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function given_with_input_s (description, input, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private pure function individual_result (message, passed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message logical, intent(in) :: passed Return Value type( individual_result_t ) private elemental function individual_result_failure_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( individual_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) private elemental function individual_result_verbose_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( individual_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) private function input_test_case (description, test) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( input_test_i ) :: test Return Value type( input_test_case_t ) private function input_test_case_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( input_test_case_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) private function input_test_case_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( input_test_case_t ), intent(in) :: self Return Value type( test_result_item_t ) private function it_basic_c (description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) private function it_basic_s (description, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) private function it_input_c (description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_input_s (description, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_with_examples_c (description, examples, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( example_t ), intent(in) :: examples (:) procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_with_examples_s (description, examples, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( example_t ), intent(in) :: examples (:) procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_with_generator_c (description, generator, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description class( generator_t ), intent(in) :: generator procedure( input_test_i ) :: test Return Value type( test_item_t ) private function it_with_generator_s (description, generator, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( generator_t ), intent(in) :: generator procedure( input_test_i ) :: test Return Value type( test_item_t ) private pure function make_doesnt_include_failure_message_cc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_failure_message_cs (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_failure_message_sc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_failure_message_ss (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_success_message_cc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_success_message_cs (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_success_message_sc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_doesnt_include_success_message_ss (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_empty_failure_message_c (string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_empty_failure_message_s (string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_equals_failure_message_cc (expected, actual) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( varying_string ) private pure function make_equals_failure_message_cs (expected, actual) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( varying_string ) private pure function make_equals_failure_message_sc (expected, actual) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual Return Value type( varying_string ) private pure function make_equals_failure_message_ss (expected, actual) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual Return Value type( varying_string ) private pure function make_equals_success_message_c (expected) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected Return Value type( varying_string ) private pure function make_equals_success_message_s (expected) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected Return Value type( varying_string ) private pure function make_faster_than_failure_message_ccc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_ccs (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_csc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_css (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_scc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_scs (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_ssc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_failure_message_sss (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_ccc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_ccs (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_csc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_css (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_scc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_scs (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_ssc (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: iterations Return Value type( varying_string ) private pure function make_faster_than_success_message_sss (reference, actual, iterations) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: reference type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: iterations Return Value type( varying_string ) private pure function make_includes_failure_message_cc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_failure_message_cs (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_failure_message_sc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_failure_message_ss (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_succes_message_cs (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_succes_message_sc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_succes_message_ss (search_for, string) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: search_for type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function make_includes_success_message_cc (search_for, string) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_for character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function make_within_failure_message_ccc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_ccs (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_csc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_css (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_scc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_scs (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_ssc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_failure_message_sss (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_ccc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_ccs (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_csc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_css (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_scc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_scs (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected character(len=*), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_ssc (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual character(len=*), intent(in) :: tolerance Return Value type( varying_string ) private pure function make_within_success_message_sss (expected, actual, tolerance) result(message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: expected type( varying_string ), intent(in) :: actual type( varying_string ), intent(in) :: tolerance Return Value type( varying_string ) private pure function result_failure_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) private pure function result_num_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self Return Value integer private pure function result_num_failing_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self Return Value integer private pure function result_passed (self) result(passed) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self Return Value logical private pure function result_verbose_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) private pure function shrink_ascii_string (input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t ) private pure function shrink_integer (input) result(shrunk) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: input Return Value type( shrink_result_t ) private pure function shrink_result (value_, simplest) Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: value_ logical, intent(in) :: simplest Return Value type( shrink_result_t ) private function simple_test_case (description, test) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( simple_test_case_t ) private function simple_test_case_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( simple_test_case_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) private function simple_test_case_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( simple_test_case_t ), intent(in) :: self Return Value type( test_result_item_t ) private function simple_test_collection (description, tests) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( simple_test_collection_t ) private recursive function simple_test_collection_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( simple_test_collection_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) private recursive function simple_test_collection_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( simple_test_collection_t ), intent(in) :: self Return Value type( test_result_item_t ) private pure function succeed_c (message) result(success) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Return Value type( result_t ) private pure function succeed_s (message) result(success) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message Return Value type( result_t ) private pure function test_case_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value type( varying_string ) private pure function test_case_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) private pure function test_case_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_t ), intent(in) :: self Return Value integer private pure function test_case_result (description, result_) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( result_t ), intent(in) :: result_ Return Value type( test_case_result_t ) private pure function test_case_result_failure_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) private pure function test_case_result_num_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value integer private pure function test_case_result_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value integer private pure function test_case_result_num_failing_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value integer private pure function test_case_result_num_failing_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value integer private pure function test_case_result_passed (self) result(passed) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self Return Value logical private pure function test_case_result_verbose_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_case_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) private function test_case_with_examples (description, examples, test) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( example_t ), intent(in) :: examples (:) procedure( input_test_i ) :: test Return Value type( test_case_with_examples_t ) private function test_case_with_examples_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_case_with_examples_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) private function test_case_with_examples_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( test_case_with_examples_t ), intent(in) :: self Return Value type( test_result_item_t ) private function test_case_with_generator (description, generator, test) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( generator_t ), intent(in) :: generator procedure( input_test_i ) :: test Return Value type( test_case_with_generator_t ) private function test_case_with_generator_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_case_with_generator_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) private function test_case_with_generator_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( test_case_with_generator_t ), intent(in) :: self Return Value type( test_result_item_t ) private pure recursive function test_collection_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self Return Value type( varying_string ) private pure recursive function test_collection_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_result_t ) private pure recursive function test_collection_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_collection_t ), intent(in) :: self Return Value integer private pure function test_collection_result (description, results) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_result_item_t ), intent(in) :: results (:) Return Value type( test_collection_result_t ) private pure recursive function test_collection_result_failure_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) private pure recursive function test_collection_result_num_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value integer private pure recursive function test_collection_result_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value integer private pure recursive function test_collection_result_num_failing_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value integer private pure recursive function test_collection_result_num_failing_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value integer private pure recursive function test_collection_result_passed (self) result(passed) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self Return Value logical private pure recursive function test_collection_result_verbose_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_collection_result_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) private function test_collection_with_input (description, input, tests) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description class( input_t ), intent(in) :: input type( test_item_t ), intent(in) :: tests (:) Return Value type( test_collection_with_input_t ) private recursive function test_collection_with_input_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_collection_with_input_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) private recursive function test_collection_with_input_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( test_collection_with_input_t ), intent(in) :: self Return Value type( test_result_item_t ) private pure recursive function test_item_description (self) result(description) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self Return Value type( varying_string ) private pure recursive function test_item_filter (self, filter_string) result(filter_result) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self type( varying_string ), intent(in) :: filter_string Return Value type( filter_item_result_t ) private pure recursive function test_item_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self Return Value integer private recursive function test_item_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) private recursive function test_item_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( test_item_t ), intent(in) :: self Return Value type( test_result_item_t ) private pure recursive function test_result_item_failure_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) private pure recursive function test_result_item_num_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value integer private pure recursive function test_result_item_num_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value integer private pure recursive function test_result_item_num_failing_asserts (self) result(num_asserts) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value integer private pure recursive function test_result_item_num_failing_cases (self) result(num_cases) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value integer private pure recursive function test_result_item_passed (self) result(passed) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self Return Value logical private pure recursive function test_result_item_verbose_description (self, colorize) result(description) Arguments Type Intent Optional Attributes Name class( test_result_item_t ), intent(in) :: self logical, intent(in) :: colorize Return Value type( varying_string ) private function then_basic_c (description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) private function then_basic_s (description, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( simple_test_i ) :: test Return Value type( test_item_t ) private function then_input_c (description, test) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) private function then_input_s (description, test) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( input_test_i ) :: test Return Value type( test_item_t ) private function transforming_test_collection (description, transformer, tests) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( transformer_i ) :: transformer type( test_item_t ), intent(in) :: tests (:) Return Value type( transforming_test_collection_t ) private recursive function transforming_test_collection_run_with_input (self, input) result(result_) Arguments Type Intent Optional Attributes Name class( transforming_test_collection_t ), intent(in) :: self class( input_t ), intent(in) :: input Return Value type( test_result_item_t ) private function transforming_test_collection_run_without_input (self) result(result_) Arguments Type Intent Optional Attributes Name class( transforming_test_collection_t ), intent(in) :: self Return Value type( test_result_item_t ) private function when_basic_c (description, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function when_basic_s (description, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function when_with_transformer_c (description, transformer, tests) result(item) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description procedure( transformer_i ) :: transformer type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private function when_with_transformer_s (description, transformer, tests) result(item) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: description procedure( transformer_i ) :: transformer type( test_item_t ), intent(in) :: tests (:) Return Value type( test_item_t ) private pure function with_user_message_cc (message, user_message) result(whole_message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message character(len=*), intent(in) :: user_message Return Value type( varying_string ) private pure function with_user_message_cs (message, user_message) result(whole_message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message type( varying_string ), intent(in) :: user_message Return Value type( varying_string ) private pure function with_user_message_sc (message, user_message) result(whole_message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message character(len=*), intent(in) :: user_message Return Value type( varying_string ) private pure function with_user_message_ss (message, user_message) result(whole_message) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: message type( varying_string ), intent(in) :: user_message Return Value type( varying_string ) Subroutines public subroutine run_tests (tests) Arguments Type Intent Optional Attributes Name type( test_item_t ), intent(in) :: tests","tags":"","loc":"module/vegetables.html","title":"vegetables – miniFAVOR"},{"text":"Uses vegetables Contents Functions test_findloc check_absent_back check_character_array check_empty_character_array check_false_back check_logical_argument check_nonexistent_character_value check_true_back check_zero_sized_argument Functions public function test_findloc () result(tests) Arguments None Return Value type( test_item_t ) private function check_absent_back () result(result_) Arguments None Return Value type( result_t ) private function check_character_array () result(result_) Arguments None Return Value type( result_t ) private function check_empty_character_array () result(result_) Arguments None Return Value type( result_t ) private function check_false_back () result(result_) Arguments None Return Value type( result_t ) private function check_logical_argument () result(result_) Arguments None Return Value type( result_t ) private function check_nonexistent_character_value () result(result_) Arguments None Return Value type( result_t ) private function check_true_back () result(result_) Arguments None Return Value type( result_t ) private function check_zero_sized_argument () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/single_image_intrinsics_test.html","title":"single_image_intrinsics_test – miniFAVOR"},{"text":"summary: verify object pattern asbtract parent Uses vegetables object_interface Contents Derived Types subject Functions test_object check_default_initialization check_mark_as_defined Subroutines write_formatted Derived Types type, private, extends( object ) :: subject Components Type Visibility Attributes Name Initial procedure, public :: write_formatted Type-Bound Procedures procedure, public :: mark_as_defined procedure, public :: user_defined generic, public :: write(formatted) => write_formatted procedure(write_interface), public :: write_formatted Functions public function test_object () result(tests) Arguments None Return Value type( test_item_t ) private function check_default_initialization () result(result_) Verify that user_defined() is .false. for a default-initialied object Arguments None Return Value type( result_t ) private function check_mark_as_defined () result(result_) Verify that mark_as_defined results in user_defined() being .true. Arguments None Return Value type( result_t ) Subroutines private subroutine write_formatted (self, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( subject ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"module/object_interface_test.html","title":"object_interface_test – miniFAVOR"},{"text":"summary: verify data partitioning across images and data gathering Uses vegetables data_partition_interface iso_fortran_env Contents Variables dummy gatherer num_particles num_steps partition Functions test_data_partition verify_all_gather_1d_real_array verify_all_gather_2d_real_array verify_all_gather_2d_real_array_dim1 verify_all_particles_partitioned verify_block_partitioning verify_gather_2d_real_array_dim1 Variables Type Visibility Attributes Name Initial integer, private, parameter :: dummy = 0 integer, private, parameter :: gatherer = 1 integer, private, parameter :: num_particles = 31 integer, private, parameter :: num_steps = 9 type( data_partition ), private :: partition Functions public function test_data_partition () result(tests) Arguments None Return Value type( test_item_t ) private function verify_all_gather_1d_real_array (unused) result(result_) values to be gathered\n values to be overwritten by the gather\n values to be overwritten by the gather Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: unused Return Value type( result_t ) private function verify_all_gather_2d_real_array (unused) result(result_) values to be gathered\n values to be overwritten by the gather\n values to be overwritten by the gather Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: unused Return Value type( result_t ) private function verify_all_gather_2d_real_array_dim1 (unused) result(result_) values to be gathered\n values to be overwritten by the gather\n values to be overwritten by the gather Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: unused Return Value type( result_t ) private function verify_all_particles_partitioned () result(result_) Verify that the number of particles on each image sums to the\n total number of particles distributed. Arguments None Return Value type( result_t ) private function verify_block_partitioning () result(result_) Verify that the data is partitioned across images evenly to\n within a difference of one datum between any two images. Arguments None Return Value type( result_t ) private function verify_gather_2d_real_array_dim1 (unused) result(result_) values to be gathered\n values to be overwritten by the gather\n values to be overwritten by the gather Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: unused Return Value type( result_t )","tags":"","loc":"module/data_partition_test.html","title":"data_partition_test – miniFAVOR"},{"text":"Uses vegetables emulated_intrinsics_interface Contents Functions test_co_all test_co_sum check_co_all_with_all_true check_co_all_with_one_false check_co_sum_with_result_image check_co_sum_without_result_image Functions public function test_co_all () result(tests) Arguments None Return Value type( test_item_t ) public function test_co_sum () result(tests) Arguments None Return Value type( test_item_t ) private function check_co_all_with_all_true () result(result_) Arguments None Return Value type( result_t ) private function check_co_all_with_one_false () result(result_) Arguments None Return Value type( result_t ) private function check_co_sum_with_result_image () result(result_) Arguments None Return Value type( result_t ) private function check_co_sum_without_result_image () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/collective_subroutines_test.html","title":"collective_subroutines_test – miniFAVOR"},{"text":"This module contains two categories of procedures:\n 1. Emulations of some Fortran 2008 and 2018 instrinsic procedures for use with\n    compilers that lack support for the corresponding procedures.\n 2. User-defined collective procedures not defined in the Fortran standard.\n Fortran 2003 emulation of Fortran 2008 intrinsic procedures (e.g, findloc) Fortran 2008 coarray emulations of Fortran 2018 intrinsic collective subroutines Used by Descendants: emulated_intrinsics_implementation Contents Interfaces co_all Interfaces interface public module subroutine co_all(boolean) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(inout) :: boolean","tags":"","loc":"module/emulated_intrinsics_interface.html","title":"emulated_intrinsics_interface – miniFAVOR"},{"text":"Used by Descendants: string_functions_implementation Contents Variables csv_format Interfaces base_name file_extension string integer_to_string Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: csv_format = '(*(G0,:,\",\"))' Interfaces interface public pure module function base_name(file_name) result(base) Implementation → result contains all characters in file_name before the first dot (.) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),\n  allocatable interface public pure module function file_extension(file_name) result(extension) Implementation → result contains all characters in file_name after the first dot (.) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),\n  allocatable public interface string private interface integer_to_string () Arguments None interface private pure module function integer_to_string(integer_value) result(characters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: integer_value Return Value character(len=:),\n  allocatable","tags":"","loc":"module/string_functions_interface.html","title":"string_functions_interface – miniFAVOR"},{"text":"use assertions_interface, only : assert\ncall assert( 2 > 1, \"2 > 1\") Turn off assertions in production code by setting .true. to .false. via the preprocessor: caf -cpp -DUSE_ASSERTIONS=.false. -c assertions_interface.f90 Doing so may eliminate any associated runtime overhead by enabling optimizing compilers to ignore\n the assertion procedure body during a dead-code-removal phase of optimization. Used by Descendants: assertions_implementation Contents Variables assertions max_errmsg_len Interfaces assert Variables Type Visibility Attributes Name Initial logical, public, parameter :: assertions = .true. integer, public, parameter :: max_errmsg_len = len(\"warning (183): FASTMEM allocation is requested but the libmemkind library is not linked in, so using the default allocator.\") longest Intel compiler error message (see https://intel.ly/35x84yr). Interfaces interface public elemental module subroutine assert(assertion, description, diagnostic_data) Implementation → If assertion is .false., error-terminate with optional, variable stop code containing diagnostic_data Arguments Type Intent Optional Attributes Name logical, intent(in) :: assertion Most assertions will be expressions, e.g., call assert( i>0, \"positive i\") character(len=*), intent(in) :: description Brief statement of what is being asserted class(*), intent(in), optional :: diagnostic_data Optional error stop code, which may be of intrinsic type or object class","tags":"","loc":"module/assertions_interface.html","title":"assertions_interface – miniFAVOR"},{"text":"Used by Descendants: co_object_implementation Contents Interfaces mark_as_defined user_defined Derived Types co_object Interfaces interface private pure module subroutine mark_as_defined(this) Implementation → Mark the co_object as user-defined Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: this interface private pure module function user_defined(this) result(is_defined) Implementation → Return a boolean result indicating whether this co_object has been initialized since its declaration Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this Return Value logical Derived Types type, public, abstract :: co_object Components Type Visibility Attributes Name Initial logical, private :: defined = .false. Default initialization indicates not yet user-defined logical, private, allocatable :: facilitate_type_extension [:] Type-Bound Procedures procedure, public :: mark_as_defined procedure, public :: user_defined","tags":"","loc":"module/co_object_interface.html","title":"co_object_interface – miniFAVOR"},{"text":"distribute data identification numbers across images such that the number of\n items differs by at most 1 between any two images. Uses iso_fortran_env Used by Descendants: data_partition_implementation Contents Variables first_datum last_datum Interfaces define_partitions first gather_real_1d_array gather_real_2d_array last Derived Types data_partition Variables Type Visibility Attributes Name Initial integer, private, allocatable :: first_datum (:) integer, private, allocatable :: last_datum (:) Interfaces interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private module subroutine define_partitions(cardinality) Implementation → define the range of data identification numbers owned by the executing image Arguments Type Intent Optional Attributes Name integer, intent(in) :: cardinality interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private pure module function first(image_number) result(first_index) Implementation → the result is the first identification number owned by the executing image Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private module subroutine gather_real_1d_array(a, result_image, dim) Implementation → Gather the elements of an 1D array distributed along dimension dim onto result_image Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private module subroutine gather_real_2d_array(a, result_image, dim) Implementation → Gather the elements of an 2D array distributed along dimension dim onto result_image Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim interface Gathers are inherently expensive and are best used either\n 1. Near the beginning/end of execution to amortize costs across an entire run or\n 2. Temporarily while developing/debugging code. private pure module function last(image_number) result(last_index) Implementation → the result is the last identification number owned by the executing image Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer Derived Types type, public :: data_partition encapsulate a description of the data subset the executing image owns Type-Bound Procedures procedure, public, nopass :: define_partitions procedure, public, nopass :: first generic, public :: gather => gather_real_2d_array, gather_real_1d_array procedure, public, nopass :: last procedure, private, nopass :: gather_real_1d_array procedure, private, nopass :: gather_real_2d_array","tags":"","loc":"module/data_partition_interface.html","title":"data_partition_interface – miniFAVOR"},{"text":"Functionally pure array utilities\n Because the Fortran standard requires that operator dummy arguments have the intent(in) attribute\n exposing only the operator and not the function names communicates more information in the\n public interface and in code using this interface. Used by Descendants: array_functions_implementation Contents Interfaces operator(.catcolumns.) operator(.catrows.) operator(.columnvectors.) column_vectors concatenate_columns concatenate_rows Interfaces public interface operator(.catcolumns.) private interface concatenate_columns () Arguments None public interface operator(.catrows.) private interface concatenate_rows () Arguments None public interface operator(.columnvectors.) private interface column_vectors () Arguments None interface private pure module function column_vectors(vector_field) result(array_of_3d_column_vectors) Implementation → Result is array of 3D column vectors of dimension (space_dim,nx ny nz) reshaped from vector-field argument\n of dimension (nx,ny,nz,space_dim) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:,:,:) :: vector_field Return Value real,\n  dimension(:,:), allocatable interface private pure module function concatenate_columns(a, b) result(concatenated) Implementation → Result contains the concatenation of the columns of argument a with the columns of argument b Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,\n  dimension(:,:), allocatable interface private pure module function concatenate_rows(a, b) result(concatenated) Implementation → Result contains the concatenation of the rows of argument a with the rows of argument b Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,\n  dimension(:,:), allocatable","tags":"","loc":"module/array_functions_interface.html","title":"array_functions_interface – miniFAVOR"},{"text":"Used by Descendants: object_implementation Contents Interfaces mark_as_defined user_defined Abstract Interfaces write_interface Derived Types object Interfaces interface private pure module subroutine mark_as_defined(this) Implementation → Mark the object as user-defined Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this interface private pure module function user_defined(this) result(is_defined) Implementation → Return a boolean result indicating whether this object has been initialized since its declaration Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical Abstract Interfaces abstract interface private subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Derived Types type, public, abstract :: object Abstract type to ensure all objects extending it implement the required methods Read more… Components Type Visibility Attributes Name Initial logical, private :: defined = .false. Default initialization indicates not yet user-defined Type-Bound Procedures procedure, public :: mark_as_defined procedure, public :: user_defined generic, public :: write(formatted) => write_formatted procedure(write_interface), public :: write_formatted","tags":"","loc":"module/object_interface.html","title":"object_interface – miniFAVOR"},{"text":"Contents Functions test_join check_join_multiple check_join_one Functions public function test_join () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_join_multiple () result(result_) Arguments None Return Value type( result_t ) private pure function check_join_one () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/join_test.html","title":"join_test – miniFAVOR"},{"text":"Contents Functions test_read_file_lines alt_read_file_lines check_read_file_lines check_speed Functions public function test_read_file_lines () result(tests) Arguments None Return Value type( test_item_t ) private function alt_read_file_lines (filename) result(lines) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value type( varying_string ),\n  allocatable, (:) private function check_read_file_lines () result(result_) Arguments None Return Value type( result_t ) private function check_speed () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/read_file_lines_test.html","title":"read_file_lines_test – miniFAVOR"},{"text":"Uses strff Contents Variables test_text Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: test_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\"//newline//\"incididunt ut labore et dolore magna aliqua. Dis parturient montes nascetur\"//newline//\"ridiculus mus mauris vitae ultricies leo. Odio pellentesque diam volutpat\"//newline//\"commodo. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\"//newline//\"Blandit libero volutpat sed cras ornare arcu. Amet venenatis urna cursus eget\"//newline//\"nunc. Venenatis cras sed felis eget velit aliquet sagittis id. Massa tincidunt\"//newline//\"dui ut ornare lectus sit amet. Dui id ornare arcu odio ut sem nulla pharetra\"//newline//\"diam. Condimentum mattis pellentesque id nibh tortor id aliquet. Arcu dictum\"//newline//\"varius duis at consectetur lorem donec massa. Et netus et malesuada fames ac\"//newline//\"turpis egestas. Aliquet risus feugiat in ante metus dictum at tempor. Sagittis\"//newline//\"purus sit amet volutpat consequat. A arcu cursus vitae congue mauris rhoncus.\"//newline//\"Luctus venenatis lectus magna fringilla urna porttitor rhoncus dolor. Massa\"//newline//\"sapien faucibus et molestie ac feugiat sed lectus vestibulum. Turpis massa sed\"//newline//\"elementum tempus. At urna condimentum mattis pellentesque id nibh.\"//newline//\"\"//newline//\"Nunc lobortis mattis aliquam faucibus purus in. Sit amet aliquam id diam\"//newline//\"maecenas ultricies mi. Porttitor leo a diam sollicitudin tempor id eu nisl. Erat\"//newline//\"nam at lectus urna duis convallis convallis tellus. Sapien nec sagittis aliquam\"//newline//\"malesuada bibendum arcu vitae. Aenean pharetra magna ac placerat. Augue mauris\"//newline//\"augue neque gravida in fermentum. Urna et pharetra pharetra massa massa\"//newline//\"ultricies. Odio euismod lacinia at quis risus. Nisl tincidunt eget nullam non\"//newline//\"nisi est sit amet facilisis. Pretium vulputate sapien nec sagittis aliquam. Enim\"//newline//\"praesent elementum facilisis leo vel. Iaculis eu non diam phasellus vestibulum\"//newline//\"lorem sed. Duis ultricies lacus sed turpis tincidunt id. Eget egestas purus\"//newline//\"viverra accumsan in nisl. In eu mi bibendum neque egestas congue quisque egestas\"//newline//\"diam.\"//newline//\"\"//newline//\"Scelerisque purus semper eget duis at tellus at urna condimentum. Pellentesque\"//newline//\"dignissim enim sit amet. Urna nec tincidunt praesent semper feugiat. Lorem dolor\"//newline//\"sed viverra ipsum nunc aliquet. Sit amet aliquam id diam maecenas ultricies mi.\"//newline//\"Ut tortor pretium viverra suspendisse potenti nullam. Non quam lacus suspendisse\"//newline//\"faucibus interdum posuere lorem ipsum dolor. Ut sem viverra aliquet eget sit\"//newline//\"amet tellus cras adipiscing. Nulla malesuada pellentesque elit eget gravida.\"//newline//\"Tellus rutrum tellus pellentesque eu tincidunt. Morbi tristique senectus et\"//newline//\"netus et malesuada fames. Lacus sed viverra tellus in. Volutpat diam ut\"//newline//\"venenatis tellus in metus vulputate eu scelerisque. Habitasse platea dictumst\"//newline//\"quisque sagittis purus sit amet volutpat consequat. Enim ut sem viverra aliquet\"//newline//\"eget sit amet. Enim tortor at auctor urna nunc id cursus metus aliquam. Magna\"//newline//\"eget est lorem ipsum dolor sit amet consectetur adipiscing.\"//newline//\"\"//newline//\"Sed adipiscing diam donec adipiscing. Ultrices neque ornare aenean euismod\"//newline//\"elementum nisi quis. At ultrices mi tempus imperdiet nulla. Pellentesque\"//newline//\"habitant morbi tristique senectus et netus et malesuada fames. Pretium quam\"//newline//\"vulputate dignissim suspendisse. Justo nec ultrices dui sapien eget mi proin.\"//newline//\"Vitae sapien pellentesque habitant morbi tristique senectus. Neque volutpat ac\"//newline//\"tincidunt vitae semper quis lectus. Penatibus et magnis dis parturient montes\"//newline//\"nascetur ridiculus. Et malesuada fames ac turpis. Tellus elementum sagittis\"//newline//\"vitae et leo duis ut diam. Adipiscing commodo elit at imperdiet dui accumsan sit\"//newline//\"amet. Neque vitae tempus quam pellentesque nec nam aliquam.\"//newline//\"\"//newline//\"Faucibus in ornare quam viverra orci sagittis eu volutpat. Amet consectetur\"//newline//\"adipiscing elit pellentesque habitant. Faucibus scelerisque eleifend donec\"//newline//\"pretium vulputate sapien nec. Nunc scelerisque viverra mauris in aliquam sem\"//newline//\"fringilla. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\"//newline//\"Accumsan sit amet nulla facilisi morbi tempus iaculis urna id. Orci a\"//newline//\"scelerisque purus semper. Nulla malesuada pellentesque elit eget gravida cum.\"//newline//\"Gravida dictum fusce ut placerat orci nulla. Diam quam nulla porttitor massa id.\"//newline//\"Arcu non sodales neque sodales ut. Arcu dictum varius duis at consectetur lorem.\"//newline//\"Semper feugiat nibh sed pulvinar. Morbi tincidunt augue interdum velit euismod\"//newline//\"in pellentesque massa. Felis eget nunc lobortis mattis aliquam faucibus purus.\"//newline//\"Eros in cursus turpis massa tincidunt dui ut. Amet porttitor eget dolor morbi\"//newline//\"non arcu risus. Sagittis eu volutpat odio facilisis mauris sit amet massa vitae.\"//newline//\"Eu mi bibendum neque egestas.\"//newline//\"\"//newline//\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\"//newline//\"incididunt ut labore et dolore magna aliqua. Dis parturient montes nascetur\"//newline//\"ridiculus mus mauris vitae ultricies leo. Odio pellentesque diam volutpat\"//newline//\"commodo. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\"//newline//\"Blandit libero volutpat sed cras ornare arcu. Amet venenatis urna cursus eget\"//newline//\"nunc. Venenatis cras sed felis eget velit aliquet sagittis id. Massa tincidunt\"//newline//\"dui ut ornare lectus sit amet. Dui id ornare arcu odio ut sem nulla pharetra\"//newline//\"diam. Condimentum mattis pellentesque id nibh tortor id aliquet. Arcu dictum\"//newline//\"varius duis at consectetur lorem donec massa. Et netus et malesuada fames ac\"//newline//\"turpis egestas. Aliquet risus feugiat in ante metus dictum at tempor. Sagittis\"//newline//\"purus sit amet volutpat consequat. A arcu cursus vitae congue mauris rhoncus.\"//newline//\"Luctus venenatis lectus magna fringilla urna porttitor rhoncus dolor. Massa\"//newline//\"sapien faucibus et molestie ac feugiat sed lectus vestibulum. Turpis massa sed\"//newline//\"elementum tempus. At urna condimentum mattis pellentesque id nibh.\"//newline//\"\"//newline//\"Nunc lobortis mattis aliquam faucibus purus in. Sit amet aliquam id diam\"//newline//\"maecenas ultricies mi. Porttitor leo a diam sollicitudin tempor id eu nisl. Erat\"//newline//\"nam at lectus urna duis convallis convallis tellus. Sapien nec sagittis aliquam\"//newline//\"malesuada bibendum arcu vitae. Aenean pharetra magna ac placerat. Augue mauris\"//newline//\"augue neque gravida in fermentum. Urna et pharetra pharetra massa massa\"//newline//\"ultricies. Odio euismod lacinia at quis risus. Nisl tincidunt eget nullam non\"//newline//\"nisi est sit amet facilisis. Pretium vulputate sapien nec sagittis aliquam. Enim\"//newline//\"praesent elementum facilisis leo vel. Iaculis eu non diam phasellus vestibulum\"//newline//\"lorem sed. Duis ultricies lacus sed turpis tincidunt id. Eget egestas purus\"//newline//\"viverra accumsan in nisl. In eu mi bibendum neque egestas congue quisque egestas\"//newline//\"diam.\"//newline//\"\"//newline//\"Scelerisque purus semper eget duis at tellus at urna condimentum. Pellentesque\"//newline//\"dignissim enim sit amet. Urna nec tincidunt praesent semper feugiat. Lorem dolor\"//newline//\"sed viverra ipsum nunc aliquet. Sit amet aliquam id diam maecenas ultricies mi.\"//newline//\"Ut tortor pretium viverra suspendisse potenti nullam. Non quam lacus suspendisse\"//newline//\"faucibus interdum posuere lorem ipsum dolor. Ut sem viverra aliquet eget sit\"//newline//\"amet tellus cras adipiscing. Nulla malesuada pellentesque elit eget gravida.\"//newline//\"Tellus rutrum tellus pellentesque eu tincidunt. Morbi tristique senectus et\"//newline//\"netus et malesuada fames. Lacus sed viverra tellus in. Volutpat diam ut\"//newline//\"venenatis tellus in metus vulputate eu scelerisque. Habitasse platea dictumst\"//newline//\"quisque sagittis purus sit amet volutpat consequat. Enim ut sem viverra aliquet\"//newline//\"eget sit amet. Enim tortor at auctor urna nunc id cursus metus aliquam. Magna\"//newline//\"eget est lorem ipsum dolor sit amet consectetur adipiscing.\"//newline//\"\"//newline//\"Sed adipiscing diam donec adipiscing. Ultrices neque ornare aenean euismod\"//newline//\"elementum nisi quis. At ultrices mi tempus imperdiet nulla. Pellentesque\"//newline//\"habitant morbi tristique senectus et netus et malesuada fames. Pretium quam\"//newline//\"vulputate dignissim suspendisse. Justo nec ultrices dui sapien eget mi proin.\"//newline//\"Vitae sapien pellentesque habitant morbi tristique senectus. Neque volutpat ac\"//newline//\"tincidunt vitae semper quis lectus. Penatibus et magnis dis parturient montes\"//newline//\"nascetur ridiculus. Et malesuada fames ac turpis. Tellus elementum sagittis\"//newline//\"vitae et leo duis ut diam. Adipiscing commodo elit at imperdiet dui accumsan sit\"//newline//\"amet. Neque vitae tempus quam pellentesque nec nam aliquam.\"//newline//\"\"//newline//\"Faucibus in ornare quam viverra orci sagittis eu volutpat. Amet consectetur\"//newline//\"adipiscing elit pellentesque habitant. Faucibus scelerisque eleifend donec\"//newline//\"pretium vulputate sapien nec. Nunc scelerisque viverra mauris in aliquam sem\"//newline//\"fringilla. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\"//newline//\"Accumsan sit amet nulla facilisi morbi tempus iaculis urna id. Orci a\"//newline//\"scelerisque purus semper. Nulla malesuada pellentesque elit eget gravida cum.\"//newline//\"Gravida dictum fusce ut placerat orci nulla. Diam quam nulla porttitor massa id.\"//newline//\"Arcu non sodales neque sodales ut. Arcu dictum varius duis at consectetur lorem.\"//newline//\"Semper feugiat nibh sed pulvinar. Morbi tincidunt augue interdum velit euismod\"//newline//\"in pellentesque massa. Felis eget nunc lobortis mattis aliquam faucibus purus.\"//newline//\"Eros in cursus turpis massa tincidunt dui ut. Amet porttitor eget dolor morbi\"//newline//\"non arcu risus. Sagittis eu volutpat odio facilisis mauris sit amet massa vitae.\"//newline//\"Eu mi bibendum neque egestas.\"//newline//\"\"//newline//\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\"//newline//\"incididunt ut labore et dolore magna aliqua. Dis parturient montes nascetur\"//newline//\"ridiculus mus mauris vitae ultricies leo. Odio pellentesque diam volutpat\"//newline//\"commodo. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\"//newline//\"Blandit libero volutpat sed cras ornare arcu. Amet venenatis urna cursus eget\"//newline//\"nunc. Venenatis cras sed felis eget velit aliquet sagittis id. Massa tincidunt\"//newline//\"dui ut ornare lectus sit amet. Dui id ornare arcu odio ut sem nulla pharetra\"//newline//\"diam. Condimentum mattis pellentesque id nibh tortor id aliquet. Arcu dictum\"//newline//\"varius duis at consectetur lorem donec massa. Et netus et malesuada fames ac\"//newline//\"turpis egestas. Aliquet risus feugiat in ante metus dictum at tempor. Sagittis\"//newline//\"purus sit amet volutpat consequat. A arcu cursus vitae congue mauris rhoncus.\"//newline//\"Luctus venenatis lectus magna fringilla urna porttitor rhoncus dolor. Massa\"//newline//\"sapien faucibus et molestie ac feugiat sed lectus vestibulum. Turpis massa sed\"//newline//\"elementum tempus. At urna condimentum mattis pellentesque id nibh.\"//newline//\"\"//newline//\"Nunc lobortis mattis aliquam faucibus purus in. Sit amet aliquam id diam\"//newline//\"maecenas ultricies mi. Porttitor leo a diam sollicitudin tempor id eu nisl. Erat\"//newline//\"nam at lectus urna duis convallis convallis tellus. Sapien nec sagittis aliquam\"//newline//\"malesuada bibendum arcu vitae. Aenean pharetra magna ac placerat. Augue mauris\"//newline//\"augue neque gravida in fermentum. Urna et pharetra pharetra massa massa\"//newline//\"ultricies. Odio euismod lacinia at quis risus. Nisl tincidunt eget nullam non\"//newline//\"nisi est sit amet facilisis. Pretium vulputate sapien nec sagittis aliquam. Enim\"//newline//\"praesent elementum facilisis leo vel. Iaculis eu non diam phasellus vestibulum\"//newline//\"lorem sed. Duis ultricies lacus sed turpis tincidunt id. Eget egestas purus\"//newline//\"viverra accumsan in nisl. In eu mi bibendum neque egestas congue quisque egestas\"//newline//\"diam.\"//newline//\"\"//newline//\"Scelerisque purus semper eget duis at tellus at urna condimentum. Pellentesque\"//newline//\"dignissim enim sit amet. Urna nec tincidunt praesent semper feugiat. Lorem dolor\"//newline//\"sed viverra ipsum nunc aliquet. Sit amet aliquam id diam maecenas ultricies mi.\"//newline//\"Ut tortor pretium viverra suspendisse potenti nullam. Non quam lacus suspendisse\"//newline//\"faucibus interdum posuere lorem ipsum dolor. Ut sem viverra aliquet eget sit\"//newline//\"amet tellus cras adipiscing. Nulla malesuada pellentesque elit eget gravida.\"//newline//\"Tellus rutrum tellus pellentesque eu tincidunt. Morbi tristique senectus et\"//newline//\"netus et malesuada fames. Lacus sed viverra tellus in. Volutpat diam ut\"//newline//\"venenatis tellus in metus vulputate eu scelerisque. Habitasse platea dictumst\"//newline//\"quisque sagittis purus sit amet volutpat consequat. Enim ut sem viverra aliquet\"//newline//\"eget sit amet. Enim tortor at auctor urna nunc id cursus metus aliquam. Magna\"//newline//\"eget est lorem ipsum dolor sit amet consectetur adipiscing.\"//newline//\"\"//newline//\"Sed adipiscing diam donec adipiscing. Ultrices neque ornare aenean euismod\"//newline//\"elementum nisi quis. At ultrices mi tempus imperdiet nulla. Pellentesque\"//newline//\"habitant morbi tristique senectus et netus et malesuada fames. Pretium quam\"//newline//\"vulputate dignissim suspendisse. Justo nec ultrices dui sapien eget mi proin.\"//newline//\"Vitae sapien pellentesque habitant morbi tristique senectus. Neque volutpat ac\"//newline//\"tincidunt vitae semper quis lectus. Penatibus et magnis dis parturient montes\"//newline//\"nascetur ridiculus. Et malesuada fames ac turpis. Tellus elementum sagittis\"//newline//\"vitae et leo duis ut diam. Adipiscing commodo elit at imperdiet dui accumsan sit\"//newline//\"amet. Neque vitae tempus quam pellentesque nec nam aliquam.\"//newline//\"\"//newline//\"Faucibus in ornare quam viverra orci sagittis eu volutpat. Amet consectetur\"//newline//\"adipiscing elit pellentesque habitant. Faucibus scelerisque eleifend donec\"//newline//\"pretium vulputate sapien nec. Nunc scelerisque viverra mauris in aliquam sem\"//newline//\"fringilla. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\"//newline//\"Accumsan sit amet nulla facilisi morbi tempus iaculis urna id. Orci a\"//newline//\"scelerisque purus semper. Nulla malesuada pellentesque elit eget gravida cum.\"//newline//\"Gravida dictum fusce ut placerat orci nulla. Diam quam nulla porttitor massa id.\"//newline//\"Arcu non sodales neque sodales ut. Arcu dictum varius duis at consectetur lorem.\"//newline//\"Semper feugiat nibh sed pulvinar. Morbi tincidunt augue interdum velit euismod\"//newline//\"in pellentesque massa. Felis eget nunc lobortis mattis aliquam faucibus purus.\"//newline//\"Eros in cursus turpis massa tincidunt dui ut. Amet porttitor eget dolor morbi\"//newline//\"non arcu risus. Sagittis eu volutpat odio facilisis mauris sit amet massa vitae.\"//newline//\"Eu mi bibendum neque egestas.\"//newline//\"\"//newline//\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\"//newline//\"incididunt ut labore et dolore magna aliqua. Dis parturient montes nascetur\"//newline//\"ridiculus mus mauris vitae ultricies leo. Odio pellentesque diam volutpat\"//newline//\"commodo. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\"//newline//\"Blandit libero volutpat sed cras ornare arcu. Amet venenatis urna cursus eget\"//newline//\"nunc. Venenatis cras sed felis eget velit aliquet sagittis id. Massa tincidunt\"//newline//\"dui ut ornare lectus sit amet. Dui id ornare arcu odio ut sem nulla pharetra\"//newline//\"diam. Condimentum mattis pellentesque id nibh tortor id aliquet. Arcu dictum\"//newline//\"varius duis at consectetur lorem donec massa. Et netus et malesuada fames ac\"//newline//\"turpis egestas. Aliquet risus feugiat in ante metus dictum at tempor. Sagittis\"//newline//\"purus sit amet volutpat consequat. A arcu cursus vitae congue mauris rhoncus.\"//newline//\"Luctus venenatis lectus magna fringilla urna porttitor rhoncus dolor. Massa\"//newline//\"sapien faucibus et molestie ac feugiat sed lectus vestibulum. Turpis massa sed\"//newline//\"elementum tempus. At urna condimentum mattis pellentesque id nibh.\"//newline//\"\"//newline//\"Nunc lobortis mattis aliquam faucibus purus in. Sit amet aliquam id diam\"//newline//\"maecenas ultricies mi. Porttitor leo a diam sollicitudin tempor id eu nisl. Erat\"//newline//\"nam at lectus urna duis convallis convallis tellus. Sapien nec sagittis aliquam\"//newline//\"malesuada bibendum arcu vitae. Aenean pharetra magna ac placerat. Augue mauris\"//newline//\"augue neque gravida in fermentum. Urna et pharetra pharetra massa massa\"//newline//\"ultricies. Odio euismod lacinia at quis risus. Nisl tincidunt eget nullam non\"//newline//\"nisi est sit amet facilisis. Pretium vulputate sapien nec sagittis aliquam. Enim\"//newline//\"praesent elementum facilisis leo vel. Iaculis eu non diam phasellus vestibulum\"//newline//\"lorem sed. Duis ultricies lacus sed turpis tincidunt id. Eget egestas purus\"//newline//\"viverra accumsan in nisl. In eu mi bibendum neque egestas congue quisque egestas\"//newline//\"diam.\"//newline//\"\"//newline//\"Scelerisque purus semper eget duis at tellus at urna condimentum. Pellentesque\"//newline//\"dignissim enim sit amet. Urna nec tincidunt praesent semper feugiat. Lorem dolor\"//newline//\"sed viverra ipsum nunc aliquet. Sit amet aliquam id diam maecenas ultricies mi.\"//newline//\"Ut tortor pretium viverra suspendisse potenti nullam. Non quam lacus suspendisse\"//newline//\"faucibus interdum posuere lorem ipsum dolor. Ut sem viverra aliquet eget sit\"//newline//\"amet tellus cras adipiscing. Nulla malesuada pellentesque elit eget gravida.\"//newline//\"Tellus rutrum tellus pellentesque eu tincidunt. Morbi tristique senectus et\"//newline//\"netus et malesuada fames. Lacus sed viverra tellus in. Volutpat diam ut\"//newline//\"venenatis tellus in metus vulputate eu scelerisque. Habitasse platea dictumst\"//newline//\"quisque sagittis purus sit amet volutpat consequat. Enim ut sem viverra aliquet\"//newline//\"eget sit amet. Enim tortor at auctor urna nunc id cursus metus aliquam. Magna\"//newline//\"eget est lorem ipsum dolor sit amet consectetur adipiscing.\"//newline//\"\"//newline//\"Sed adipiscing diam donec adipiscing. Ultrices neque ornare aenean euismod\"//newline//\"elementum nisi quis. At ultrices mi tempus imperdiet nulla. Pellentesque\"//newline//\"habitant morbi tristique senectus et netus et malesuada fames. Pretium quam\"//newline//\"vulputate dignissim suspendisse. Justo nec ultrices dui sapien eget mi proin.\"//newline//\"Vitae sapien pellentesque habitant morbi tristique senectus. Neque volutpat ac\"//newline//\"tincidunt vitae semper quis lectus. Penatibus et magnis dis parturient montes\"//newline//\"nascetur ridiculus. Et malesuada fames ac turpis. Tellus elementum sagittis\"//newline//\"vitae et leo duis ut diam. Adipiscing commodo elit at imperdiet dui accumsan sit\"//newline//\"amet. Neque vitae tempus quam pellentesque nec nam aliquam.\"//newline//\"\"//newline//\"Faucibus in ornare quam viverra orci sagittis eu volutpat. Amet consectetur\"//newline//\"adipiscing elit pellentesque habitant. Faucibus scelerisque eleifend donec\"//newline//\"pretium vulputate sapien nec. Nunc scelerisque viverra mauris in aliquam sem\"//newline//\"fringilla. Elit at imperdiet dui accumsan sit amet nulla facilisi morbi.\"//newline//\"Accumsan sit amet nulla facilisi morbi tempus iaculis urna id. Orci a\"//newline//\"scelerisque purus semper. Nulla malesuada pellentesque elit eget gravida cum.\"//newline//\"Gravida dictum fusce ut placerat orci nulla. Diam quam nulla porttitor massa id.\"//newline//\"Arcu non sodales neque sodales ut. Arcu dictum varius duis at consectetur lorem.\"//newline//\"Semper feugiat nibh sed pulvinar. Morbi tincidunt augue interdum velit euismod\"//newline//\"in pellentesque massa. Felis eget nunc lobortis mattis aliquam faucibus purus.\"//newline//\"Eros in cursus turpis massa tincidunt dui ut. Amet porttitor eget dolor morbi\"//newline//\"non arcu risus. Sagittis eu volutpat odio facilisis mauris sit amet massa vitae.\"//newline//\"Eu mi bibendum neque egestas.\"//newline","tags":"","loc":"module/text_m.html","title":"text_m – miniFAVOR"},{"text":"Contents Functions test_to_string_for_doubles test_to_string_for_integers check_handles_extreme_numbers check_handles_zero check_includes_zero_after_decimal check_negative_numbers check_only_keeps_six_digits check_round_numbers checkto_string_for_integers Functions public function test_to_string_for_doubles () result(tests) Arguments None Return Value type( test_item_t ) public function test_to_string_for_integers () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_handles_extreme_numbers () result(result_) Arguments None Return Value type( result_t ) private pure function check_handles_zero () result(result_) Arguments None Return Value type( result_t ) private pure function check_includes_zero_after_decimal () result(result_) Arguments None Return Value type( result_t ) private pure function check_negative_numbers () result(result_) Arguments None Return Value type( result_t ) private pure function check_only_keeps_six_digits () result(result_) Arguments None Return Value type( result_t ) private pure function check_round_numbers () result(result_) Arguments None Return Value type( result_t ) private pure function checkto_string_for_integers () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/to_string_test.html","title":"to_string_test – miniFAVOR"},{"text":"Contents Functions test_read_file check_read_file Functions public function test_read_file () result(tests) Arguments None Return Value type( test_item_t ) private function check_read_file () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/read_file_test.html","title":"read_file_test – miniFAVOR"},{"text":"Contents Functions test_indent check_indents_correctly check_single_line Functions public function test_indent () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_indents_correctly () result(result_) Arguments None Return Value type( result_t ) private pure function check_single_line () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/indent_test.html","title":"indent_test – miniFAVOR"},{"text":"Contents Functions test_starts_with check_false check_true Functions public function test_starts_with () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_false () result(result_) Arguments None Return Value type( result_t ) private pure function check_true () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/starts_with_test.html","title":"starts_with_test – miniFAVOR"},{"text":"Contents Functions test_split_at check_for_empty_string check_for_only_split_characters check_no_empty_begin check_no_empty_between check_no_empty_end check_no_split_characters check_split_at_something check_split_doesnt_contain Functions public function test_split_at () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_for_empty_string () result(result_) Arguments None Return Value type( result_t ) private pure function check_for_only_split_characters () result(result_) Arguments None Return Value type( result_t ) private pure function check_no_empty_begin () result(result_) Arguments None Return Value type( result_t ) private pure function check_no_empty_between () result(result_) Arguments None Return Value type( result_t ) private pure function check_no_empty_end () result(result_) Arguments None Return Value type( result_t ) private pure function check_no_split_characters () result(result_) Arguments None Return Value type( result_t ) private pure function check_split_at_something () result(result_) Arguments None Return Value type( result_t ) private pure function check_split_doesnt_contain () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/split_at_test.html","title":"split_at_test – miniFAVOR"},{"text":"Contents Functions test_hanging_indent check_indents_correctly check_single_line Functions public function test_hanging_indent () result(tests) Arguments None Return Value type( test_item_t ) private pure function check_indents_correctly () result(result_) Arguments None Return Value type( result_t ) private pure function check_single_line () result(result_) Arguments None Return Value type( result_t )","tags":"","loc":"module/hanging_indent_test.html","title":"hanging_indent_test – miniFAVOR"},{"text":"Contents Variables newline Interfaces cover_empty_decimal first_character hanging_indent includes indent join last_character operator(.includes.) operator(.startswith.) read_file read_file_lines remove_trailing_zeros split_at to_string without_first_character without_last_character Functions cover_empty_decimal_c cover_empty_decimal_s first_character_c first_character_s hanging_indent_c hanging_indent_s includes_cc includes_cs includes_sc includes_ss indent_c indent_s join_c join_s last_character_c last_character_s read_file_c read_file_lines_c read_file_lines_s read_file_s remove_trailing_zeros_c remove_trailing_zeros_s split_at_cc split_at_cs split_at_sc split_at_ss starts_with_cc starts_with_cs starts_with_sc starts_with_ss to_string_int16 to_string_int32 to_string_int64 to_string_int8 to_string_logical to_string_real32 to_string_real64 to_string_with_significant_digits_real32 to_string_with_significant_digits_real64 without_first_character_c without_first_character_s without_last_character_c without_last_character_s Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: newline = new_line('A') Interfaces public interface cover_empty_decimal private pure function cover_empty_decimal_c (number) result(fixed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: number Return Value type( varying_string ) private pure function cover_empty_decimal_s (number) result(fixed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: number Return Value type( varying_string ) public interface first_character private pure function first_character_c (string) result(char_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=1) private pure function first_character_s (string) result(char_) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value character(len=1) public interface hanging_indent private pure function hanging_indent_c (string, spaces) result(indented) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) private pure function hanging_indent_s (string, spaces) result(indented) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) public interface includes private pure function includes_cc (within, search_for) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: within character(len=*), intent(in) :: search_for Return Value logical private pure function includes_cs (within, search_for) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: within type( varying_string ), intent(in) :: search_for Return Value logical private pure function includes_sc (within, search_for) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: within character(len=*), intent(in) :: search_for Return Value logical private pure function includes_ss (within, search_for) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: within type( varying_string ), intent(in) :: search_for Return Value logical public interface indent private pure function indent_c (string, spaces) result(indented) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) private pure function indent_s (string, spaces) result(indented) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) public interface join private pure function join_c (strings, separator) result(string) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: strings (:) character(len=*), intent(in) :: separator Return Value type( varying_string ) private pure recursive function join_s (strings, separator) result(string) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: strings (:) type( varying_string ), intent(in) :: separator Return Value type( varying_string ) public interface last_character private pure function last_character_c (string) result(char_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=1) private pure function last_character_s (string) result(char_) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value character(len=1) public interface operator(.includes.) private pure function includes_cc (within, search_for) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: within character(len=*), intent(in) :: search_for Return Value logical private pure function includes_cs (within, search_for) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: within type( varying_string ), intent(in) :: search_for Return Value logical private pure function includes_sc (within, search_for) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: within character(len=*), intent(in) :: search_for Return Value logical private pure function includes_ss (within, search_for) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: within type( varying_string ), intent(in) :: search_for Return Value logical public interface operator(.startswith.) private pure function starts_with_cc (string, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private pure function starts_with_cs (string, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: substring Return Value logical private pure function starts_with_sc (string, substring) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private pure function starts_with_ss (string, substring) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: substring Return Value logical public interface read_file private function read_file_c (filename) result(contents) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value type( varying_string ) private function read_file_s (filename) result(contents) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename Return Value type( varying_string ) public interface read_file_lines private function read_file_lines_c (filename) result(lines) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value type( varying_string ),\n  allocatable, (:) private function read_file_lines_s (filename) result(lines) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename Return Value type( varying_string ),\n  allocatable, (:) public interface remove_trailing_zeros private pure recursive function remove_trailing_zeros_c (number) result(trimmed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: number Return Value type( varying_string ) private pure recursive function remove_trailing_zeros_s (number) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: number Return Value type( varying_string ) public interface split_at private pure recursive function split_at_cc (string, split_characters) result(strings) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable, (:) private pure function split_at_cs (string, split_characters) result(strings) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable, (:) private pure recursive function split_at_sc (string, split_characters) result(strings) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable, (:) private pure function split_at_ss (string, split_characters) result(strings) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable, (:) public interface to_string private pure function to_string_int8 (number) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: number Return Value type( varying_string ) private pure function to_string_int16 (number) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: number Return Value type( varying_string ) private pure function to_string_int32 (number) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number Return Value type( varying_string ) private pure function to_string_int64 (number) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: number Return Value type( varying_string ) private pure function to_string_logical (logical_) result(string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logical_ Return Value type( varying_string ) private pure function to_string_real32 (number) result(string) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: number Return Value type( varying_string ) private pure function to_string_real64 (number) result(string) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: number Return Value type( varying_string ) private pure function to_string_with_significant_digits_real32 (number, significant_digits) result(string_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: number integer, intent(in) :: significant_digits Return Value type( varying_string ) private pure function to_string_with_significant_digits_real64 (number, significant_digits) result(string_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: number integer, intent(in) :: significant_digits Return Value type( varying_string ) public interface without_first_character private pure function without_first_character_c (string) result(trimmed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function without_first_character_s (string) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) public interface without_last_character private pure function without_last_character_c (string) result(trimmed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function without_last_character_s (string) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) Functions private pure function cover_empty_decimal_c (number) result(fixed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: number Return Value type( varying_string ) private pure function cover_empty_decimal_s (number) result(fixed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: number Return Value type( varying_string ) private pure function first_character_c (string) result(char_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=1) private pure function first_character_s (string) result(char_) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value character(len=1) private pure function hanging_indent_c (string, spaces) result(indented) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) private pure function hanging_indent_s (string, spaces) result(indented) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) private pure function includes_cc (within, search_for) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: within character(len=*), intent(in) :: search_for Return Value logical private pure function includes_cs (within, search_for) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: within type( varying_string ), intent(in) :: search_for Return Value logical private pure function includes_sc (within, search_for) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: within character(len=*), intent(in) :: search_for Return Value logical private pure function includes_ss (within, search_for) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: within type( varying_string ), intent(in) :: search_for Return Value logical private pure function indent_c (string, spaces) result(indented) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) private pure function indent_s (string, spaces) result(indented) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string integer, intent(in) :: spaces Return Value type( varying_string ) private pure function join_c (strings, separator) result(string) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: strings (:) character(len=*), intent(in) :: separator Return Value type( varying_string ) private pure recursive function join_s (strings, separator) result(string) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: strings (:) type( varying_string ), intent(in) :: separator Return Value type( varying_string ) private pure function last_character_c (string) result(char_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=1) private pure function last_character_s (string) result(char_) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value character(len=1) private function read_file_c (filename) result(contents) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value type( varying_string ) private function read_file_lines_c (filename) result(lines) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value type( varying_string ),\n  allocatable, (:) private function read_file_lines_s (filename) result(lines) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename Return Value type( varying_string ),\n  allocatable, (:) private function read_file_s (filename) result(contents) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: filename Return Value type( varying_string ) private pure recursive function remove_trailing_zeros_c (number) result(trimmed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: number Return Value type( varying_string ) private pure recursive function remove_trailing_zeros_s (number) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: number Return Value type( varying_string ) private pure recursive function split_at_cc (string, split_characters) result(strings) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable, (:) private pure function split_at_cs (string, split_characters) result(strings) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable, (:) private pure recursive function split_at_sc (string, split_characters) result(strings) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable, (:) private pure function split_at_ss (string, split_characters) result(strings) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: split_characters Return Value type( varying_string ),\n  allocatable, (:) private pure function starts_with_cc (string, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private pure function starts_with_cs (string, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( varying_string ), intent(in) :: substring Return Value logical private pure function starts_with_sc (string, substring) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private pure function starts_with_ss (string, substring) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string type( varying_string ), intent(in) :: substring Return Value logical private pure function to_string_int16 (number) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: number Return Value type( varying_string ) private pure function to_string_int32 (number) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: number Return Value type( varying_string ) private pure function to_string_int64 (number) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: number Return Value type( varying_string ) private pure function to_string_int8 (number) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: number Return Value type( varying_string ) private pure function to_string_logical (logical_) result(string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logical_ Return Value type( varying_string ) private pure function to_string_real32 (number) result(string) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: number Return Value type( varying_string ) private pure function to_string_real64 (number) result(string) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: number Return Value type( varying_string ) private pure function to_string_with_significant_digits_real32 (number, significant_digits) result(string_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: number integer, intent(in) :: significant_digits Return Value type( varying_string ) private pure function to_string_with_significant_digits_real64 (number, significant_digits) result(string_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: number integer, intent(in) :: significant_digits Return Value type( varying_string ) private pure function without_first_character_c (string) result(trimmed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function without_first_character_s (string) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string ) private pure function without_last_character_c (string) result(trimmed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( varying_string ) private pure function without_last_character_s (string) result(trimmed) Arguments Type Intent Optional Attributes Name type( varying_string ), intent(in) :: string Return Value type( varying_string )","tags":"","loc":"module/strff.html","title":"strff – miniFAVOR"},{"text":"Uses assertions_interface Ancestors: randomness_m Contents Module Procedures cu_local cu_sig_local define ni_local phi write_formatted Module Procedures module procedure cu_local pure module function cu_local(self) result(self_cu_local) Interface → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real module procedure cu_sig_local pure module function cu_sig_local(self) result(self_cu_sig_local) Interface → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real module procedure define module subroutine define(self) Interface → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(out) :: self module procedure ni_local pure module function ni_local(self) result(self_ni_local) Interface → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real module procedure phi pure module function phi(self) result(self_phi) Interface → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self Return Value real module procedure write_formatted module subroutine write_formatted(self, unit, iotype, v_list, iostat, iomsg) Interface → Arguments Type Intent Optional Attributes Name class( random_samples_t ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"module/randomness_s.html","title":"randomness_s – miniFAVOR"},{"text":"Uses Ancestors: object_interface Contents Module Procedures mark_as_defined user_defined Module Procedures module procedure mark_as_defined pure module subroutine mark_as_defined(this) Interface → Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this module procedure user_defined pure module function user_defined(this) result(is_defined) Interface → Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical","tags":"","loc":"module/object_implementation.html","title":"object_implementation – miniFAVOR"},{"text":"Uses assertions_interface Ancestors: array_functions_interface Contents Module Procedures column_vectors concatenate_columns concatenate_rows Module Procedures module procedure column_vectors pure module function column_vectors(vector_field) result(array_of_3d_column_vectors) Interface → Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:,:,:) :: vector_field Return Value real,\n  dimension(:,:), allocatable module procedure concatenate_columns pure module function concatenate_columns(a, b) result(concatenated) Interface → Using reshape rather than manipulating array elements directly frees the compiler to decide the particular order of array\n element references that best exploits the given platform.  Alternatively, do concurrent could instead free the compiler\n to order element accesses however is best. Trade-off: reshape requires the creation of temporary array results but reshape\n is likely to have more mature compiler support than do concurrent.  If this code turns out to be a critical performance\n bottleneck, try replacing this implementation with element-by-element copying using do concurrent. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,\n  dimension(:,:), allocatable module procedure concatenate_rows pure module function concatenate_rows(a, b) result(concatenated) Interface → For simplicity, this implementation invokes concatenate_columns at the cost of transpose creating additional temporaries.\n If this code turns out to be a critical performance bottleneck, try replacing this implementation with element-by-element\n copying using do concurrent. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,\n  dimension(:,:), allocatable","tags":"","loc":"module/array_functions_implementation.html","title":"array_functions_implementation – miniFAVOR"},{"text":"Uses assertions_interface Ancestors: emulated_intrinsics_interface Contents Functions both Module Procedures co_all Functions pure function both (lhs, rhs) result(lhs_and_rhs) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lhs logical, intent(in) :: rhs Return Value logical Module Procedures module procedure co_all module subroutine co_all(boolean) Interface → Arguments Type Intent Optional Attributes Name logical, intent(inout) :: boolean","tags":"","loc":"module/emulated_intrinsics_implementation.html","title":"emulated_intrinsics_implementation – miniFAVOR"},{"text":"Uses Ancestors: string_functions_interface Contents Module Procedures base_name file_extension integer_to_string Module Procedures module procedure base_name pure module function base_name(file_name) result(base) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),\n  allocatable module procedure file_extension pure module function file_extension(file_name) result(extension) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),\n  allocatable module procedure integer_to_string pure module function integer_to_string(integer_value) result(characters) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: integer_value Return Value character(len=:),\n  allocatable","tags":"","loc":"module/string_functions_implementation.html","title":"string_functions_implementation – miniFAVOR"},{"text":"Uses Ancestors: co_object_interface Contents Module Procedures mark_as_defined user_defined Module Procedures module procedure mark_as_defined pure module subroutine mark_as_defined(this) Interface → Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: this module procedure user_defined pure module function user_defined(this) result(is_defined) Interface → Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this Return Value logical","tags":"","loc":"module/co_object_implementation.html","title":"co_object_implementation – miniFAVOR"},{"text":"Uses Ancestors: assertions_interface Contents Module Procedures assert Module Procedures module procedure assert elemental module subroutine assert(assertion, description, diagnostic_data) Interface → Arguments Type Intent Optional Attributes Name logical, intent(in) :: assertion Most assertions will be expressions, e.g., call assert( i>0, \"positive i\") character(len=*), intent(in) :: description Brief statement of what is being asserted class(*), intent(in), optional :: diagnostic_data Optional error stop code, which may be of intrinsic type or object class","tags":"","loc":"module/assertions_implementation.html","title":"assertions_implementation – miniFAVOR"},{"text":"Uses assertions_interface Ancestors: data_partition_interface Contents Variables verbose Functions overflow Module Procedures define_partitions first gather_real_1d_array gather_real_2d_array last Variables Type Visibility Attributes Name Initial logical, private, parameter :: verbose = .false. Functions pure function overflow (im, excess) result(extra_datum) Arguments Type Intent Optional Attributes Name integer, intent(in) :: im integer, intent(in) :: excess Return Value integer Module Procedures module procedure define_partitions module subroutine define_partitions(cardinality) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: cardinality module procedure first pure module function first(image_number) result(first_index) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer module procedure gather_real_1d_array module subroutine gather_real_1d_array(a, result_image, dim) Interface → Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim module procedure gather_real_2d_array module subroutine gather_real_2d_array(a, result_image, dim) Interface → Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim module procedure last pure module function last(image_number) result(last_index) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer","tags":"","loc":"module/data_partition_implementation.html","title":"data_partition_implementation – miniFAVOR"},{"text":"Uses i_o calc_rtndt calc_k calc_cpi randomness_m Contents Variables a b chemistry_content chemistry_factor cpi cpi_avg cpi_hist cu_ave cu_sig details fn_in fsurf i j k_hist n_dat n_echo n_in n_out ni_ave ni_sig nmaterials nsim ntime num_seeds r_tndt rtndt0 samples stress temp Source Code minifavor Variables Type Attributes Name Initial real :: a real :: b real, dimension(:,:), allocatable :: chemistry_content real, allocatable :: chemistry_factor (:) real, allocatable :: cpi (:) real, allocatable :: cpi_avg (:) real, dimension(:,:), allocatable :: cpi_hist real :: cu_ave real :: cu_sig logical :: details character(len=64) :: fn_in real :: fsurf integer :: i integer :: j real, allocatable :: k_hist (:) integer, parameter :: n_dat = n_in+3 integer, parameter :: n_echo = n_in+1 integer, parameter :: n_in = 15 integer, parameter :: n_out = n_in+2 real :: ni_ave real :: ni_sig integer, parameter :: nmaterials = 2 integer :: nsim integer :: ntime integer :: num_seeds real, allocatable :: r_tndt (:) real :: rtndt0 type( random_samples_t ), allocatable :: samples (:) real, dimension(:), allocatable :: stress real, dimension(:), allocatable :: temp Source Code program miniFAVOR use I_O , only : read_In , write_Out use calc_RTndt , only : RTndt , CF , sample_chem use calc_K , only : Ki_t use calc_cpi , only : cpi_t use randomness_m , only : random_samples_t implicit none ! Variables character ( len = 64 ) :: fn_IN integer , parameter :: n_IN = 15 integer , parameter :: n_ECHO = n_IN + 1 integer , parameter :: n_OUT = n_IN + 2 integer , parameter :: n_DAT = n_IN + 3 integer :: i , j , num_seeds type ( random_samples_t ), allocatable :: samples (:) ! Inputs real :: a , b integer :: nsim , ntime logical :: details real , dimension (:), allocatable :: stress , temp real :: Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 ! Outputs real , allocatable :: K_hist (:) real , allocatable :: Chemistry_factor (:) real , allocatable :: R_Tndt (:) real , allocatable :: CPI (:) real , allocatable :: CPI_avg (:) real , dimension (:,:), allocatable :: Chemistry_content real , dimension (:,:), allocatable :: cpi_hist integer , parameter :: nmaterials = 2 ! Body of miniFAVOR !Get input file name call random_seed ( size = num_seeds ) call random_seed ( put = [( i , i = 1 , num_seeds )]) print * , 'Input file name:' read ( * , '(a)' ) fn_IN !Read input file call read_IN ( fn_IN , n_IN , n_ECHO , & a , b , nsim , ntime , details , Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 , stress , temp ) !Allocate output arrays allocate ( Chemistry_content ( nsim , nmaterials )) allocate ( Chemistry_factor ( nsim )) allocate ( cpi_hist ( nsim , ntime )) allocate ( R_Tndt ( nsim ), CPI ( nsim ), CPI_avg ( nsim ), samples ( nsim )) !Calculate applied stress intensity factor (SIF) K_hist = Ki_t ( a , b , stress ) ! This cannot be parallelized or reordered without the results changing do i = 1 , nsim call samples ( i )% define () end do !Start looping over number of simulations Vessel_loop : do i = 1 , nsim !Sample chemistry: Chemistry_content(i,1) is Cu content, Chemistry_content(i,2) is Ni content call sample_chem ( Cu_ave , Ni_ave , Cu_sig , Ni_sig , Chemistry_content ( i , 1 ), Chemistry_content ( i , 2 ), samples ( i )) !Calculate chemistry factor: Chemistry_factor(i) is chemistry factor Chemistry_factor ( i ) = CF ( Chemistry_content ( i , 1 ), Chemistry_content ( i , 2 )) !Calculate RTndt for this vessel trial: CPI_results(i,1) is RTndt R_Tndt ( i ) = RTndt ( a , Chemistry_factor ( i ), fsurf , RTndt0 , samples ( i )% phi ()) !Start time loop Time_loop : do j = 1 , ntime !Calculate instantaneous cpi(t) cpi_hist ( i , j ) = cpi_t ( K_hist ( j ), R_Tndt ( i ), temp ( j )) end do Time_loop !Calculate CPI for vessel 'i' CPI ( i ) = maxval ( cpi_hist ( i ,:)) !Calculate moving average CPI for trials executed so far CPI_avg ( i ) = sum ( CPI ( 1 : i )) / i end do Vessel_loop call write_OUT ( fn_IN , n_OUT , n_DAT , & a , b , nsim , ntime , details , Cu_ave , Ni_ave , Cu_sig , Ni_sig , fsurf , RTndt0 , & R_Tndt , CPI , CPI_avg , K_hist , Chemistry_content , Chemistry_factor ) end program miniFAVOR","tags":"","loc":"program/minifavor.html","title":"minifavor – miniFAVOR"},{"text":"Contents Subroutines run Subroutines subroutine run () Arguments None","tags":"","loc":"program/main.html","title":"main – miniFAVOR"},{"text":"Uses iso_varying_string Contents None","tags":"","loc":"program/simple_put_line.html","title":"simple_put_line – miniFAVOR"},{"text":"Uses iso_varying_string Contents Variables string Variables Type Attributes Name Initial type( varying_string ) :: string","tags":"","loc":"program/simple_get.html","title":"simple_get – miniFAVOR"},{"text":"Contents Subroutines run Subroutines subroutine run () Arguments None","tags":"","loc":"program/main~2.html","title":"main – miniFAVOR"},{"text":"Uses iso_varying_string Contents None","tags":"","loc":"program/simple_put.html","title":"simple_put – miniFAVOR"},{"text":"Uses iso_fortran_env iso_varying_string Contents Variables file_unit separator stat string Variables Type Attributes Name Initial integer :: file_unit type( varying_string ) :: separator integer :: stat type( varying_string ) :: string","tags":"","loc":"program/round_trip.html","title":"round_trip – miniFAVOR"},{"text":"Uses iso_fortran_env iso_varying_string Contents Variables stat string Variables Type Attributes Name Initial integer :: stat type( varying_string ) :: string","tags":"","loc":"program/get_iostat.html","title":"get_iostat – miniFAVOR"},{"text":"Uses iso_varying_string Contents Variables separator string Variables Type Attributes Name Initial type( varying_string ) :: separator type( varying_string ) :: string","tags":"","loc":"program/get_terminator.html","title":"get_terminator – miniFAVOR"},{"text":"Uses iso_varying_string Contents Variables hello remaining Variables Type Attributes Name Initial type( varying_string ) :: hello type( varying_string ) :: remaining","tags":"","loc":"program/get_maxlen.html","title":"get_maxlen – miniFAVOR"},{"text":"Uses iso_varying_string Contents None","tags":"","loc":"program/string_put_line.html","title":"string_put_line – miniFAVOR"},{"text":"Uses iso_varying_string Contents None","tags":"","loc":"program/string_put.html","title":"string_put – miniFAVOR"},{"text":"Uses iso_varying_string make_driver_m Contents Variables argument driver_file i num_arguments program_name test_files Variables Type Attributes Name Initial character(len=1000) :: argument type( varying_string ) :: driver_file integer :: i integer :: num_arguments character(len=100) :: program_name type( varying_string ), allocatable :: test_files (:)","tags":"","loc":"program/make_vegetable_driver.html","title":"make_vegetable_driver – miniFAVOR"},{"text":"Contents Subroutines run Subroutines subroutine run () Arguments None","tags":"","loc":"program/main~3.html","title":"main – miniFAVOR"},{"text":"Contents Subroutines run Subroutines subroutine run () Arguments None","tags":"","loc":"program/main~4.html","title":"main – miniFAVOR"},{"text":"Contents Subroutines run Subroutines subroutine run () Arguments None","tags":"","loc":"program/main~5.html","title":"main – miniFAVOR"}]}